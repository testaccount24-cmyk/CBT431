//JOBNAME JOB ACCOUNT,'NAME'
//*------------------------------------------------------------------*/
//*                                                                  */
//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1995    */
//*                                                                  */
//* This software is provided on an "AS IS" basis. All warranties,   */
//* including the implied warranties of merchantability and fitness, */
//* are expressly denied.                                            */
//*                                                                  */
//* Provided this copyright notice is included, this software may    */
//* be freely distributed and not offered for sale.                  */
//*                                                                  */
//* Changes or modifications may be made and used only by the maker  */
//* of same, and not further distributed. Such modifications should  */
//* be mailed to the author for consideration for addition to the    */
//* software and incorporation in subsequent releases.               */
//*                                                                  */
//*------------------------------------------------------------------*/
//*
//*    IPCS Verb Exits, ISPF Panels and CLISTs
//*
//*
//* Author: Steve Bacher <seb@draper.com>
//*
//* Date: 26 Sep 1997
//*
//*-------------------------------------------------------------------
//*
//* This job creates the distribution libraries (PDS's).
//*
//* Run this JCL to create the PDS's, after customizing to suit.
//* (Obviously, put in a good JOB statement first.)
//* To customize the JCL, change the defaults on the //MDLOAD PROC
//* statement to your liking, particularly the PREFIX default.
//* You might also want to change the final qualifiers of the PDS's
//* created - to do this, find the // EXEC MDLOAD statements and
//* change the value of the TO parameter.
//*
//* See the $$README file (of the CNTL PDS, first in this stream)
//* for the rest of the installation instructions.
//*
//MDLOAD PROC CLS='*',BS='6160',U='SYSDA',V='',
//      TRK1='30',TRK2='10',DIR='35',RLSE='RLSE',
//      PREFIX='SYS8.IPCS.'
//*
//IEBUPDTE EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD SYSOUT=&CLS
//SYSUT2 DD DISP=(NEW,CATLG,DELETE),DSN=&PREFIX.&TO,
//  DCB=(RECFM=FB,LRECL=80,BLKSIZE=&BS),
//  SPACE=(TRK,(&TRK1,&TRK2,&DIR),&RLSE),UNIT=&U,VOL=SER=&V
//*
//  PEND
//*
//CNTL     EXEC MDLOAD,BS='6160',TRK1='5',TRK2='1',TO='CNTL'
//SYSIN    DD   DATA,DLM='?!'
./ ADD NAME=$$README
This distribution contains IPCS CLISTs, panels, and verb exits.

You must assemble the verb exits and store the resultant load modules
in a library allocated to ISPLLIB and/or referenced in an IPCS
"TASKLIB" library.

You must also insure that the CLISTs are accessible in the SYSPROC
concatenation, the panels are accessible in the ISPPLIB concatenation,
etc.

Note that these are made available AS IS.  There are a few references
to utilities local to Draper, e.g.:

 XDELETE = replacement for IBM's "DELETE" command
 XDSTAT  = reports on status of an MVS data set
 XLC     = replacement for IBM's "LISTC"  command

 XPROC   = available from your friendly MVS FTP site, probably
 the same one you got this stuff from.  Some of the REXX execs use it.
 If you don't have it, get it - it's worth it.

You should make suitable changes to the CLISTs that reference these.

=======================================================================

Other warnings:

These were written originally for an MVS/XA system and then
migrated to MVS/ESA.  All caveats apply.

The stuff that runs under IPCS is in CLIST, because I wrote them
before IPCS had full REXX support.  The handful of REXX execs are
things that run as TSO commands, even if from within ISPF or IPCS.

For the stuff that references fields in SWA control blocks, like the
JFCB, you must be running with SWA below the line.  I have no idea
how to process SWA above the line from IPCS, and IBM has not been
any help in this area either.

=======================================================================

If you have any questions, feel free to send email to:

 Steve Bacher <batchman@draper.com>

./ ENDUP
?!
//CLIST    EXEC MDLOAD,BS='6160',TRK1='20',TRK2='1',TO='CLIST'
//SYSIN    DD   DATA,DLM='?!'
./ ADD NAME=ACTIVE
PROC 0 +
       XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
ELSE CONTROL NOMSG
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
EVAL 224.%+24 SIGNED LENGTH(2) CLIST(S(ASID)) ACTIVE
IF &LASTCC = 12 THEN DO
 WRITE Unable to access ASID in active main storage.
 EXIT C(12) Q
END
SETDEF ACTIVE ASID(&ASID)
./ ADD NAME=BINARY
PROC 1 NUMBER XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
ELSE CONTROL NOMSG
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
INTEGER &NUMBER UNSIGNED CLIST(S(FIXNUM))
CONTROL NOFLUSH
ERROR DO
 ERROR OFF
 WRITE Value out of range or invalid, &NUMBER
 EXIT C(12) Q
END
IF &FIXNUM < 0 | &FIXNUM > 255 THEN DO
 WRITE Value out of range, &NUMBER
 EXIT C(12) Q
END
ERROR OFF
SET I = 1
SET J = 128
DO WHILE &J > 0
 SET B&I = &FIXNUM / &J
 SET FIXNUM = &FIXNUM // &J
 SET I = &I + 1
 SET J = &J / 2
END
SET BINARY = &STR(&B1&B2&B3&B4&B5&B6&B7&B8)
IF &SYSNEST = NO THEN NOTE '&BINARY' ASIS
EXIT CODE(&BINARY)
./ ADD NAME=BROWSE
/* REXX. Usage: BROWSE address otherparms        */
/*       See OBROWSE for old version.            */
/*
say "browse"
trace r
if sysvar("syspcmd") \= "IPCS" then do
  say "*** You must be in IPCS to use this CLIST. ***"
  exit 16
end
 */
signal on halt
parse arg addr parms
if addr \= "" then do
 address ISPEXEC "SELECT PGM(BLSGSCMD) PARM(EQ X "addr")"
 if rc \= 0  then do; say "Error, bad IPCS environment";exit rc;end
 parms = "PANEL(STORAGE)" parms
end
else do
 parms = "PANEL(POINTER)" parms
end
address ISPEXEC,
        "SELECT PGM(BLSLDISP) NEWAPPL(BLSL) PASSLIB PARM("parms")"
if rc \= 0  then do; say "Error, bad IPCS environment";exit rc;end
exit rc
halt:exit
./ ADD NAME=CPUID
/* rexx (this takes 72 msec vs. CLIST OCPUID's 430 msec */

pccavt = c2d(storage(d2x(c2d(storage(10,4))+764),4))
do cpu = 0 to 15
 pccapointer = c2d(storage(d2x(pccavt+(cpu*4)),4))
 if pccapointer ^= 0 then do
  cpuserial = storage(d2x(pccapointer+4) ,8)
  cpuid     = storage(d2x(pccapointer+12),4)
  say
  say "CPU #"cpu" ID = "cpuid
  say "CPU #"cpu" serial number = "cpuserial
 end
end
exit
./ ADD NAME=DCB
PROC 1 DCBADDRESS TCBADDRESS(21C.%) XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
IF &SUBSTR(1:4,&DCBADDRESS    ) = &SUBSTR(1:4,DCB()) THEN +
 SET DCBADDRESS = &SUBSTR(5:&LENGTH(&STR(&DCBADDRESS))-1,&DCBADDRESS)
IF &STR(&DCBADDRESS) ^= DCB THEN +
 EQ DCB &DCBADDRESS L(96) NODROP
EVAL &DCBADDRESS L(96) CLIST(S(DCB))
IF &LASTCC ^= 0 THEN DO
 NOTE 'Error: DCB at &DCBADDRESS not accessible.' ASIS
 EXIT C(12) Q
END
%DUMPCB DCB &DCBADDRESS 96
CONTROL NOFLUSH
SET ERROK = N
ERROR DO
 SET CC = &LASTCC
 IF &ERROK = Y THEN RETURN
 ERROR OFF
 IF &CC = 12 THEN DO
  NOTE 'Error accessing storage - DCB processing terminated.' ASIS
  EXIT C(12) Q
 END
 WRITE Major error processing &SYSSCMD subcommand - LASTCC=&CC
 EXIT C(16) Q
END
/*
/* First get DSORG.  This determines DCB type as well.
/*
EVAL &DCBADDRESS+1A L(2) HEX CLIST(S(DSORG))
SELECT &STR(&DSORG)
 WHEN (&STR(8000)) SET DSORG = IS
 WHEN (&STR(8100)) SET DSORG = ISU
 WHEN (&STR(4000)) SET DSORG = PS
 WHEN (&STR(4100)) SET DSORG = PSU
 WHEN (&STR(2000)) SET DSORG = DA
 WHEN (&STR(2100)) SET DSORG = DAU
 WHEN (&STR(1000)) SET DSORG = CX
 WHEN (&STR(0200)) SET DSORG = PO
 WHEN (&STR(0300)) SET DSORG = POU
 WHEN (&STR(0080)) SET DSORG = GS
 WHEN (&STR(0040)) SET DSORG = TX
 WHEN (&STR(0020)) SET DSORG = TQ
 WHEN (&STR(0008)) SET DSORG = VSAM
 WHEN (&STR(0004)) SET DSORG = TR
 WHEN (&STR(0000)) SET DSORG = NONE
 OTHERWISE         SET DSORG = &STR(X''&DSORG'')
END
/*
/* Get record format.
/*
EVAL &DCBADDRESS+24 L(1) HEX CLIST(S(HEXRF))
SET CC = 0
SET ERROK = Y
%BINARY X'&HEXRF'
SET ERROK = N
SET BINRF = &SUBSTR(2:9,&EVAL(100000000+&CC))
SELECT &SUBSTR(1:3,&BINRF)
 WHEN (&STR(000)) SET RECFM = ?
 WHEN (&STR(001)) SET RECFM = D
 WHEN (&STR(010)) SET RECFM = V
 WHEN (&STR(011)) SET RECFM = VT
 WHEN (&STR(100)) SET RECFM = F
 WHEN (&STR(101)) SET RECFM = FT
 WHEN (&STR(110)) SET RECFM = U
 WHEN (&STR(111)) SET RECFM = UT
END
IF &SUBSTR(4,&BINRF) = 1 THEN SET RECFM = &RECFM.B
IF &SUBSTR(5,&BINRF) = 1 THEN SET RECFM = &RECFM.S
IF &SUBSTR(6,&BINRF) = 1 THEN SET RECFM = &RECFM.A
IF &SUBSTR(7,&BINRF) = 1 THEN SET RECFM = &RECFM.M
IF &RECFM = ? THEN SET RECFM = X''&HEXRF''
/*
/* Get KEYLEN if low-order bit of RECFM byte is on.
/*
IF &SUBSTR(8,&BINRF) = 1 THEN DO
 EVAL &DCBADDRESS+10 L(1) UNS CLIST(S(KEYLEN))
 SET KEYLENEQ = &STR(,KEYLEN=&EVAL(&KEYLEN))
END
ELSE SET KEYLENEQ =
/*
/* Get other DCB attributes.
/*
EVAL &DCBADDRESS+3E L(2) SIG CLIST(S(BLKSIZE))
EVAL &DCBADDRESS+52 L(2) SIG CLIST(S(LRECL))
/*
/* Display basic DCB attributes.
/*
NOTE +
 'RECFM=&RECFM,LRECL=&LRECL,BLKSIZE=&BLKSIZE,DSORG=&DSORG&KEYLENEQ' +
 ASIS
NOTE SPACE(1)
/*
/* Now see if dataset is open.  Certain fields are in different places
/* depending on this.
/*
SET CC = 0
SET ERROK = Y
COMPARE ADDRESS(&DCBADDRESS+30) WITH(VALUE(X'10')) MASK(X'10') LENGTH(1)
SET ERROK = N
IF &CC = 0 THEN DO /* dataset is open */
 EVAL &DCBADDRESS+2D           L(3) PTR CLIST(S(DEBADDRESS))
 EVAL &DEBADDRESS..+1          L(3) PTR CLIST(S(TCBADDRESS)
 EVAL &DCBADDRESS+28           L(2) HEX CLIST(S(TOFF))
 EVAL &TCBADDRESS..+C%+&TOFF+4 L(8) CHAR CLIST(S(DDNAME))
 NOTE 'Dataset is open - DEB at &DEBADDRESS, TCB at &TCBADDRESS' ASIS
 NOTE 'DDNAME is &DDNAME' ASIS
 EVAL &TCBADDRESS..+C%+&TOFF+C L(3) PTR CLIST(S(JFCBADDR))
 SET CC = 0
 SET ERROK = Y
 EVAL &JFCBADDR..+10 L(44) CHAR CLIST(S(DSNAME))
 IF &CC = 12 THEN GOTO SKIPJFCB
 EVAL &JFCBADDR..+3C L(8)  CHAR CLIST(S(MEMBER))
 IF &CC = 12 THEN GOTO SKIPJFCB
 EVAL &JFCBADDR..+86 L(6)  CHAR CLIST(S(VOLUME))
 IF &CC = 12 THEN GOTO SKIPJFCB
 SET ERROK = N
 NOTE 'DSNAME is &DSNAME' ASIS
 IF &STR(&MEMBER) ^= THEN +
  NOTE 'MEMBER is &MEMBER' ASIS
 NOTE 'VOLUME is &VOLUME' ASIS
 SKIPJFCB:+
 SET OPEN = Y
END
ELSE DO
 EVAL &DCBADDRESS+28 L(8) CHAR CLIST(S(DDNAME))
 EVAL &DCBADDRESS+28 L(2) HEX CLIST(S(TOFF))
 IF &SUBSTR(1,&TOFF ) = 0 THEN DO
  NOTE 'Dataset is not open' ASIS
  EVAL 21C.%+C%+&TOFF+4 L(8) CHAR CLIST(S(DDNAME))
  NOTE 'DDNAME is &DDNAME' ASIS
  EVAL 21C.%+C%+&TOFF+C L(3) PTR CLIST(S(JFCBADDR))
  SET CC = 0
  SET ERROK = Y
  EVAL &JFCBADDR..+10 L(44) CHAR CLIST(S(DSNAME))
  IF &CC = 12 THEN GOTO SKIPJ2
  EVAL &JFCBADDR..+3C L(8)  CHAR CLIST(S(MEMBER))
  IF &CC = 12 THEN GOTO SKIPJ2
  EVAL &JFCBADDR..+86 L(6)  CHAR CLIST(S(VOLUME))
  IF &CC = 12 THEN GOTO SKIPJ2
  SET ERROK = N
  NOTE 'DSNAME is &DSNAME' ASIS
  IF &STR(&MEMBER) ^= THEN +
   NOTE 'MEMBER is &MEMBER' ASIS
  NOTE 'VOLUME is &VOLUME' ASIS
  SKIPJ2:+
 END
 ELSE DO
  NOTE 'Dataset is closed' ASIS
  NOTE 'DDNAME is &DDNAME' ASIS
 END
 SET OPEN = N
END
NOTE SPACE(1)
EVAL &DCBADDRESS+00 L(4) HEX CLIST(S(Z))
NOTE 'RELAD  &SUBSTR(1:16,&Z        )  TTRN of current PDS member' ASIS
EVAL &DCBADDRESS+05 L(8) HEX CLIST(S(Z))
NOTE 'FDAD   &Z  MBBCCHHR of record just read or written' ASIS
EVAL &DCBADDRESS+10 L(1) UNS CLIST(S(Z))
NOTE 'KEYLE  &SUBSTR(1:16,&Z                )  Key length' ASIS
EVAL &DCBADDRESS+14 L(1) UNS CLIST(S(Z))
NOTE 'BUFNO  &SUBSTR(1:16,&Z                )  Buffer number' ASIS
EVAL &DCBADDRESS+15 L(3) PTR CLIST(S(Z))
NOTE 'BUFCB  &Z            Address of buffer pool control block' ASIS
EVAL &DCBADDRESS+18 L(2) SIG CLIST(S(Z))
NOTE 'BUFL   &SUBSTR(1:16,&Z                )  Buffer length' ASIS
EVAL &DCBADDRESS+1C L(4) PTR CLIST(S(Z))
NOTE 'IOBAD  &Z          Address of IOB for chained scheduling' ASIS
EVAL &DCBADDRESS+20 L(1) HEX CLIST(S(Z))
NOTE 'BFTEK  &SUBSTR(1:16,&Z                )  Buffering technique' ASIS
EVAL &DCBADDRESS+21 L(3) PTR CLIST(S(Z))
NOTE 'EODAD  &Z            Address of end-of-data routine' ASIS
EVAL &DCBADDRESS+25 L(3) HEX CLIST(S(Z))
NOTE 'EXLST  &Z            Address of exit list' ASIS
EVAL &DCBADDRESS+34 L(1) HEX CLIST(S(Z))
NOTE 'OPTCD  &SUBSTR(1:16,&Z                )  Option codes' ASIS
EVAL &DCBADDRESS+39 L(3) PTR CLIST(S(Z))
NOTE 'SYNAD  &Z            Address of SYNAD routine' ASIS
EVAL &DCBADDRESS+45 L(3) PTR CLIST(S(Z))
NOTE 'IOBA   &Z            Address of IOB or ICB' ASIS
EVAL &DCBADDRESS+50 L(2) UNS CLIST(S(Z))
NOTE 'DIRCT  &SUBSTR(1:16,&Z                )  +
Bytes used in last directory block' ASIS
EVAL &DCBADDRESS+48 L(1) UNS CLIST(S(Z))
NOTE 'NCP    &SUBSTR(1:16,&Z                )  +
Number of channel programs' ASIS
IF &DSORG = PS THEN DO
 EVAL &DCBADDRESS+48 L(4) PTR CLIST(S(Z))
 NOTE 'EOBAD  &Z          Address of last byte of current buffer' ASIS
 EVAL &DCBADDRESS+4C L(4) PTR CLIST(S(R))
 NOTE 'RECAD  &R          Address of current or next logical record' +
      ASIS
 IF &LRECL = 0 THEN SET RECLEN = &BLKSIZE
 ELSE SET RECLEN = &LRECL
 SET CC = 0
 NOTE SPACE(1)
 IF &CC = 0 THEN DO
  SET ERROK = Y
  %DUMPCB LAST_LOGICAL_RECORD &R..-&RECLEN.N &RECLEN &XTRACE
  IF &CC = 0 THEN DO
   %DUMPCB NEXT_LOGICAL_RECORD &R..          &RECLEN &XTRACE
  END
  SET ERROK = N
 END
END
./ ADD NAME=DOTCBS
PROC 1 COMMAND PARMS() ARGUMENTPOSITIONAL XTRACE
/*********************************************************************/
/*                                                                   */
/* Function: This CLIST executes an IPCS subcommand or CLIST for all */
/*           TCBs in a memory contained in the dump being analyzed.  */
/*           In this way it is similar to RUNCHAIN.  The CLIST is    */
/*           executed with the specified parameters plus the keyword */
/*           "TCB(address)", where the TCB address is provided for   */
/*           each TCB.                                               */
/*                                                                   */
/* SYNTAX:   %DOTCBS command P('...')                                */
/*                                                                   */
/*********************************************************************/
CONTROL NOCAPS
/**********************************************************************/
/*                                                                    */
/* Get the current ASID.                                              */
/*                                                                    */
/**********************************************************************/
%GETASID &XTRACE
SET ASID = &LASTCC

EVAL 224. PTR CLIST(S(ASCBADDR))
EVAL &ASCBADDR..+6C PTR CLIST(S(ASXBADDR))
IF &LASTCC=12 THEN DO
 NOTE '==> Error: ASXB not available for ASID(&ASID)' ASIS
 EXIT C(16) Q
END

EVAL &ASXBADDR..+5 LE(3) PTR CLIST(S(TCBADDR))
IF &LASTCC=12 THEN DO
 L &ASXBADDR..+5 LE(3) PTR
 NOTE '==> Error: TCB&TCBCTR not available for ASID(&ASID)' ASIS
 EXIT C(16) Q
END

IF &TCBADDR = 0 THEN DO
 NOTE SPACE(1)
 NOTE '--- No TCB''s to process for &NRSTR(&COMMAND).' ASIS
 EXIT
END

/******************************************************************/
/* Process all TCBs for this address space                        */
/******************************************************************/

CONTROL NOFLUSH

NOTE SPACE(1)

DO WHILE &TCBADDR^=0
 INTEGER X'&TCBADDR' PTR CLIST(S(TCBADDR))

 IF &ARGUMENTPOSITIONAL = THEN +
  SET CMDSTR = &NRSTR(&COMMAND TCB(&TCBADDR..) &PARMS)
 ELSE +
  SET CMDSTR = &NRSTR(&COMMAND &TCBADDR &PARMS)

 NOTE SPACE(1)
 NOTE '--- &NRSTR(&COMMAND) --- TCB at &TCBADDR.. ---' ASIS
 WRITE &NRSTR(&CMDSTR)
 NOTE SPACE(1)
 &NRSTR(&CMDSTR)
 WRITE

 EVAL &TCBADDR..+75 LE(3) PTR CLIST(S(TCBADDR))
 IF &LASTCC=12 THEN DO
  NOTE '==> Error: Cannot access next TCB pointer from &TCBADDR for +
                   ASID(&ASID)' ASIS
  EXIT C(4)
 END
END

EXIT

./ ADD NAME=DUMP
PROC 1 ADDRESS LENGTHVALUE() XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
SET LP = &SUBSTR(1,())
SET RP = &SUBSTR(2,())
SET L = &LENGTH(&STR(&ADDRESS))
IF &SUBSTR(&L,&ADDRESS) = &STR(&RP) THEN DO
 SET I = 0
 DO WHILE &I LT &L-1
  SET I = &I + 1
  IF &SUBSTR(&I,&ADDRESS) = &STR(&LP) THEN DO
   SET &CB = &SUBSTR(1:&I-1,&ADDRESS)
   IF &LENGTHVALUE = THEN DO
    IF &STR(&CB) = TCB THEN SET LENGTHVALUE = 376
    ELSE SET LENGTHVALUE = 256
   END
   %DUMPCB &CB &SUBSTR(&I+1:&L-1,&ADDRESS) &LENGTHVALUE
   EXIT C(&LASTCC)
  END
 END /* Do while */
END
ELSE DO
 IF &LENGTHVALUE = THEN SET LENGTHVALUE = 256
 %DUMPCB DUMPDATA &ADDRESS &LENGTHVALUE
END
./ ADD NAME=DUMPCB
PROC 3 CBNAME CBADDRESS CBLENGTH OFFSET(0) TITLE() NOTITLE NOSKIP XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
IF &NRSTR(&TITLE&NOTITLE) = THEN +
 SET TITLE = &NRSTR(&CBNAME at &CBADDRESS)
IF &NOSKIP = THEN NOTE SPACE(1)
IF &LASTCC ^= 0 THEN EXIT C(4)
INTEGER &CBLENGTH SIGNED CLIST(S(CBLENGTH))
IF &LASTCC = 12 THEN DO
 WRITE Invalid length value, &CBLENGTH
 EXIT Q
END
EVAL &CBADDRESS L(&CBLENGTH) HEX CLIST(S(CBHEX))
IF &LASTCC = 12 THEN GOTO ERROR
EVAL &CBADDRESS L(&CBLENGTH) CHAR CLIST(S(CBCHAR))
IF &LASTCC = 12 THEN GOTO ERROR
EQ TEMP$$$$ &CBADDRESS+0
EVALSYM TEMP$$$$ CLIST(ADDRESS(CBADDRESS) POSITION(CBPOSITION))
INTEGER X'&CBADDRESS'  SIGNED CLIST(S(V))
INTEGER X'&CBPOSITION' SIGNED CLIST(S(P))
SET V = &V + &P
INTEGER &V PTR CLIST(S(CBADDRESS))
IF &NOTITLE = THEN DO
 NOTE '&TITLE' ASIS
 IF &LASTCC ^= 0 THEN EXIT C(4)
 IF &NOSKIP = THEN NOTE SPACE(1)
 IF &LASTCC ^= 0 THEN EXIT C(4)
END
DO J = 0 TO &CBLENGTH-1 BY 16
 SET HOWLONG = &CBLENGTH - &J
 IF &HOWLONG > 16 THEN SET HOWLONG = 16
 EVAL &CBADDRESS..+&J.N L(&HOWLONG) HEX CLIST(S(HEXLINE))
 IF &LASTCC = 12 THEN GOTO ERROR
 SET HEXLINE = &SUBSTR(1:32,&HEXLINE                                )
 EVAL &CBADDRESS..+&J.N L(&HOWLONG) CHAR CLIST(S(CHARLINE) ENQUOTE)
 IF &LASTCC = 12 THEN GOTO ERROR
 SET CHARLINE = &SUBSTR(2:&LENGTH(&NRSTR(&CHARLINE))-1,&NRSTR(&CHARLINE)
 SET CURRENT_OFFSET = &J+(&OFFSET)
 IF &CURRENT_OFFSET < 0 THEN DO
  INTEGER &EVAL(0-(&CURRENT_OFFSET)) PTR(6) CLIST(S(LABEL))
  SET SIGN = &STR(-)
 END
 ELSE DO
  INTEGER &CURRENT_OFFSET PTR(6) CLIST(S(LABEL))
  SET SIGN = &STR(+)
 END
 INTEGER &V PTR(8) CLIST(S(X))
 NOTE ' &SIGN&LABEL  &X  &SUBSTR(01:08,&HEXLINE) +
                         &SUBSTR(09:16,&HEXLINE) +
                         &SUBSTR(17:24,&HEXLINE) +
                         &SUBSTR(25:32,&HEXLINE)  *+
                         &NRSTR(&CHARLINE)*' ASIS
 IF &LASTCC ^= 0 THEN EXIT C(4)
 SET V = &V + 16
END
NOTE SPACE(1)
EXIT
ERROR:+
NOTE 'Error: &CBNAME at &CBADDRESS not available (length &CBLENGTH)' ASI
EXIT C(12) Q
END
./ ADD NAME=DUMPRB
PROC 0 TCB() XTRACE
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
/* Code to extract current TCB
IF &STR(&TCB) = THEN DO
 SET TCB = 0
 EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))
 IF &TCB = 0 THEN DO
  EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))
  IF &TCB = 0 THEN DO
   EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))
   IF &TCB = 0 THEN DO
    NOTE 'TCB unavailable' ASIS
    EXIT C(12) Q
   END
  END
 END
END
/* End code to extract current TCB
%DUMPCB RB_PREFIX &TCB+0%-40 64
%DUMPCB RB &TCB+0% 240
EXIT
./ ADD NAME=ENQ
PROC 1 R1 XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END

NOTE 'ENQ (SVC 56) info: +
      MVS/XA Debugging Handbook, Vol. 1 - p. 5-31' +
     SPACE(1) ASIS

TCBX YITADDR &R1
SET E1 = &STR(&YITHEX)
TCBX YITADDR &E1..-20
SET E2 = &STR(&YITHEX)

DO UNTIL &DO_IT_AGAIN = 4
 SYSCALL DO_IT &E1 &E2
 SET DO_IT_AGAIN = &LASTCC
 TCBX YITADDR &E1..+20
 SET E1 = &STR(&YITHEX)
END

EXIT

DO_IT: PROC 2 E1 E2

/*
/* Stupid code to get around SYSREF lossage.
/*
SET SYSDVAL =
READDVAL ENQPLIST ENQMASID BITS +
         FLAGBITS RNAMELEN ENQPARMS +
         ENQRCODE QNAMEPTR RNAMEPTR UCB_WORD

SYSCALL ISET ENQPLIST &E1 L(20) DUMPCB

SYSCALL EXTRACT ENQPLIST FLAGBITS  0 L(1)    DUMP
SYSCALL EXTRACT ENQPLIST RNAMELEN  1 L(1)    DUMP
SYSCALL EXTRACT ENQPLIST ENQPARMS  2 L(1)    DUMP
SYSCALL EXTRACT ENQPLIST ENQRCODE  3 L(1)    DUMP
SYSCALL EXTRACT ENQPLIST QNAMEPTR  4 L(4)    DUMP
SYSCALL EXTRACT ENQPLIST RNAMEPTR  8 L(4)    DUMP
SYSCALL EXTRACT ENQPLIST UCB_WORD 12 L(4)    DUMP

NOTE SPACE(1)

SYSCALL SETBITS BITS FLAGBITS
SET MASID = N
SET END_OF_LIST = N
IF &SUBSTR(1,&BITS) = 1 THEN DO
 NOTE '  End-of-list indicator on '  ASIS
 SET END_OF_LIST = Y
END
IF &SUBSTR(2,&BITS) = 1 THEN DO
 NOTE '  Old options are in effect' ASIS
 GOTO SKIP_OTHER_BITS
END
IF &SUBSTR(3,&BITS) = 1 THEN NOTE '  Reserved bit on!!!!!!!'     ASIS
IF &SUBSTR(4,&BITS) = 1 THEN NOTE '  Resource owned shared'      ASIS
ELSE                         NOTE '  Resource owned exclusively' ASIS
IF &SUBSTR(5,&BITS) = 1 THEN DO
 NOTE '  MASID prefix present'       ASIS
 SET MASID = Y
END
IF &SUBSTR(6:7,&BITS) = &STR(01) THEN DO
 NOTE '  Generic DEQ requested'  ASIS
END
IF &SUBSTR(8,&BITS) = 1 THEN NOTE '  TCB=... requested        '  ASIS

SKIP_OTHER_BITS:+
IF &MASID = Y THEN DO

 SYSCALL ISET ENQMASID &E2 L(20) DUMPCB

END

SYSCALL SETBITS BITS ENQPARMS
IF &SUBSTR(1,&BITS) = 1 THEN NOTE '  Shared request' ASIS
ELSE NOTE '  Exclusive request' ASIS
SELECT &SUBSTR(2,&BITS)&SUBSTR(5,&BITS)
 WHEN (00)  NOTE '  SCOPE=STEP' ASIS
 WHEN (01)  NOTE '  RESERVE (see UCB_WORD for UCB address)' ASIS
 WHEN (10)  NOTE '  SCOPE=SYSTEM' ASIS
 WHEN (11)  NOTE '  SCOPE=SYSTEMS' ASIS
END

IF &SUBSTR(3,&BITS) = 1 THEN NOTE '  Obsolete bit on!!!!!!!'     ASIS
IF &SUBSTR(4,&BITS) = 1 THEN NOTE '  Step-must-complete (SMC)'   ASIS
SELECT &SUBSTR(6:8,&BITS)
 WHEN (000)  NOTE '  RET=NONE   ' ASIS
 WHEN (001)  NOTE '  RET=HAVE   ' ASIS
 WHEN (010)  NOTE '  RET=CHNG   ' ASIS
 WHEN (011)  NOTE '  RET=USE    ' ASIS
 WHEN (100)  NOTE '  ECB=...    ' ASIS
 WHEN (111)  NOTE '  RET=TEST   ' ASIS
 OTHERWISE   NOTE 'Invalid ENQPARMS:  &BITS'
END

NOTE SPACE(1)
SET QNAMEPTRDOT = &STR(&QNAMEPTR..)
SYSCALL FIXUP QNAMEPTRDOT
EVAL &QNAMEPTRDOT L(8) CHAR CLIST(S(QNAME))
IF &LASTCC = 12 THEN DO
 NOTE 'QNAME at &QNAMEPTRDOT (length 8) is not accessible in dump.' ASIS
 EVAL &QNAMEPTRDOT L(8) CHAR CLIST(S(QNAME)) ACTIVE
 IF &LASTCC = 0 THEN DO
  NOTE 'On the current (active) system it is:  &NRSTR(&QNAME)' ASIS
  NOTE SPACE(1)
 END
END
ELSE DO
 NOTE 'QNAME:  &NRSTR(&QNAME)' ASIS
END

INTEGER X'&RNAMELEN' UNS CLIST(S(RNAMELNN))
IF &RNAMELNN = 0 THEN DO
 NOTE 'RNAME length is zero' ASIS
END
ELSE DO
 SET RNAMEPTRDOT = &STR(&RNAMEPTR..)
 SYSCALL FIXUP RNAMEPTRDOT
 EVAL &RNAMEPTRDOT L(&RNAMELNN) CHAR CLIST(S(RNAME))
 IF &LASTCC = 12 THEN DO
  NOTE 'RNAME at &RNAMEPTRDOT (length &RNAMELNN) is not accessible' ASIS
 END
 ELSE DO
  NOTE 'RNAME:  &NRSTR(&RNAME)' ASIS
  EVAL &RNAMEPTRDOT L(&RNAMELNN) HEX CLIST(S(RNAMEX))
  NOTE '        (&RNAMEX)' ASIS
 END
END

IF &END_OF_LIST = Y THEN RETURN CODE(4)
ELSE RETURN CODE(0)

END DO_IT

EXTRACT: PROC 3 STRING VAR OFFSET LENGTHVALUE(4) DUMP
 SET VARNAME = &STR(&VAR)
 SYSREF VAR STRING
 SET X = 2*&OFFSET+1
 ERROR RETURN CODE(&LASTCC)
 SET VAR = &SUBSTR(&X:&X+2*&LENGTHVALUE-1,&STRING)
 IF &LASTCC = 932 THEN DO
  NOTE 'Error: Unable to extract &LENGTHVALUE bytes at offset &OFFSET +
               from data: &STRING' SPACE(1) ASIS
 END
 ELSE DO
  IF &DUMP = DUMP THEN DO
   NOTE '&VARNAME:  &VAR' ASIS
  END
 END
END

ISET: PROC 2 CLISTVAR FIELD DUMPCB +
             LENGTHVALUE(4) PTR POINTER SIGNED UNSIGNED
 SET TITLE = &STR(&CLISTVAR) /* before SYSREFfing
 SYSREF CLISTVAR
 SET CLISTVAR = &STR(<<<no_value>>>)
 IF &SYSINDEX(.,&FIELD) ^= 0 THEN DO
  SYSCALL FIXUP FIELD
 END
 EVAL &FIELD L(&LENGTHVALUE) &PTR &POINTER &SIGNED &UNSIGNED +
      CLIST(S(CLISTVAR))
 IF &LASTCC ^= 0 THEN DO
  NOTE 'Error: &NRSTR(&TITLE) at &NRSTR(&FIELD) not accessible.' ASIS
  EXIT C(12) Q
 END
 IF &DUMPCB = DUMPCB THEN %DUMPCB &TITLE &FIELD &LENGTHVALUE
 RETURN
END

FIXUP: PROC 1 AFIELD
 SYSREF AFIELD
 SET I = &SYSINDEX(.,&AFIELD)
 IF &I = 9 THEN DO
  SET I = &SYSINDEX(&SUBSTR(1,&AFIELD),89ABCDEF)
  IF &I ^= 0 THEN DO
   SET AFIELD = +
      &SUBSTR(&I,01234567)&SUBSTR(2:&LENGTH(&STR(&AFIELD)),&AFIELD)
  END
 END
END

SETBITS: PROC 2 BITS FROMWHAT
 SYSREF BITS FROMWHAT
 %BINARY X'&FROMWHAT'
 SET R = &LASTCC
 SET L = &LENGTH(&STR(&R))
 SET BITS = &SUBSTR(&L+1:&L+8,00000000&R)
END
./ ADD NAME=EQREGS
00010002PROC 1 REQUESTBLOCKADDRESS ACTIVE LIST
00020000IF &STR(&SYSPCMD) ^= IPCS THEN DO
00030000  WRITE *** YOU MUST BE IN IPCS TO USE THIS CLIST. ***
00040000  EXIT C(16) Q
00050000END
00060001IF &LIST = LIST THEN CONTROL LIST
00070001EQ REGS &REQUESTBLOCKADDRESS+20 L(64) &ACTIVE
00080001EQ R0   &REQUESTBLOCKADDRESS+20 L(4)  &ACTIVE
00090001EQ R1   &REQUESTBLOCKADDRESS+24 L(4)  &ACTIVE
00100001EQ R2   &REQUESTBLOCKADDRESS+28 L(4)  &ACTIVE
00110001EQ R3   &REQUESTBLOCKADDRESS+2C L(4)  &ACTIVE
00120001EQ R4   &REQUESTBLOCKADDRESS+30 L(4)  &ACTIVE
00130001EQ R5   &REQUESTBLOCKADDRESS+34 L(4)  &ACTIVE
00140001EQ R6   &REQUESTBLOCKADDRESS+38 L(4)  &ACTIVE
00150001EQ R7   &REQUESTBLOCKADDRESS+3C L(4)  &ACTIVE
00160001EQ R8   &REQUESTBLOCKADDRESS+40 L(4)  &ACTIVE
00170001EQ R9   &REQUESTBLOCKADDRESS+44 L(4)  &ACTIVE
00180001EQ R10  &REQUESTBLOCKADDRESS+48 L(4)  &ACTIVE
00190001EQ R11  &REQUESTBLOCKADDRESS+4C L(4)  &ACTIVE
00200001EQ R12  &REQUESTBLOCKADDRESS+50 L(4)  &ACTIVE
00210001EQ R13  &REQUESTBLOCKADDRESS+54 L(4)  &ACTIVE
00220001EQ R14  &REQUESTBLOCKADDRESS+58 L(4)  &ACTIVE
00230001EQ R15  &REQUESTBLOCKADDRESS+5C L(4)  &ACTIVE
./ ADD NAME=GETASID
PROC 0 LIST XTRACE
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
/*
/* This CLIST returns the ASID as a return code.
/*
ISPQRY
IF &LASTCC = 20 THEN DO
 WRITE ISPF services not available, assuming current ASID is correct.
 EXIT
END
DO WHILE ETERNITY=ETERNITY
 ISPEXEC DISPLAY PANEL(IPCASID) /* Choose an ASID. */
 SELECT &LASTCC
  WHEN (0) DO
            IF &STR(&OTHASID) ^= &STR() THEN DO
             INTEGER &OTHASID UNS CLIST(S(IPASID))
            END
            IF &STR(&IPASID) = &STR() THEN DO
             SET IPASID = &STR(N/A)
            END
            ELSE DO
             SETDEF ASID(&IPASID)
             IF &LIST = LIST THEN WRITE ASID is &IPASID
             EXIT C(&IPASID)
            END
           END
  WHEN (8) DO
            EXIT QUIT C(0)
           END
  OTHERWISE DO
             ISPEXEC DISPLAY PANEL(ISPTERM)
             EXIT QUIT C(0)
            END
 END
END
./ ADD NAME=GETSSVT
PROC 0 ACTIVE XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
/*SE CONTROL NOMSG
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END

/**********************************************************************/
/*                                                                    */
/* This CLIST finds the SSVT and similar control blocks.              */
/*                                                                    */
/**********************************************************************/

EVAL 10.?+128 L(4) PTR &ACTIVE   /* Get JESCT pointer from CVT  */+
              CLIST(S(JESCTP))
IF &LASTCC = 12 THEN DO
 NOTE 'JESCT pointer not available from CVT.' ASIS
 GOTO EXIT
END
IF &JESCTP = 00000000 THEN DO
 NOTE 'There is no JESCT.' ASIS
 GOTO EXIT
END
EQ JESCT &JESCTP.. L(112) &ACTIVE
EVAL &JESCTP.+18 L(4) PTR &ACTIVE /* Get SSCVT pointer from JESCT */ +
                 CLIST(S(SSCVTP))
IF &LASTCC = 12 THEN DO
 NOTE 'SSCVT pointer not available from JESCT.' ASIS
 GOTO EXIT
END
IF &SSCVTP = 00000000 THEN DO
 NOTE 'There is no SSCVT.' ASIS
 GOTO EXIT
END
EQ SSCVT &SSCVTP.. L(36) &ACTIVE
EVAL &SSCVTP..+10 L(4) PTR &ACTIVE  /* Get SSVT pointer from SSCVT */ +
                  CLIST(S(SSVTP))
IF &LASTCC = 12 THEN DO
 NOTE 'SSVT pointer not available from SSCVT.' ASIS
 GOTO EXIT
END
IF &SSVTP = 000000 THEN DO
 NOTE 'There is no SSVT.' ASIS
 GOTO EXIT
END
EQ SSVT &SSVTP.. L(260) &ACTIVE
EXIT:+
LISTSYM    (JESCT SSCVT SSVT)              &ACTIVE
EXIT
./ ADD NAME=HEADER

/**********************************************************************/
/*                                                                    */
/* Updated for ESA header format.                                     */
/*                                                                    */
/**********************************************************************/

PROC 0 EQUATEPREFIX() WHERE XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
CONTROL NOFLUSH
SET ERROK = N
ERROR DO
 SET CC = &LASTCC
 IF &ERROK = Y THEN RETURN CODE(&CC)
 ELSE GOTO ERROR_ERROR_ERROR
END
IF &WHERE = WHERE THEN +
 IF &STR(&EQUATEPREFIX) = &STR() THEN +
  SET EQUATEPREFIX = HEADERREGISTERWHERE
IF &STR(&EQUATEPREFIX) ^= &STR() THEN +
 SET SREP = &STR(EQUATEPREFIX(&EQUATEPREFIX))
ELSE SET SREP =
EVAL 0. HEADER L(2) CHAR CLIST(S(TEMP))
IF &STR(&TEMP) ^= DR THEN DO
 NOTE 'Warning: Header+0 not C''DR'' - not an SP/3 (ESA) dump.' ASIS
END
ERROR OFF
SET HDRASID  = &STR(N/A)
SET HDRASIDX = &STR(N/A)
SET HASID    = &STR(N/A)
SET HASIDX   = &STR(N/A)
SET PROGRAM  = &STR(N/A)
/* Offset of SDUMP common section... */
EVAL 168. HEADER L(2) HEX CLIST(S(COMMOFF))
IF &STR(&COMMOFF) ^= &STR(0000) THEN DO
 NOTE SPACE(1)
 NOTE '======================= Information from common section +
       ======================' ASIS
 NOTE SPACE(1)
 EVAL &COMMOFF..+48 HEADER L(2) UNS CLIST(S(PASID))
 INTEGER &PASID PTR(4) CLIST(S(PASIDX))
 EVAL &COMMOFF..+4A HEADER L(2) UNS CLIST(S(SASID))
 INTEGER &SASID PTR(4) CLIST(S(SASIDX))
 EVAL &COMMOFF..+4C HEADER L(2) UNS CLIST(S(HASID))
 INTEGER &HASID PTR(4) CLIST(S(HASIDX))
 NOTE 'ASID''s: Primary= &PASID (X''&PASIDX'')  +
       Secondary= &SASID (X''&SASIDX'')  +
       Home= &HASID (X''&HASIDX'')+
      ' ASIS
END
NOTE SPACE(1)
NOTE '======================= Information from dump header +
      =========================' ASIS
NOTE SPACE(1)
SET HDRASID  = &STR(&HASID)
SET HDRASIDX = &STR(&HASIDX)
EVAL 24. HEADER L(1) HEX CLIST(S(TEMP))
SELECT &STR(&TEMP)
 WHEN (01)  SET TYPE = &STR(a stand-alone dump)
 WHEN (02)  SET TYPE = &STR(an SVC dump)
 WHEN (03)  SET TYPE = &STR(a SYSMDUMP)
 WHEN (04)  SET TYPE = &STR(a SLIP dump)
 OTHERWISE  SET TYPE = &STR(an unknown (X''&TEMP'') kind of dump)
END
EVAL 40. HEADER L(8) CHAR CLIST(S(PROGRAM))
NOTE 'This is &TYPE for ASID &HDRASID (X''&HDRASIDX'') +
      requested by program &PROGRAM..' ASIS

/**********************************************************************/
/*                                                                    */
/* Cross-check the header ASID with the current ASCB ASID and the     */
/* ASID as established by IPCS.                                       */
/*                                                                    */
/**********************************************************************/

SET DEFASCB = &STR(*unavail)
SET DEFASID = &STR(***)
SET DEFASIDX = &STR(****)
EVALDEF CLIST(QUALIFICATION(KWAL))
/*  IF &SUBSTR(1:6,&NRSTR(&KWAL      )) = &STR(NOCPU ) THEN DO
/*   SET KWAL = &SUBSTR(7:&LENGTH(&NRSTR(&KWAL)),&NRSTR(&KWAL))
/*  END
SET KX = &SYSINDEX(&SUBSTR(1:5,ASID()),&NRSTR(&KWAL)
IF &KX ^= 0 THEN DO
 SET QA = &SUBSTR(&KX+5:&LENGTH(&NRSTR(&KWAL))-1,&NRSTR(&KWAL))
 INTEGER &NRSTR(&QA) UNS    CLIST(S(DEFASID))
 INTEGER &NRSTR(&QA) PTR(4) CLIST(S(DEFASIDX))
END
ELSE DO
 NOTE 'Warning: No ASID qualification defined via SETDEF.' ASIS
 /* cannot do note... quotes */
 WRITE Current qualification is:  "&NRSTR(&KWAL)"
 NOTE SPACE(1)
END
SET CURASCB = &STR(*unavail)
SET CURASID = &STR(***)
SET CURASIDX = &STR(****)
EVAL 224. PTR CLIST(S(CURASCB))
IF &LASTCC ^= 0 THEN DO
 NOTE 'Error:  PSA ASCB pointer not accessible at 224.' ASIS
END
ELSE DO
 EVAL 224.?+24 L(2) UNS CLIST(S(CURASID))
 IF &LASTCC ^= 0 THEN DO
  NOTE 'Error:  Couldn''t get ASID from the current ASCB.' ASIS
 END
 ELSE DO
  INTEGER &CURASID PTR(4) CLIST(S(CURASIDX))
 END
END
SET SYSDVAL = /* STUPID_SYSREF_LOSSAGE */
READDVAL HDRASCB HDRJOBN CURJOBN DEFASCB DEFJOBN +
         HDRASIDC CURASIDC DEFASIDC
SYSCALL EDITN HDRASID HDRASIDC
SYSCALL EDITN CURASID CURASIDC
SYSCALL EDITN DEFASID DEFASIDC
SYSCALL GET_ASCB HDRASCB &HDRASID &HDRASIDX
SYSCALL GET_ASCB DEFASCB &DEFASID &DEFASIDX
SYSCALL GET_JOBNAME HDRJOBN &HDRASCB
SYSCALL GET_JOBNAME CURJOBN &CURASCB
SYSCALL GET_JOBNAME DEFJOBN &DEFASCB

NOTE SPACE(1)
NOTE 'ASID from SETDEF set by IPCS... &DEFASIDC (X''&DEFASIDX'')    +
     Jobname:  &DEFJOBN' ASIS
NOTE 'ASID from the current ASCB..... &CURASIDC (X''&CURASIDX'')    +
     Jobname:  &CURJOBN' ASIS
NOTE 'ASID from the dump header...... &HDRASIDC (X''&HDRASIDX'')    +
     Jobname:  &HDRJOBN' ASIS

/*  EVAL 10. HEADER L(8) HEX CLIST(S(TEMP))
/*  NOTE SPACE(1)
/*  NOTE 'Time of dump:  &TEMP' ASIS

/*  /* Process SDUMP/SYSMDUMP data
/*
/*  EVAL 130. HEADER L(2) HEX CLIST(S(SDMPOFF))
/*  IF &STR(&SDMPOFF) ^= &STR(0000) THEN DO
/*   NOTE SPACE(1)
/*   NOTE '------------------- SDUMP/SYSMDUMP data follows +
/*         -----------------' ASIS
/*   NOTE SPACE(1)
/*   EVAL &SDMPOFF..+0 HEADER L(4) HEX CLIST(S(TEMP))
/*   NOTE 'CVT address:  &TEMP' ASIS
/*  END

/* Process SLIP-dump-only data

ERROR DO
 SET CC = &LASTCC
 IF &ERROK = Y THEN RETURN CODE(&CC)
 ELSE GOTO ERROR_ERROR_ERROR
END
EVAL 16C. HEADER L(2) HEX CLIST(S(SLIPOFF))
IF &STR(&SLIPOFF) ^= &STR(0000) THEN DO
 NOTE SPACE(1)
 NOTE '-------------------- SLIP dump data follows +
       ---------------------' ASIS
 NOTE SPACE(1)
 EVAL &SLIPOFF..+0 HEADER L(8) HEX CLIST(S(TEMP))
 NOTE 'PSW at entry to SLIP:  &SUBSTR(1:8,&TEMP) &SUBSTR(9:16,&TEMP)' +
      ASIS
 NOTE SPACE(1)
 SET NSI = &SUBSTR(9:16,&TEMP)
 %WHERE &NSI.. STACK ID('ABEND LOCATION (SLIP DUMP HEADER)')
 NOTE SPACE(1)
 NOTE 'Registers at time of SLIP...' ASIS
 EVAL &SLIPOFF..+10 HEADER L(64) HEX CLIST(S(TEMP))
 /* %SHOWREGS &TEMP STACK(YES) ID('SLIP DUMP HEADER') &XTRACE
 SET CC = 0
 SET ERROK = Y
 EVALSYM SLIPREGSFROMDUMPHEADER
 SET ERROK = N
 IF &CC ^= 0 THEN DO
  %SHOWREGS &TEMP STACK(YES) ID('SLIP DUMP HEADER') &SREP &XTRACE
  EQ SLIPREGSFROMDUMPHEADER &SLIPOFF..+10 HEADER L(64)
 END
 ELSE DO
  %SHOWREGS &TEMP &SREP &XTRACE
 END
 NOTE SPACE(1)
 ERROR OFF
 SET A = &SUBSTR(1,&NSI)
 DO I = 1 TO 8
  IF &A = &SUBSTR(&I,89ABCDEF) THEN DO
   SET NSI = &SUBSTR(&I,01234567)&SUBSTR(2:8,&NSI)
   SET I = 9
  END
 END

 %DUMPCB INSTRUCTIONS_PRECEDING_PSW_ADDRESS &NSI..-20 32 OFFSET(-32) +
         NOSKIP TITLE('Instructions preceding PSW address')
 %DUMPCB INSTRUCTIONS_FOLLOWING_PSW_ADDRESS &NSI..    32 +
         NOSKIP TITLE('Instructions following PSW address')

 IF &WHERE = WHERE THEN SYSCALL DO_WHERE &EQUATEPREFIX

END

/* Process SDWA data

ERROR DO
 SET CC = &LASTCC
 IF &ERROK = Y THEN RETURN CODE(&CC)
 ELSE GOTO ERROR_ERROR_ERROR
END
EVAL 174. HEADER L(2) HEX CLIST(S(SDWAOFF))
IF &STR(&SDWAOFF) ^= &STR(0000) THEN DO
 NOTE SPACE(1)
 NOTE '---------------------- SDWA data follows +
       ----------------------- ' ASIS
 NOTE SPACE(1)
 EVAL 176. HEADER L(2) SIG CLIST(S(SDWALEN))

 EVAL &SDWAOFF..+04 HEADER L(4) HEX CLIST(S(TEMP))
 NOTE 'Completion code:        &TEMP' ASIS
 EVAL &SDWAOFF..+68 HEADER L(8) HEX CLIST(S(TEMP))
 NOTE 'PSW at time of error:   &SUBSTR(1:8,&TEMP) &SUBSTR(9:16,&TEMP)' +
      ASIS
 NOTE SPACE(1)
 SET NSI = &SUBSTR(9:16,&TEMP)
 %WHERE &NSI.. STACK ID('ABEND LOCATION (DUMP HEADER SDWA)')
 NOTE SPACE(1)
 NOTE 'Registers at time of abend...' ASIS
 EVAL &SDWAOFF..+18 HEADER L(64) HEX CLIST(S(TEMP))
 SET CC = 0
 SET ERROK = Y
 EVALSYM SDWAREGSFROMDUMPHEADER
 SET ERROK = N
 IF &CC ^= 0 THEN DO
  %SHOWREGS &TEMP STACK(YES) ID('DUMP HEADER SDWA') &SREP &XTRACE
  EQ SDWAREGSFROMDUMPHEADER &SDWAOFF..+18 HEADER L(64)
 END
 ELSE DO
  %SHOWREGS &TEMP &SREP &XTRACE
 END
 /*  EVAL &SDWAOFF..+58 HEADER L(8) CHAR CLIST(S(TEMP))
 /*  NOTE 'Abending program name:  &TEMP' ASIS
 /*  EVAL &SDWAOFF..+60 HEADER L(4) PTR  CLIST(S(TEMP))
 /*  NOTE 'Entry point of above:   &TEMP' ASIS
 /*  NOTE SPACE(1)
 ERROR OFF
 SET A = &SUBSTR(1,&NSI)
 DO I = 1 TO 8
  IF &A = &SUBSTR(&I,89ABCDEF) THEN DO
   SET NSI = &SUBSTR(&I,01234567)&SUBSTR(2:8,&NSI)
   SET I = 9
  END
 END

 %DUMPCB INSTRUCTIONS_PRECEDING_PSW_ADDRESS &NSI..-20 32 OFFSET(-32) +
         TITLE('Instructions preceding PSW address')
 %DUMPCB INSTRUCTIONS_FOLLOWING_PSW_ADDRESS &NSI..    32 +
         TITLE('Instructions following PSW address')

 IF &WHERE = WHERE THEN SYSCALL DO_WHERE &EQUATEPREFIX

END

EXIT

DO_WHERE: PROC 1 EQUATEPREFIX
 DO &I = 0 TO 15
  %WHERE &EQUATEPREFIX&I
 END
RETURN
END DO_WHERE

ERROR_ERROR_ERROR:+
ERROR OFF
IF &CC = 12 THEN DO
 NOTE 'Error accessing storage - HEADER processing terminated.' ASIS
 EXIT C(12) Q
END
WRITE Major error processing &SYSSCMD subcommand - LASTCC=&CC
EXIT C(16) Q

GET_ASCB: PROC 3 AVAR ASIDN ASIDX
 SYSREF AVAR
 SET AVAR = &STR(*unavail)

 IF &DATATYPE(&STR(&ASIDN)) ^= NUM THEN DO
  NOTE 'Cannot get ASCB for this ASID: &ASIDN' ASIS
  RETURN CODE(16)
 END

/**********************************************************************/
/*                                                                    */
/* Get the ASCB for this ASID.  Note that instead of using the PSA's  */
/* ASCBNEW or ASCBOLD pointer, we use the ASID to index into the ASVT */
/* to find it.  In that way you can map the TCB chain from the ASID   */
/* that you requested using SETDEF.                                   */
/*                                                                    */
/**********************************************************************/

 EVAL CVT+22C L(4) PTR CLIST(S(ASVTADDR))
 IF &LASTCC ^= 0 THEN DO
  NOTE '==> Error: ASVT address not available from CVT+22C' ASIS
  RETURN CODE(16)
 END
 EVAL &ASVTADDR..+204 L(4) UNS CLIST(S(ASVTMAXU))
 IF &LASTCC ^= 0 THEN DO
  NOTE '==> Error: ASVTMAXU not available from ASVT at &ASVTADDR' ASIS
  RETURN CODE(16)
 END
 IF &ASIDN > &ASVTMAXU THEN DO
  NOTE '==> Error: ASID &ASID is invalid, greater than maximum' ASIS
  RETURN CODE(16)
 END
 SET ASVTOFFS = &ASIDN*4
 EVAL &ASVTADDR..+20C+&ASVTOFFS.N L(4) PTR CLIST(S(ASCBADDR))
 IF &LASTCC ^= 0 THEN DO
  NOTE '==> Error: ASCB address not available at 224.' ASIS
  RETURN CODE(16)
 END
 SELECT &SUBSTR(1,&ASCBADDR)
  WHEN (8|9|A|B|C|D|E|F) DO
   NOTE '==> Error: ASID &ASID is not assigned.' ASIS
   RETURN CODE(16)
  END
 END

 SET AVAR = &STR(&ASCBADDR)
 RETURN CODE(0)
END

GET_JOBNAME: PROC 2 JOBNAME ASCBADDR
 SYSREF JOBNAME
 SET JOBNAME = &STR(*unavail)
 IF &STR(&ASCBADDR) = &STR(*unavail) THEN RETURN
 EVAL &ASCBADDR..+AC L(4) PTR CLIST(S(JOBNAMEADDR))
 IF &LASTCC = 12 THEN RETURN
 IF &STR(&JOBNAMEADDR) = &STR(00000000) THEN DO
  EVAL &ASCBADDR..+B0 L(4) PTR CLIST(S(JOBNAMEADDR))
  IF &LASTCC = 12 THEN RETURN
 END
 EVAL &JOBNAMEADDR.. L(8) CHAR CLIST(S(JOBNAME))
 RETURN
END

EDITN: PROC 2 ASID ASIDC
 SYSREF ASID ASIDC
 SET E = &STR(   &ASID)
 SET L = &LENGTH(&STR(&E))
 SET ASIDC = &SUBSTR(&L-2:&L,&E)
END /* EDITN */
./ ADD NAME=HELPSUB

/**********************************************************************/
/*                                                                    */
/* This CLIST displays HELP for a subcommand of a command processor.  */
/*                                                                    */
/* Example:  HELP IPCS EVAL                                           */
/*                                                                    */
/**********************************************************************/

PROC 2 COMMAND SUBCOMMAND ALL FUNCTION SYNTAX OPERANDS XTRACE
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
IF &NRSTR(&SUBCOMMAND) = &STR(*) THEN DO
 SET SUBCOMMAND =
 SET ALL        =
 SET FUNCTION   =
 SET SYNTAX     =
 SET OPERANDS   =
END
TSOEXEC TEST 'SYS1.CMDLIB(HELP)' C
HELP &SUBCOMMAND &ALL &FUNCTION &SYNTAX &OPERANDS
IF &XTRACE = THEN CONTROL NOMSG
GET 64 EQ(NEWECT)
CONTROL MSG
COPY 1R?+C? NEWECT L(64)
COPY NEWECT 1R?+C P
NEWECT+C=C'&SUBSTR(1:8,&NRSTR(&COMMAND        ))'
NEWECT+14=C'&SUBSTR(1:8,&NRSTR(&SUBCOMMAND        ))'
RUN
./ ADD NAME=IDUMP
PROC 1 ADDRESS COUNT() LENGTHVALUE() OFFSET(0) TITLE() ACTIVE XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
IF &LENGTHVALUE = THEN SET LENGTHVALUE = 2147483647
IF &NRSTR(&TITLE) = THEN SET TITLE = &NRSTR(Instructions at &ADDRESS)
NOTE SPACE(1)
EQ TEMP$$$$ &ADDRESS+0 &ACTIVE
IF &LASTCC = 12 THEN EXIT
EVALSYM TEMP$$$$ CLIST(ADDRESS(ADDRESS) POSITION(POSITION)) &ACTIVE
IF &LASTCC = 12 THEN DO
 NOTE 'Error: Unable to evaluate address &ADDRESS' ASIS
 EXIT C(12) Q
END
INTEGER X'&ADDRESS'  SIGNED CLIST(S(V))
INTEGER X'&POSITION' SIGNED CLIST(S(P))
INTEGER X'&OFFSET'   SIGNED CLIST(S(O))
SET V = &V + &P
NOTE '&TITLE' ASIS
NOTE SPACE(1)
SET I = 0
SET ILENGTH = 1
LOOP:+
IF &COUNT = 0 THEN EXIT
IF &I GE &LENGTHVALUE THEN EXIT
INTEGER &V PTR CLIST(S(ADDRESS))
EVAL &ADDRESS.. L(1) UNS CLIST(S(OPCODE)) &ACTIVE
IF &LASTCC = 12 THEN GOTO ERROR
IF      &OPCODE LT  64  THEN SET ILENGTH = 2
ELSE IF &OPCODE GE 192  THEN SET ILENGTH = 6
ELSE                         SET ILENGTH = 4
EVAL &ADDRESS.. L(&ILENGTH) HEX CLIST(S(INSTR)) &ACTIVE
SET HEXLINE = &SUBSTR(1:32,&INSTR                                 )
EVAL &ADDRESS.. L(&ILENGTH) CHAR CLIST(S(CHARLINE) ENQUOTE) &ACTIVE
IF &LASTCC = 12 THEN GOTO ERROR
SET CHARLINE = &SUBSTR(2:&LENGTH(&NRSTR(&CHARLINE))-1,&NRSTR(&CHARLINE)
SET CURRENT_OFFSET = &I+&O
IF &CURRENT_OFFSET < 0 THEN DO
 INTEGER &EVAL(0-(&CURRENT_OFFSET)) PTR(6) CLIST(S(LABEL))
 SET SIGN = &STR(-)
END
ELSE DO
 INTEGER &CURRENT_OFFSET PTR(6) CLIST(S(LABEL))
 SET SIGN = &STR(+)
END
INTEGER &V PTR(8) CLIST(S(X))
NOTE ' &X  &SIGN&LABEL  +
                        &SUBSTR(1:4,&HEXLINE) +
                        &SUBSTR(5:8,&HEXLINE) +
                        &SUBSTR(9:31,&HEXLINE) *+
                        &NRSTR(&CHARLINE)*' ASIS
IF &LASTCC ^= 0 THEN EXIT
SET I = &I + &ILENGTH
SET V = &V + &ILENGTH
IF &COUNT ^= THEN SET COUNT = &COUNT - 1
GOTO LOOP
ERROR:+
NOTE 'Error: Instructions at &ADDRESS not available (length &ILENGTH)' +
     ASIS
EXIT C(12) Q
END
./ ADD NAME=IP

/**********************************************************************/
/*                                                                    */
/* This CLIST initiates the ISPF/IPCS dialog.                         */
/*                                                                    */
/**********************************************************************/

PROC 0 VOLUME() XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&VOLUME) ^= THEN SET V = VOL(&STR(&VOLUME))
ELSE SET V =

/* Make sure that IPCS CLISTs are allocated.

CONTROL NOFLUSH
SET SYSOUTTRAP = 999
%IPBLSTST
SET RC = &LASTCC
SET SYSOUTTRAP = 0
IF &RC ^= 4 THEN DO
 WRITE
 WRITE You cannot use this CLIST because 'SYSPGMR.CMD.CLIST'
 WRITE is not allocated to SYSPROC.  Please fix your XSETUP.
 EXIT C(12)
END
CONTROL FLUSH

IF &SYSISPF = ACTIVE THEN DO

 ISPEXEC VGET (ZSCREEN)

 /* ALLOC F(BLSPANL&ZSCREEN) DA('SYS1.SBLSPNL0') &V SHR REU
 /* ALLOC F(BLSSKEL&ZSCREEN) DA('SYS1.SBLSKEL0') &V SHR REU
 /* ALLOC F(BLSMSG&ZSCREEN)  DA('SYS1.SBLSMSG0') &V SHR REU
 /* ALLOC F(BLSTABL&ZSCREEN) DA('SYS1.SBLSTBL0') &V SHR REU
 /*
 /* ISPEXEC LIBDEF ISPPLIB LIBRARY ID(BLSPANL&ZSCREEN)
 /* ISPEXEC LIBDEF ISPSLIB LIBRARY ID(BLSSKEL&ZSCREEN)
 /* ISPEXEC LIBDEF ISPMLIB LIBRARY ID(BLSMSG&ZSCREEN)
 /* ISPEXEC LIBDEF ISPTLIB LIBRARY ID(BLSTABL&ZSCREEN)

 ISPEXEC SELECT CMD(%IPPRIM &XTRACE) NEWAPPL(ISR) PASSLIB

 /* ISPEXEC LIBDEF ISPPLIB
 /* ISPEXEC LIBDEF ISPSLIB
 /* ISPEXEC LIBDEF ISPMLIB
 /* ISPEXEC LIBDEF ISPTLIB

END
ELSE DO
 XPDF SELECT('CMD(%IP VOL(''&VOLUME'') &XTRACE)')
 /* XCMD ISPSTART CMD(%IP VOL('&VOLUME') &XTRACE)
END
./ ADD NAME=IPBLSTST
/* ESA version only. */
/* This returns code 4 if found, code 12 if not found (obviously!). */
EXIT CODE(4)
./ ADD NAME=IPCLEAR
/* REXX */
   /**************************************************************/
   /*       Clear SYS1.DUMP without save                         */
   /**************************************************************/
 trace off
 address ISPEXEC
 "VGET (IPDSN)"
 ipact = "CLEAR"
 "DISPLAY PANEL(IPCONF)"
 if rc \= 0 then do
  "SETMSG MSG(IP001)"  /* &IPDSN not cleared */
  exit
 end
 "SELECT PGM(BLSGSCMD) PARM(SETDEF NODSN)"
 "SELECT PGM(BLSGSCMD) PARM(DROPDUMP DSN("ipdsn"))"

 if left(ipdsn,6) = "'SYS1." then do
  iebcc = ipclrdmp(strip(ipdsn,"B","'"))
  if iebcc = 0 then
   "SETMSG MSG(IP002)"  /* &IPDSN has been cleared */
  else say "Clear failed"
 end
 else do
  address TSO "XDELETE" ipdsn
  ipccc = rc
  if ipccc = 0 then
   "SETMSG MSG(IP008)"  /* &IPDSN has been deleted */
  else
   "SETMSG MSG(IP009)"   /* &IPDSN delete failed, RC=... */
 end

 ipdsn = ""
 "VPUT (IPDSN)"

 exit

./ ADD NAME=IPCLRDMP
/* REXX */
address TSO
arg sys1dump

/* Clear out SYS1.DUMP data set. */

signal on error
"ALLOC FI(CLRUT2) DA('"sys1dump"') SHR REU"
"ALLOC FI(CLRPRINT) DUMMY REU"
"ALLOC FI(CLRIN) DUMMY REU"
call listdsi "'"sys1dump"'"
if length(sysrecfm) > 1 then sysrecfm = spread(sysrecfm)
"ALLOC FI(CLRUT1) DUMMY REU DSORG(PS)",
       "RECFM("sysrecfm") LRECL("syslrecl") BLKSIZE("sysblksize")"
signal off error
"XINV IEBGENER",
    "SYSPRINT(CLRPRINT) SYSIN(CLRIN) SYSUT1(CLRUT1) SYSUT2(CLRUT2)"
iebcc = rc
if iebcc \= 0 then do
 "ALLOC FI(CLRPRINT) DA(*) REU"
 "XINV IEBGENER",
       "SYSPRINT(CLRPRINT) SYSIN(CLRIN) SYSUT1(CLRUT1) SYSUT2(CLRUT2)"
 iebcc = rc
end
"FREE FI(CLRUT1,CLRUT2,CLRIN,CLRPRINT)"

/* Clear out AUTOMATE dump listing. */

"ALLOC FI(CLRLIST) REU DA('AUTOMATE."sys1dump".IPCSLIST')"
if rc = 0 then do
 "newstack"
 queue sys1dump "cleared by" userid() "on" date("U") "at" time()
 "EXECIO 1 DISKW CLRLIST (FINIS"
 "delstack"
 "FREE FI(CLRLIST)"
end

return iebcc

spread: parse arg string
spret = ""
do i = 1 to length(string)
 spret = spret substr(string,i,1)
end
return spret

error:return 12
./ ADD NAME=IPCMD
PROC 0
CONTROL ASIS
ISPEXEC CONTROL DISPLAY LINE START(1)
WRITE Enter command:
READ
ISPEXEC SELECT PGM(BLSGSCMD) PARM(&NRSTR(&SYSDVAL))
ISPEXEC CONTROL DISPLAY REFRESH
./ ADD NAME=IPCSEXEC

/**********************************************************************/
/*                                                                    */
/* Use this CLIST to invoke IPCS subcommands from within ISPF, not    */
/* necessarily under the IPCS dialog.  Syntax:                        */
/*                                                                    */
/* IPCSEXEC CMD('IPCS subcommand')                                    */
/*                                                                    */
/**********************************************************************/

PROC 0 CMD()
CONTROL NOFLUSH NOCAPS
IF &NRSTR(&CMD) ^= THEN DO
 SET CMD_SUPPLIED = Y
END
ELSE DO
 SET CMD_SUPPLIED = N
END
LOOP:+
IF &CMD_SUPPLIED = N THEN DO
 WRITE IPCSEXEC
 READ
 SET CMD = &NRSTR(&SYSDVAL)
 IF &SYSCAPS(&NRSTR(&CMD)) = END THEN EXIT
END
ISPEXEC SELECT PGM(BLSGSCMD) PARM(&NRSTR(&CMD))
IF &CMD_SUPPLIED = N THEN DO
 GOTO LOOP
END
./ ADD NAME=IPCSTSO
PROC 0 XTRACE CMD()
IF &XTRACE=XTRACE THEN CONTROL CONLIST SYMLIST LIST
GLOBAL ZG0 ZG1 ZG2 ZG3 ZG4 ZG5 ZG6 ZG7 ZG8 ZG9 ZGA ZGB ZGC ZGD ZGE ZGF
ISPEXEC CONTROL DISPLAY LINE
SET ZSYSDVAL = &NRSTR(&SYSDVAL)
IF &NRSTR(&CMD) ^= THEN DO
 &NRSTR(&CMD)
 EXIT
END
CONTROL NOFLUSH PROMPT
ERROR DO
  WRITE *** ERROR - LASTCC = &LASTCC
  SET ERRORFLAG = 1
  RETURN
END
LOOP:SET ERRORFLAG = 0
IF &STR(&SYSSCMD) = END THEN WRITE IPCSTSO
IF &STR(&SYSPCMD) = IPCS THEN WRITE IPCSTSO
ELSE IF &STR(&SYSSCMD) ^= THEN WRITE IPCSTSO/&SYSPCMD
ELSE IF &STR(&SYSPCMD) = XED      | +
        &STR(&SYSPCMD) = TESTFORT | +
        &STR(&SYSPCMD) = ACCOUNT  | +
        &STR(&SYSPCMD) = OPER     | +
        &STR(&SYSPCMD) = OPERATOR | +
        &STR(&SYSPCMD) = ACF      | +
        &STR(&SYSPCMD) = IPCS     | +
        &STR(&SYSPCMD) = ECHO     | +
        &STR(&SYSPCMD) = EDIT     | +
        &STR(&SYSPCMD) = E        THEN WRITE IPCSTSO/&SYSPCMD
ELSE WRITE IPCSTSO/READY
SET ZSYSDVAL = &NRSTR(&SYSDVAL)
READ
IF &NRSTR(&SYSDVAL) = &STR(==) THEN DO
 WRITE *** CHANGE OPTIONS IF DESIRED ***
 WRITE &STR(&CMD)                                           /*
 READ
 SET CMD=&NRSTR(&SYSDVAL)
END
IF &NRSTR(&SYSDVAL) = THEN GOTO LOOP
SET CMDDVAL = &NRSTR(&SYSDVAL)
IF &SUBSTR(1,&NRSTR(&SYSDVAL )) = ? THEN DO
 WRITE IPCSTSO: NO INFORMATION AVAILABLE
 GOTO LOOP
END
READDVAL VERB
IF &NRSTR(&VERB) = END THEN GOTO ENDITALL
IF &NRSTR(&CMDDVAL) NE &STR(=) THEN SET CMD=&NRSTR(&CMDDVAL)
SET SYSDVAL = /* CLEAR GLOBAL VARIABLES */
READDVAL ZG0 ZG1 ZG2 ZG3 ZG4 ZG5 ZG6 ZG7 ZG8 ZG9 ZGA ZGB ZGC ZGD ZGE ZGF
SET SYSDVAL = &NRSTR(&ZSYSDVAL)
IF &STR(&CMD) ^= THEN IF &ERRORFLAG = 0 THEN &CMD
SET ZSYSDVAL = &NRSTR(&SYSDVAL)
GOTO LOOP
ENDITALL:+
IF &ERRORFLAG = 1 THEN GOTO LOOP
SET SYSDVAL= /* DUMMY STMT TO KILL CLIST NATURALLY */
./ ADD NAME=IPDCAT

/**********************************************************************/
/*                                                                    */
/* This CLIST invokes an ISPF dialog which displays all the datasets  */
/* ending in DUMP in your catalog.                                    */
/*                                                                    */
/**********************************************************************/

PROC 0 APPL(BLSG) XTRACE
IF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST
CONTROL NOCAPS

/******************************************************************/
/* Create table to contain catalog output.                        */
/******************************************************************/

ISPEXEC CONTROL ERRORS RETURN
ISPEXEC TBCREATE IPDCATBL +
                 KEYS() +
                 NAMES(DCASEL DCADSN DCAVOL) +
                 NOWRITE REPLACE
IF &LASTCC > 4 THEN DO
 ISPEXEC DISPLAY PANEL(ISPTERM)
 GOTO EXIT
END

/******************************************************************/
/* Get the catalog entries.                                       */
/******************************************************************/

XLC * SUF(DUMP) VOL NOINFORM DISK WORKDS(&SYSUID..$$IPDCAT.XLCWORK)

ALLOC F(XLCWORK) DA('&SYSUID..$$IPDCAT.XLCWORK') REU

OPENFILE XLCWORK
CONTROL NOFLUSH
ERROR DO
 SET CC = &LASTCC
 IF &CC = 400 THEN GOTO CLOSEIT
 IF &CC < 16 THEN RETURN
 WRITE *** Error in IPDCAT CLIST - LASTCC = &CC
 EXIT Q
END

/******************************************************************/
/* Create a table line for this dump.                             */
/******************************************************************/

GETLDMP:+
GETFILE XLCWORK
SET SYSDVAL = &NRSTR(&XLCWORK)
READDVAL JUNKNUMBER ENTRYTYPE DSNAME VOLSER
IF &STR(&JUNKNUMBER) = THEN GOTO CLOSEIT
SET CC = 0
ISPEXEC TBVCLEAR IPDCATBL
IF &CC ^= 0 THEN GOTO REDISP
SET DCASEL =
SET DCADSN = &STR(&DSNAME)
SET DCAVOL = &STR(&VOLSER)
SET CC = 0
ISPEXEC TBADD IPDCATBL
IF &CC > 4 THEN DO
 SET CC = 0
 ISPEXEC DISPLAY PANEL(ISPTERM)
 IF &CC > 0 THEN DO
  WRITE *** Aargh!  Can't even display panel ISPTERM. Is nothing sacred?
  EXIT Q
 END
 GOTO EXIT
END
GOTO GETLDMP

CLOSEIT:+
ERROR OFF
CONTROL FLUSH
CLOSFILE XLCWORK
FREE F(XLCWORK) /*DELETE

/******************************************************************/
/* Display the table.                                             */
/******************************************************************/

REDISP:+
ISPEXEC TBTOP IPDCATBL
IF &LASTCC ^= 0 THEN DO
 ISPEXEC DISPLAY PANEL(ISPTERM)
 GOTO EXIT
END
SET TABLECC = 0
DO WHILE &TABLECC < 8
 IF &TABLECC = 4 THEN DO /* ISPEXEC TBDISPL
  WRITE Multiple table entries not allowed
  SET DCASEL =
  GOTO REDISP
 END
 ISPEXEC TBTOP IPDCATBL
 ISPEXEC TBDISPL IPDCATBL PANEL(IPDCATBL)
 SET TABLECC = &LASTCC
 IF &TABLECC > 8 THEN DO
  ISPEXEC DISPLAY PANEL(ISPTERM)
  GOTO EXIT
 END
 IF &TABLECC < 8 THEN DO
  SET DCASEL = &STR(&SYSCAPS(&DCASEL))
  IF &DCASEL = THEN DO
  END
  ELSE IF &DCASEL = S THEN DO
   ISPEXEC CONTROL DISPLAY SAVE
   SET IPDDSN = &STR(&DCADSN)
   ISPEXEC VPUT (IPDDSN) PROFILE
   ISPEXEC SELECT CMD(%IPDSN D(&IPDDSN)) NEWAPPL(&APPL) PASSLIB
   ISPEXEC CONTROL DISPLAY RESTORE
  END
  ELSE IF &DCASEL = H THEN DO
   ISPEXEC CONTROL DISPLAY SAVE
   HRECALL '&DCADSN' NOWAIT
   ISPEXEC CONTROL DISPLAY RESTORE
  END
  ELSE IF &DCASEL = P THEN DO
   ISPEXEC CONTROL DISPLAY SAVE
   ISPEXEC SELECT PGM(BLSGSCMD) NEWAPPL(&APPL) PASSLIB +
                  PARM(DROPDUMP DSN('&DCADSN'))
   XDELETE '&DCADSN'
   SET DELCC = &LASTCC
   IF &DELCC = 0 THEN DO
    ISPEXEC TBDELETE IPDCATBL
    SET IPSMSG = &STR(Dump deleted.)
    SET IPLMSG = &STR('&DCADSN' has been dropped and deleted.)
    ISPEXEC SETMSG MSG(IPZ000)
   END
   ELSE DO
    SET IPSMSG = &STR(Delete failed.)
    SET IPLMSG = &STR(Return code from XDELETE is &DELCC..)
    ISPEXEC SETMSG MSG(IPZ000)
   END
   ISPEXEC CONTROL DISPLAY RESTORE
  END
  ELSE DO
   SET IPSMSG = &STR(Invalid select code)
   SET IPLMSG = &STR(The only valid selection codes are S, P and H.)
   ISPEXEC SETMSG MSG(IPZ001)
  END
 END
END
ISPEXEC TBEND IPDCATBL
EXIT:+
EXIT
./ ADD NAME=IPDEB

/**********************************************************************/
/*                                                                    */
/* This CLIST invokes an ISPF DIALOG which displays a list of DEB's   */
/* and their associated DCB's, etc.                                   */
/*                                                                    */
/* The positional parameter is a TCB address (see IPTCB).             */
/*                                                                    */
/**********************************************************************/

PROC 1 TCBADDR XTRACE
IF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST
CONTROL NOFLUSH NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
 WRITE *** You must be in IPCS to use this CLIST. ***
 EXIT C(16) Q
END
EVAL &TCBADDR+9 L(3) PTR CLIST(S(DEBADDR))
IF &LASTCC=12 THEN DO
 NOTE 'IPDEB: Error accessing TCB at &TCBADDR' ASIS
 EXIT C(16) Q
END
IF &DEBADDR = 0 THEN DO
 SET IPSMSG = &STR(NO OPEN DATA SETS)
 SET IPLMSG = &STR(TCB at &TCBADDR has no open data sets.)
 ISPEXEC SETMSG MSG(IPZ001)
 EXIT C(4)
END
/******************************************************************/
/* Create table to contain DEBs for this TCB                      */
/******************************************************************/
ISPEXEC CONTROL ERRORS RETURN
ISPEXEC TBCREATE IPDEBTBL +
        KEYS() +
        NAMES(DEBSEL DEBEXIT IDBADDR DEBAM DEBOPT +
              DEBDCB DCBDDN DCBDSN DCBMEM) +
        NOWRITE REPLACE
IF &LASTCC > 4 THEN DO
 ISPEXEC DISPLAY PANEL(ISPTERM)
 GOTO EXIT
END

/******************************************************************/
/* Process all DEBs for this address space                        */
/******************************************************************/

DO WHILE &DEBADDR^=0
 ISPEXEC TBVCLEAR IPDEBTBL
 EVAL &DEBADDR..-03 LE(1) UNS CLIST(S(DEBAM))
 EVAL &DEBADDR..+0C LE(1) UNS CLIST(S(DEBOPT))
 EVAL &DEBADDR..+19 LE(3) PTR CLIST(S(DEBDCB))
 EVAL &DEBADDR..+01 LE(3) PTR CLIST(S(DEBTCB))

/******************************************************************/
/* Get stuff from the DEB.                                        */
/******************************************************************/

IF      &DEBAM =   0 THEN SET DEBAM = UNKNOWN
ELSE IF &DEBAM =   1 THEN SET DEBAM = VSAM
ELSE IF &DEBAM =   2 THEN SET DEBAM = EXCP
ELSE IF &DEBAM =   4 THEN SET DEBAM = TCAM
ELSE IF &DEBAM =   8 THEN SET DEBAM = GAM
ELSE IF &DEBAM =  16 THEN SET DEBAM = BTAM
ELSE IF &DEBAM =  32 THEN SET DEBAM = SAMBPAM
ELSE IF &DEBAM =  64 THEN SET DEBAM = BDAM
ELSE IF &DEBAM = 128 THEN SET DEBAM = ISAM
ELSE IF &DEBAM = 129 THEN SET DEBAM = JES2
ELSE IF &DEBAM = 130 THEN SET DEBAM = VTAM
ELSE IF &DEBAM = 132 THEN SET DEBAM = TCAMAPP

SET DEBOPT = &DEBOPT // 16
IF      &DEBOPT =  0 THEN SET DEBOPT = INPUT
ELSE IF &DEBOPT = 15 THEN SET DEBOPT = OUTPUT
ELSE IF &DEBOPT =  3 THEN SET DEBOPT = INOUT
ELSE IF &DEBOPT =  7 THEN SET DEBOPT = OUTIN
ELSE IF &DEBOPT =  1 THEN SET DEBOPT = RDBACK
ELSE IF &DEBOPT =  4 THEN SET DEBOPT = UPDAT

/******************************************************************/
/* Get DCB stuff.                                                 */
/******************************************************************/

SET TIOTOFFSET =
SET DCBDDN     =
SET DCBDSN     =
SET DCBMEM     =
SET JFCBADDR   =

EVAL &DEBDCB..+28 LE(2) SIGNED CLIST(S(TIOTOFFSET))
EQ $TIOTENTRY &DEBTCB..+C?+&TIOTOFFSET.N+0 POS(0) L(20)
EVAL $TIOTENTRY+4 L(8) CHAR CLIST(S(DCBDDN))
EVAL $TIOTENTRY+C L(3) PTR CLIST(S(JFCBADDR))
EQ $JFCB &JFCBADDR..+10 POS(0) L(176)
EVAL $JFCB+0 L(44) CHAR CLIST(S(DCBDSN))
EVAL $JFCB+2C L(8) CHAR CLIST(S(DCBMEM))

SET IDBADDR = &STR(&DEBADDR)

ISPEXEC TBADD IPDEBTBL
IF &LASTCC ^= 0 THEN DO
 ISPEXEC DISPLAY PANEL(ISPTERM)
 EXIT
END

/**********************************************************************/
/*                                                                    */
/* Determine if another DEB is chained. If so, prepare to process it. */
/* In any case, set the chain pointer.                                */
/*                                                                    */
/**********************************************************************/

 EVAL &DEBADDR..+5 LE(3) PTR CLIST(S(DEBADDR))
 IF &LASTCC=12 THEN DO
  NOTE '==> Error: Next DEB not available from DEB(&DEBADDR)'
  EXIT C(4)
 END
END

/******************************************************************/
/* Display the table of DEB's.                                   */
/******************************************************************/

REDISP:+
ISPEXEC TBTOP IPDEBTBL
IF &LASTCC ^= 0 THEN DO
 ISPEXEC DISPLAY PANEL(ISPTERM)
 GOTO EXIT
END
SET H1 = &STR(+
 Sel/IPCS Clist //Address  Acsmeth Openopt DCB     Ddname   )
SET M1 = &STR(+
 _Z+/_DEBEXIT  +//!IDBADDR!DEBAM  !DEBOPT !DEBDCB !DCBDDN   )
SET H2 = &STR(+
 Sel/IPCS Clist // Ddname   Member   Dsname)
SET M2 = &STR(+
 _Z+/_DEBEXIT  +//!DCBDDN  !DCBMEM  !DCBDSN)
SET DEBHEAD = &NRSTR(&H1)
SET DEBMODL = &NRSTR(&M1)
SET DEBNUM = 1
SET TABLECC = 0
DO WHILE &TABLECC < 8
 IF &TABLECC = 4 THEN DO /* ISPEXEC TBDISPL
  WRITE Multiple table entries not allowed
  SET DEBSEL =
  SET DEBEXIT =
  GOTO REDISP
 END
 ELSE ISPEXEC TBDISPL IPDEBTBL PANEL(IPDEBTBL)
 SET TABLECC = &LASTCC
 IF &TABLECC > 8 THEN DO
  ISPEXEC DISPLAY PANEL(ISPTERM)
  GOTO EXIT
 END
 IF &TABLECC < 8 THEN DO
  SET DEBSEL  = &STR(&SYSCAPS(&DEBSEL))
  SET DEBEXIT = &STR(&SYSCAPS(&DEBEXIT))
  IF &STR(&DEBSEL&DEBEXIT) ^= THEN DO
   ISPEXEC CONTROL DISPLAY SAVE
   IF &DEBSEL = THEN DO
    IF &STR(&DEBEXIT) ^= THEN +
    ISPEXEC SELECT PGM(BLSGSCMD) PARM(%&DEBEXIT DCB(&DEBDCB..) &XTRACE)
   END
   ELSE DO
    ISPEXEC SETMSG MSG(IPZ002)
    SET DEBSEL =
    SET DEBEXIT =
    GOTO REDISP
   END
   ISPEXEC CONTROL DISPLAY RESTORE
  END
  IF &NRSTR(&DEBCMD) ^= THEN DO
   ISPEXEC CONTROL DISPLAY SAVE
   ISPEXEC SELECT PGM(BLSGSCMD) PARM(&DEBCMD)
   ISPEXEC CONTROL DISPLAY RESTORE
  END
 END
END
ISPEXEC TBEND IPDEBTBL
GOTO EXIT
EXIT:+
ISPEXEC CONTROL DISPLAY REFRESH
EXIT
./ ADD NAME=IPDFS
 PROC 0 XTRACE
 IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
 ELSE CONTROL NOLIST
 CONTROL NOCAPS
   /**************************************************************/
   /*      IPCS Dialogs: Set defaults                            */
   /**************************************************************/
 ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPDFSI)
 IF &LASTCC < 12 THEN +
   ISPEXEC VGET (IPDSN IPQUAL IPCON IPDSP IPFLG IPPRI IPTER IPVER)
 IF &LASTCC < 12 THEN DO
   ISPEXEC DISPLAY PANEL(IPDEF)
   IF &LASTCC ^= 0 THEN EXIT
   ISPEXEC SELECT PGM(BLSGSCMD) +
           PARM(SETDEF &IPQUAL &IPROUTE &IPCNTRL DISPLAY(&IPDSP) NOLIST)
 END
 EXIT
/***********************************************************************
/*
/* Source:
/*
/* "MVS/XA2.1.2 Installation and User's Guide"
/* IBM International Systems Centers
/* GG24-1596-1
/* (c) Copyright International Business Machines Corporation 1983, 1984
/*
/* Page 162
/*
/***********************************************************************
./ ADD NAME=IPDFSI
 PROC 0 XTRACE
 IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
 CONTROL NOFLUSH NOCAPS
   /**************************************************************/
   /*      IPCS Dialogs: Get current defaults                    */
   /**************************************************************/
 EVALDEF DIALOG(CONFIRM(IPCON) DISPLAY(IPDSP) FLAG(IPFLG) +
                PRINT(IPPRI) TERMINAL(IPTER) VERIFY(IPVER))
 IF &LASTCC > 8 THEN EXIT
 EVALDEF DIALOG(QUALIFICATION(IPQUAL))
 IF &LASTCC < 16 THEN SET MAXCC = 0
 ISPEXEC VPUT (IPQUAL IPCON IPDSP IPFLG IPPRI IPTER IPVER) PROFILE
 EXIT
/***********************************************************************
/*
/* Source:
/*
/* "MVS/XA2.1.2 Installation and User's Guide"
/* IBM International Systems Centers
/* GG24-1596-1
/* (c) Copyright International Business Machines Corporation 1983, 1984
/*
/* Page 161
/*
/***********************************************************************
./ ADD NAME=IPDLEVAL
PROC 1 EDDSN XTRACE
IF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST
CONTROL NOCAPS
EVALDUMP GT DATASET(&EDDSN) +
         CLIST (BLOCKS(DLDBLKS) BYTES(DLDBYTES) +
                SOURCE(DLDSRC) QUAL(DLDQUAL))
SET EVALDUMPCC = &LASTCC
IF &EVALDUMPCC = 0 THEN DO
 ISPEXEC VPUT (DLDBLKS DLDBYTES DLDSRC DLDQUAL) SHARED
 SET VPUTCC = &LASTCC
 IF &VPUTCC ^= 0 THEN WRITE VPUT returned with code &VPUTCC..
END
EXIT CODE(&EVALDUMPCC)
./ ADD NAME=IPDLIST

/**********************************************************************/
/*                                                                    */
/* This CLIST invokes an ISPF dialog which displays LISTDUMP output.  */
/*                                                                    */
/**********************************************************************/

PROC 0 APPL(BLSG) XTRACE
IF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST
CONTROL NOCAPS

/******************************************************************/
/* Create table to contain LISTDUMP output.                       */
/******************************************************************/

ISPEXEC CONTROL ERRORS RETURN
ISPEXEC TBCREATE IPDLDTBL +
                 KEYS() +
                 NAMES(DLDSEL DLDDSN DLDQUAL DLDBLKS DLDBYTES) +
                 NOWRITE REPLACE
IF &LASTCC > 4 THEN DO
 ISPEXEC DISPLAY PANEL(ISPTERM)
 GOTO EXIT
END

/******************************************************************/
/* Create a table line for this dump.                             */
/******************************************************************/

SET EDDSN = '$'
GETLDMP:+
ISPEXEC TBVCLEAR IPDLDTBL
ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPDLEVAL &EDDSN)
IF &LASTCC ^= 0 THEN GOTO REDISP
ISPEXEC VGET (DLDSRC DLDQUAL DLDBLKS DLDBYTES) SHARED
IF &STR(&DLDSRC) = THEN DO
 WRITE Error: I couldn't get the dump data from IPDLEVAL.
 EXIT
END
IF &SUBSTR(1:6,&DLDSRC      ) = DSNAME THEN DO
 SET DLDDSN = &SUBSTR(8:&LENGTH(&STR(&DLDSRC))-1,&DLDSRC)
END
SET EDDSN = &STR(&DLDDSN)
SET DLDSEL =
ISPEXEC VPUT (DLDSEL DLDDSN DLDQUAL DLDBLKS DLDBYTES)
ISPEXEC TBADD IPDLDTBL
IF &LASTCC > 4 THEN DO
 ISPEXEC DISPLAY PANEL(ISPTERM)
 GOTO EXIT
END
GOTO GETLDMP

/******************************************************************/
/* Display the table.                                             */
/******************************************************************/

REDISP:+
ISPEXEC TBTOP IPDLDTBL
IF &LASTCC ^= 0 THEN DO
 ISPEXEC DISPLAY PANEL(ISPTERM)
 GOTO EXIT
END
SET TABLECC = 0
DO WHILE &TABLECC < 8
 IF &TABLECC = 4 THEN DO /* ISPEXEC TBDISPL
  WRITE Multiple table entries not allowed
  SET DLDSEL =
  GOTO REDISP
 END
 ISPEXEC TBTOP IPDLDTBL
 ISPEXEC TBDISPL IPDLDTBL PANEL(IPDLDTBL)
 SET TABLECC = &LASTCC
 IF &TABLECC > 8 THEN DO
  ISPEXEC DISPLAY PANEL(ISPTERM)
  GOTO EXIT
 END
 IF &TABLECC < 8 THEN DO
  SET DLDSEL  = &STR(&SYSCAPS(&DLDSEL))
  IF &DLDSEL = THEN DO
  END
  ELSE IF &DLDSEL = S THEN DO
   ISPEXEC CONTROL DISPLAY SAVE
   SET IPDDSN = &STR(&DLDDSN)
   ISPEXEC VPUT (IPDDSN) PROFILE
   ISPEXEC SELECT CMD(%IPDSN D(&IPDDSN)) NEWAPPL(&APPL) PASSLIB
   ISPEXEC CONTROL DISPLAY RESTORE
  END
  ELSE IF &DLDSEL = P THEN DO
   ISPEXEC CONTROL DISPLAY SAVE
   ISPEXEC SELECT PGM(BLSGSCMD) NEWAPPL(&APPL) +
                  PARM(SETDEF NODSN) PASSLIB
   ISPEXEC SELECT PGM(BLSGSCMD) NEWAPPL(&APPL) +
                  PARM(DROPDUMP DSN(&DLDDSN)) PASSLIB
   IF &SUBSTR(1:6,&DLDDSN      ) = &STR('SYS1.) THEN DO
    ALLOC FI(CLRPRINT) DUMMY REU
    ALLOC FI(CLRIN) DUMMY REU
    ALLOC FI(CLRUT1) DUMMY REU +
                     RECFM(F) LRECL(4104) BLKSIZE(4104) DSORG(PS)
    ALLOC FI(CLRUT2) DA(&DLDDSN) SHR REU
    XINV IEBGENER +
         SYSPRINT(CLRPRINT) SYSIN(CLRIN) SYSUT1(CLRUT1) SYSUT2(CLRUT2)
    SET IEBCC = &LASTCC
    IF &IEBCC = 0 THEN DO
     ISPEXEC TBDELETE IPDLDTBL
     SET IPSMSG = &STR(Dump cleared.)
     SET IPLMSG = &STR(&DLDDSN has been dropped and cleared.)
     ISPEXEC SETMSG MSG(IPZ000)
    END
    ELSE DO
     SET IPSMSG = &STR(Clear failed.)
     SET IPLMSG = &STR(Return code from IEBGENER is &IEBCC..)
     ISPEXEC SETMSG MSG(IPZ000)
    END
    FREE FI(CLRUT1,CLRUT2,CLRIN,CLRPRINT)
   END
   ELSE DO
    IF &XTRACE = THEN CONTROL NOMSG
    FREE DA(&DLDDSN)
    CONTROL MSG
    XDELETE &DLDDSN
    SET DELCC = &LASTCC
    IF &DELCC = 0 THEN DO
     ISPEXEC TBDELETE IPDLDTBL
     SET IPSMSG = &STR(Dump deleted.)
     SET IPLMSG = &STR(&DLDDSN has been dropped and deleted.)
     ISPEXEC SETMSG MSG(IPZ000)
    END
    ELSE DO
     SET IPSMSG = &STR(Delete failed.)
     SET IPLMSG = &STR(Return code from XDELETE is &DELCC..)
     ISPEXEC SETMSG MSG(IPZ000)
    END
   END
   ISPEXEC CONTROL DISPLAY RESTORE
  END
  ELSE IF &DLDSEL = H THEN DO
   HRECALL &DLDDSN
  END
  ELSE IF &DLDSEL = A THEN DO
   SET MSGID = IPZ001
   XDSTAT &DLDDSN NORECALL
   SELECT &LASTCC
    WHEN (0) DO
     SET MSGID = IPZ000
     SET IPSMSG = &STR(Dataset exists.)
     SET IPLMSG = &STR(&DLDDSN exists and is online.)
    END
    WHEN (4) DO
     SET IPSMSG = &STR(Member not found.)
     SET IPLMSG = &STR(&DLDDSN contains a nonexistent member.)
    END
    WHEN (8) DO
     SET IPSMSG = &STR(Dataset not cataloged.)
     SET IPLMSG = &STR(&DLDDSN was not found in catalog.)
    END
    WHEN (12) DO
     SET IPSMSG = &STR(Volume not available.)
     SET IPLMSG = &STR(&DLDDSN is on an unavailable DASD volume.)
    END
    WHEN (16) DO
     SET IPSMSG = &STR(Dataset not on DASD.)
     SET IPLMSG = &STR(&DLDDSN is on a non-DASD device.)
    END
    WHEN (20) DO
     SET IPSMSG = &STR(Dataset not on volume.)
     SET IPLMSG = &STR(+
          &DLDDSN is not on the volume specified in the catalog.)
    END
    WHEN (24) DO
     SET IPSMSG = &STR(Dataset not a PDS.)
     SET IPLMSG = &STR(+
         &DLDDSN is sequential but a member name is specified.)
    END
    WHEN (28) DO
     SET IPSMSG = &STR(Allocation error.)
     SET IPLMSG = &STR(Some kind of error occurred wrt &DLDDSN..)
    END
    WHEN (32) DO
     SET IPSMSG = &STR(Invalid dataset name.)
     SET IPLMSG = &STR(&DLDDSN is a syntactically invalid name.)
    END
    WHEN (36) DO
     SET IPSMSG = &STR(Dataset in use.)
     SET IPLMSG = &STR(&DLDDSN is in use, cannot verify member name.)
    END
    WHEN (40) DO
     SET IPSMSG = &STR(Dataset is migrated.)
     SET IPLMSG = &STR(&DLDDSN is migrated.  Use H to HRECALL it.)
    END
    OTHERWISE DO
     SET IPSMSG = &STR(Dataset status unknown.)
     SET IPLMSG = &STR(XDSTAT returned code of &SYSSELECT for &DLDDSN..)
    END
   END
   ISPEXEC SETMSG MSG(&MSGID)
  END
  ELSE DO
   SET IPSMSG = &STR(Invalid select code)
   SET IPLMSG = &STR(The only valid selection codes are H,A,S,P.)
   ISPEXEC SETMSG MSG(IPZ001)
  END
 END
END
ISPEXEC TBEND IPDLDTBL
EXIT:+
EXIT
./ ADD NAME=IPDSCAN
/* This REXX exec invokes an ISPF dialog which displays SYSDSCAN output.
   Updated for MVS/ESA. */
address TSO
signal on halt
signal on failure
/* bug in IPCS/REXX interface... */
/* parse arg ipcsrexxbugarg             */
/* "XPROC IPCSREXXBUGARG 0 APPL(BLSG)"  */
"XPROC 0 APPL(BLSG)"
if rc > 0 then exit
n_appl = appl
call outtrap "line."
"SYSDSCAN 0:99"
sdscc = rc
call outtrap "OFF"
maxlines = line.0
if sdscc > 4 then do
 say "*** Error: Return code from SYSDSCAN is" sdscc
 say "*** Output follows:"
 say
 do i = 1 to line.0; say line.i;end
 say
 exit sdscc
end
/******************************************************************/
/* Create table to contain SYSDSCAN output.                       */
/******************************************************************/
address ISPEXEC
signal off error
"CONTROL ERRORS RETURN"
"TBCREATE IPSDSTBL",
         "KEYS()",
         "NAMES(SDSSEL SDSDUMP SDSDATE SDSTIME SDSTITLE)",
         "NOWRITE REPLACE"
if rc > 4 then signal error
signal on error
/******************************************************************/
/* Inspect all command output.                                    */
/******************************************************************/
do i = 1 to line.0
 /******************************************************************/
 /* Determine if PROFILE MSGID was active.                         */
 /******************************************************************/
 if abbrev(line.i,"BLS",3) | ,
    abbrev(line.i,"IKJ",3) then off = 10
 else off = 0
 outline = line.i
 if off > 0 then interpret "parse var outline prefix" off+1 "outline"
 else prefix = ""
/**********************************************************************/
/* Check if this is an error message or a dump data set message.      */
/**********************************************************************/
 if sdscc > 0 then do
  if abbrev(prefix,"IKJ",3) | \abbrev(outline,"SYS1",4) then do
   if pos("NOT IN CATALOG",outline) = 0 then say prefix || outline
   iterate i
  end
 end
/**********************************************************************/
/* Check if the dump title goes across lines.                         */
/**********************************************************************/
 title2 = ""
 do while i < line.0
  nxtline = value("line." || i+1)
  if verify(nxtline," ") <= 2 then leave
  i = i + 1
  title2 = title2 || strip(nxtline)
 end
/******************************************************************/
/* Create a table line for this dump.                             */
/******************************************************************/
 "TBVCLEAR IPSDSTBL"
 sdssel = ""
 sdsdump = substr(outline,1,11)
 if translate(substr(outline,13,8)) = "IS EMPTY" then do
  sdsdate = ""
  sdstime = ""
  sdstitle = "---Empty---"
 end
 else do
  l = length(outline)
  sdsdate = substr(outline,14,10)
  sdstime = substr(outline,25,5) || " "
  if right(strip(outline),1) = "+" then
   sdstitle = strip(substr(outline,32),"T","+") || title2
  else sdstitle = substr(outline,32)
 end
 "TBADD IPSDSTBL"
end i
redisp:
"TBTOP IPSDSTBL"
tablecc = 0
do while tablecc < 8
 if tablecc = 4 then do /* ISPEXEC TBDISPL */
  say "Multiple table entries not allowed"
  sdssel =
  signal redisp
 end
 "TBTOP IPSDSTBL"
 signal off error
 "TBDISPL IPSDSTBL PANEL(IPSDSTBL)"
 tablecc = rc
 if tablecc > 8 then signal error
 signal on error
 if tablecc < 8 then do
  upper sdssel
  if sdssel = "" then nop
  else if sdssel = "S" then do
   if sdsdate = "" then do
    ipsmsg = "Empty dump dataset"
    iplmsg = "Requested dump dataset is empty, cannot be selected."
    "SETMSG MSG(IPZ001)"
   end
   else do
    "CONTROL DISPLAY SAVE"
    ipddsn = "'"sdsdump"'"
    "VPUT (IPDDSN) PROFILE"
    parse var sdsdate imonth "/" iday    "/" iyear
    parse var sdstime ihour  ":" iminute ":" isecond
    iyear = right(iyear,2)
    iminute = strip(iminute)
    if isecond = "" then isecond = "00"
    ipnewdsn = sdsdump || ".D" || iyear || imonth  || iday    || ,
                          ".T" || ihour || iminute || isecond || ,
                          ".DUMP"
    /*
    address TSO
    "ALLOC DA("ipddsn")" ,
           "RECFM(F) LRECL(4160) BLKSIZE(4160) DSORG(PS) SHR"
    */
    call tso_command "%IPDSN D("ipddsn") T("ipnewdsn")"
    /* don't mark it processed...
       sdssel =
       sdsdate =
       sdstime =
       sdstitle = "---Processed---"
       "tbput ipsdstbl"
    */
    address ISPEXEC
    "CONTROL DISPLAY RESTORE"
   end
  end
  else if sdssel = "N" then do
   if sdsdate = "" then do
    ipsmsg = "Empty dump dataset"
    iplmsg = "Requested dump dataset is empty, cannot be selected."
    "SETMSG MSG(IPZ001)"
   end
   else do
    "CONTROL DISPLAY SAVE"
    ipddsn = "'"sdsdump"'"
    "VPUT (IPDDSN) PROFILE"
    call tso_command "%IPDSN D("ipddsn") NEW"
    "CONTROL DISPLAY RESTORE"
   end
  end
  else if sdssel = "P" then do
   if sdsdate = "" then do
    ipsmsg = "Empty dump dataset"
    iplmsg = "Requested dump dataset is empty, cannot be selected."
    "SETMSG MSG(IPZ001)"
   end
   else do
    "CONTROL DISPLAY SAVE"
    call ipcs_command "SETDEF NODSN"
    call ipcs_command "DROPDUMP DSN('"sdsdump"')"
    iebcc = ipclrdmp(sdsdump)
    signal on error
    address ISPEXEC
    if iebcc = 0 then do
     sdssel =
     sdsdate =
     sdstime =
     sdstitle = "---Purged---"
     "TBPUT IPSDSTBL"
     ipsmsg = "Dump cleared."
     iplmsg = "'"sdsdump"' has been dropped and cleared."
     "SETMSG MSG(IPZ000)"
    end
    else do
     ipsmsg = "Clear failed."
     iplmsg = "Return code from IPCLRDMP exec is "iebcc"."
     "SETMSG MSG(IPZ000)"
    end
    "CONTROL DISPLAY RESTORE"
   end
  end
  else if sdssel = "B" then do
   "CONTROL DISPLAY SAVE"
   autdsn = "'AUTOMATE."sdsdump".IPCSLIST'"
   signal off error
   "BROWSE DATASET("autdsn")"
   if rc > 0 then "DISPLAY PANEL(ISPTERM)"
   signal on error
   "CONTROL DISPLAY RESTORE"
  end
  else do
   ipsmsg = "Invalid select code"
   iplmsg = "Valid selection codes are: S, N, P."
   "SETMSG MSG(IPZ001)"
  end
 end
end
"TBEND IPSDSTBL"
exit

error:
signal off error
if address() = "ISPEXEC" then "DISPLAY PANEL(ISPTERM)"
signal exit
exit:halt:failure:
if datatype(sigl,"W") then say sourceline(sigl)": rc=" rc
exit

tso_command: arg cmd
address ISPEXEC
signal off error
"SELECT CMD("cmd") NEWAPPL("n_appl") PASSLIB"
signal on error
return

ipcs_command: arg cmd
address ISPEXEC
signal off error
"SELECT PGM(BLSGSCMD) NEWAPPL("n_appl") PARM("cmd") PASSLIB"
signal on error
return
./ ADD NAME=IPDSN
 PROC 0 NEWAPPL(BLSG) DUMPDATASET() TODATASET() SYS1DUMP(Y) NEW XTRACE
 IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
 CONTROL NOCAPS
 /*
 /**********************************************************************
 /*      IPCS Dialogs: Open dumpdataset
 /**********************************************************************
 WRITE DUMPDATASET=&STR(&DUMPDATASET)
 IF &STR(&DUMPDATASET) = THEN DO
  ISPEXEC VGET (IPDSN IPUDD IPFI)
  SET V = 0
 END
 ELSE DO
  WRITE V=&V
  SET IPDSN = &STR('&DUMPDATASET')
  IF &NEW = NEW THEN SET IPUDD = NO
  ELSE SET IPUDD = YES
  SET IPFI =
 END
 SET V = &SYSINDEX(&STR(:),&IPDSN)
 WRITE IPDSN=&STR(&IPDSN)
 WRITE IPUDD=&STR(&IPUDD)
 WRITE IPFI =&STR(&IPFI)
 WRITE V=&V
 IF &STR(&IPDSN) = 1 THEN DO
   /* active main storage - don't open any dump data set */
   /* don't ISPEXEC SELECT PGM(BLSGSCMD) PARM(DROPDUMP ACTIVE)
   SET FILEORDSN = ACTIVE
 END
 ELSE IF &STR(&IPDSN) = 0 THEN DO
   /* open preallocated file  (DSN not known)
   SET FILEORDSN = &STR(FILE('&IPFI'))
 END
 ELSE IF &V ^= 0 THEN DO
   SET VIPVOL = &SUBSTR(1:&V-1,&IPDSN)
   SET VIPDSN = &SUBSTR(&V+1:&LENGTH(&STR(&IPDSN)),&IPDSN)
   ALLOC FI(VIPDD) SHR REU DA(&VIPDSN) VOL(&VIPVOL)
   IF &LASTCC ^= 0 THEN EXIT C(12)
   SET IPFI = VIPDD
   SET FILEORDSN = &STR(FILE(&IPFI))
 END
 ELSE IF &SYS1DUMP = N && +
         &SUBSTR(1:10,&IPDSN          ) = 'SYS1.DUMP THEN DO
  SET NGTODATASET = &STR(&TODATASET)
  SET NGNEWAPPL   = &STR(&NEWAPPL)
  SYSCALL COPY_FROM_SYS1 /* may change IPDSN */
  IF &LASTCC ^= 0 THEN EXIT C(12)
 END
 ELSE DO
   /* open by dsname
   SET FILEORDSN = &STR(DSNAME(&IPDSN))
 END
 IF &STR(&FILEORDSN) = ACTIVE THEN DO
  ISPEXEC SELECT PGM(BLSGSCMD) PARM(%ACTIVE)
  SET OPENCC = 0
 END
 ELSE DO
  ISPEXEC SELECT PGM(BLSGSCMD) PARM(SETDEF &FILEORDSN)
  IF &IPUDD = NO THEN DO
    ISPEXEC SELECT PGM(BLSGSCMD) PARM(DROPD &FILEORDSN)
    ISPEXEC CONTROL DISPLAY LINE
    ISPEXEC SELECT PGM(BLSGSCMD) PARM(OPEN &FILEORDSN)
    SET OPENCC = &LASTCC
    ISPEXEC CONTROL DISPLAY REFRESH
  END
  ELSE SET OPENCC = 0
 END

 IF &OPENCC ^= 0 THEN EXIT C(&OPENCC)

 /**********************************************************************
 /*      Get dumptitle
 /**********************************************************************
 IF &STR(&IPDSN) ^= 1 THEN DO
   ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPDSNI)
   ISPEXEC VGET (IPTIT)
   SET &L = &LENGTH(&NRSTR(&IPTIT))+1
   IF &L > 65 THEN DO
     SET IPTIT1 = &SUBSTR(1:65,&NRSTR(&IPTIT))
     IF &L > 130 THEN +
         SET IPTIT2 = &SUBSTR(67:130,'&NRSTR(&IPTIT)')
     ELSE IF &L > 66 THEN +
         SET IPTIT2 = &SUBSTR(67:&L,'&NRSTR(&IPTIT)')
     ELSE +
         SET IPTIT2 = &STR()
   END
   ELSE DO
     SET IPTIT1 = &NRSTR(&IPTIT)
     SET IPTIT2 =
   END
 END
 ELSE DO
   SET IPTIT1 = &STR(NONE)
   SET IPTIT2 = &STR(      (Active main storage has been requested))
 END
 ISPEXEC VPUT (IPDSN IPTIT1 IPTIT2)

 /**********************************************************************
 /*      Get correct ASID
 /**********************************************************************

 ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPVASID &XTRACE)
 ISPEXEC VGET (IPASID IPASIDX IPASCB IPJOBN) SHARED

 /**********************************************************************
 /*      Display dump-options panel
 /**********************************************************************

 ISPEXEC SELECT PANEL(IPDAN)

 EXIT C(0)

 COPY_FROM_SYS1: PROC 0
  NGLOBAL NGTODATASET NGNEWAPPL IPDSN
  SET ERROR = 0
  SET IPNEWDSN = &STR(&TODATASET)
  ISPEXEC VPUT (IPNEWDSN)
  ISPEXEC CONTROL DISPLAY SAVE
  ISPEXEC DISPLAY PANEL(IPSYS1)  /* sets IPNEWDSN
  IF &LASTCC ^= 0 THEN EXIT C(12)
  IF &NRSTR(&IPNEWDSN) ^= &STR() THEN DO
   XDELETE &IPNEWDSN NOINFORM
   ISPEXEC SELECT PGM(BLSGSCMD) NEWAPPL(&NEWAPPL) +
                  PARM(DROPDUMP DSN(&IPDSN)) PASSLIB
   ALLOC FI(CPYPRINT) DUMMY REU
   ALLOC FI(CPYIN) DUMMY REU
   ALLOC FI(CPYUT1) DA(&IPDSN) SHR REU
   ALLOC FI(CPYUT2) DA(&IPNEWDSN) LIKE(&IPDSN) REU
   WRITE *** Copy from &IPDSN to &IPNEWDSN in progress
   XINV IEBGENER +
        SYSPRINT(CPYPRINT) SYSIN(CPYIN) SYSUT1(CPYUT1) SYSUT2(CPYUT2)
   IF &LASTCC ^= 0 THEN DO
    SET IPSMSG = &STR(Copy failed.)
    SET IPLMSG = &STR(Copy of &IPDSN to &IPNEWDSN unsuccessful.)
    ISPEXEC SETMSG MSG(IPZ000)
    SET ERROR = 12
   END
   ELSE DO
    FREE F(CPYPRINT CPYIN CPYUT1 CPYUT2)
    ALLOC FI(CLRPRINT) DUMMY REU
    ALLOC FI(CLRIN) DUMMY REU
    ALLOC FI(CLRUT1) DUMMY REU +
                     RECFM(F) LRECL(4104) BLKSIZE(4104) DSORG(PS)
    ALLOC FI(CLRUT2) DA(&IPDSN) SHR REU
   WRITE *** Clear of &IPDSN in progress
    XINV IEBGENER +
         SYSPRINT(CLRPRINT) SYSIN(CLRIN) SYSUT1(CLRUT1) SYSUT2(CLRUT2)
    SET IEBCC = &LASTCC
    IF &IEBCC ^= 0 THEN DO
     SET IPSMSG = &STR(Clear failed.)
     SET IPLMSG = &STR(Return code from IEBGENER is &IEBCC..)
     ISPEXEC SETMSG MSG(IPZ000)
     SET ERROR = 0
    END
    FREE FI(CLRUT1,CLRUT2,CLRIN,CLRPRINT)
    IF &ERROR = 0 THEN DO
     SET IPDSN = &STR(&IPNEWDSN)
     SET IPNEWDSN =
     ISPEXEC VPUT (IPDSN IPNEWDSN)
    END
   END
  END
  ELSE DO  /* &IPNEWDSN is blank ... */
   ISPEXEC VPUT (IPDSN IPNEWDSN)
  END
  ISPEXEC CONTROL DISPLAY RESTORE
  SET FILEORDSN = &STR(DSNAME(&IPDSN))
  RETURN CODE(&ERROR)
 END COPY_FROM_SYS1

/***********************************************************************
/*
/* Source:
/*
/* "MVS/XA2.1.2 Installation and User's Guide"
/* IBM International Systems Centers
/* GG24-1596-1
/* (c) Copyright International Business Machines Corporation 1983, 1984
/*
/* Page 159
/*
/***********************************************************************
./ ADD NAME=IPDSNI
 PROC 0 XTRACE
 IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
 CONTROL NOCAPS
   /**************************************************************/
   /*    Get dumptitle                                           */
   /**************************************************************/
 EVAL TITLE DIALOG(STORAGE(IPTIT))
 IF &LASTCC = 0 THEN +
  ISPEXEC VPUT (IPTIT) SHARED
 EXIT
/***********************************************************************
/*
/* Source:
/*
/* "MVS/XA2.1.2 Installation and User's Guide"
/* IBM International Systems Centers
/* GG24-1596-1
/* (c) Copyright International Business Machines Corporation 1983, 1984
/*
/* Page 158
/*
/***********************************************************************
./ ADD NAME=IPFORM
 PROC 0 XTRACE
 IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
 CONTROL NOFLUSH NOCAPS
 /**************************************************************/
 /*        Format dump                                         */
 /**************************************************************/
 ISPEXEC VGET (ZTEMPF IPDSN)
 REPEAT:+
 ISPEXEC DISPLAY PANEL(IPFORM)
 IF &LASTCC ^= 0 THEN EXIT
 ISPEXEC VGET (IPD)
 IF &IPD = P THEN DO
   /**************************************************************/
   /*        Print formatted dump                                */
   /**************************************************************/
   ISPEXEC FTOPEN TEMP
   ISPEXEC FTINCL IPPRINT
   ISPEXEC FTCLOSE
   SUBMIT '&ZTEMPF'
   ISPEXEC SETMSG MSG(IP005)
 END
 ELSE DO
   /**************************************************************/
   /*      Display formatted dump                                */
   /**************************************************************/
   SET BS = &STR(ISPEXEC SELECT PGM(BLSGSCMD) PARM)
   SET NG = &STR(Not valid for display output)
   IF &STR(.&IPP12)  ^= . THEN DO
     &BS(VERBEXIT DAEDATA)
     &BS(VERBEXIT SUMDUMP)
   END
   IF .&STR(&IPP1)   ^= . THEN &BS(VERBEXIT ASMDATA)
   IF .&STR(&IPP2)   ^= . THEN &BS(NOTE 'CPUDATA &NG' ASIS)
   IF .&STR(&IPP3)   ^= . THEN &BS(VERBEXIT CVTMAP)
   IF .&STR(&IPP4)   ^= . THEN &BS(VERBEXIT GRSTRACE)
   IF .&STR(&IPP5)   ^= . THEN &BS(VERBEXIT LOGDATA)
   IF .&STR(&IPP6)   ^= . THEN &BS(NOTE 'LPAMAP &NG' ASIS)
   IF .&STR(&IPP7)   ^= . THEN &BS(VERBEXIT MTRACE)
   IF .&STR(&IPP8)   ^= . THEN &BS(VERBEXIT NUCMAP '&IPSORT')
   IF .&STR(&IPP9)   ^= . THEN &BS(VERBEXIT RSMDATA)
   IF .&STR(&IPP10)  ^= . THEN &BS(VERBEXIT SRMDATA)
   IF .&STR(&IPP11)  ^= . THEN &BS(VERBEXIT VTAMMAP)
   IF .&STR(&IPIOS)  ^= . THEN &BS(VERBEXIT IOSDATA '&IPIOS')
   IF .&STR(&IPTRC)  ^= . THEN &BS(VERBEXIT TRACE '&IPTRC')
   IF .&STR(&IPVSM)  ^= . THEN &BS(VERBEXIT VSMDATA '&IPVSM')
   IF .&STR(&IPPRT1) ^= . THEN &BS(NOTE 'PRINT keyword &NG' ASIS)
   IF .&STR(&IPCVT)  ^= . THEN &BS(NOTE 'CVT keyword &NG' ASIS)
   IF .&STR(&IPSEG)  ^= . THEN &BS(NOTE 'SEGTAB keyword &NG' ASIS)
 END
 GOTO REPEAT
/***********************************************************************
/*
/* Source:
/*
/* "MVS/XA2.1.2 Installation and User's Guide"
/* IBM International Systems Centers
/* GG24-1596-1
/* (c) Copyright International Business Machines Corporation 1983, 1984
/*
/* Page 163
/*
/***********************************************************************
./ ADD NAME=IPHEADER
 PROC 0 XTRACE
 IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
 CONTROL NOCAPS
 ISPEXEC SELECT PGM(BLSGSCMD) PARM(%GETASID &XTRACE)
 IF &IPASID = 0 THEN EXIT
 CONTROL NOFLUSH
 ISPEXEC SELECT PGM(BLSGSCMD) PARM(%HEADER &XTRACE)
./ ADD NAME=IPMOVE
 PROC 0 XTRACE
 IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
 CONTROL NOCAPS
   /****************************************************************/
   /*  Move dump dataset.  Compare IPSAVE, which saves SYS1 dump   */
   /****************************************************************/
 ISPEXEC VGET (ZYEAR ZMONTH ZDAY IPSF IPDSN)
 SET IPACT = &STR(Move and clear)
 SET IPSDSCN1 =
 SET IPSDSCN2 =
 IF &SUBSTR(1:10,&IPDSN          ) = 'SYS1.DUMP THEN DO
  SET SYS1P = T
  SET SYSOUTTRAP = 2
  SYSDSCAN &SUBSTR(11:12,&IPDSN            )
  SET SYSOUTTRAP = 0
  SET IPSDSCN1 = &NRSTR(&SYSOUTLINE1
  SET IPSDSCN2 = &NRSTR(&SYSOUTLINE2
 END
 ELSE SET SYS1P = NIL
 ISPEXEC DISPLAY PANEL(IPMOVE)
 IF &LASTCC NE 0 THEN DO
   ISPEXEC SETMSG MSG(IP003)   /* &IPDSN not cleared */
   EXIT
 END
 SET SYSDVAL = &STR(&IPSDSN)
 READDVAL IPSDSN  /* Strip quotes */
 IF &STR(&IPSDSN) = THEN DO
  /*  IPSDSN = &STR(&SYSUID..DUMP&IPSF..D&ZYEAR.&ZMONTH.&ZDAY..SVCDUMP)
  WRITE Error - no dump dataset name specified.
  EXIT Q
 END
 ISPEXEC SELECT PGM(BLSGSCMD) +
                PARM(%IPMOVEIT &IPDSN '&IPSDSN' &SYS1P &XTRACE)
 EXIT

./ ADD NAME=IPMOVEIT
PROC 3 OLDDSN NEWDSN SYS1P XTRACE
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS NOFLUSH
EVALDEF CLIST(SOURCE(SAVESRC))
ERROR GOTO CLEANUP
SYSCALL DO_IT &OLDDSN &NEWDSN &SYS1P
CLEANUP: ERROR OFF
IF &STR(&SAVESRC) = &STR(DSNAME(&OLDDSN)) THEN SETDEF NODSN
ELSE SETDEF &SAVESRC

EXIT

DO_IT: PROC 3 OLDDSN NEWDSN SYS1P

 SETDEF DSN(&OLDDSN)
 SYSCALL SAVE_CONTENTS &OLDDSN &NEWDSN
 SETDEF NODSN
 DROPDUMP DSN(&OLDDSN)
 ALLOC DA(&NEWDSN) LIKE(&OLDDSN) CYL SPACE(10 10)
 WRITE Copying &OLDDSN to &NEWDSN
 WRITE
 NOTE SPACE(1)
 NOTE 'Copying '&OLDDSN' to '&NEWDSN'' ASIS
 NOTE SPACE(1)
 COPYDUMP OUTDATASET(&NEWDSN) +
          INDATASET (&OLDDSN) +
          NOCONFIRM
 SET COPYDUMPCC = &LASTCC
 SELECT &COPYDUMPCC
  WHEN (0) DO
  END
  OTHERWISE DO
   SET IPSMSG = &STR(COPYDUMP failed.)
   SET IPLMSG = &STR(&OLDDSN not copied to &NEWDSN, COPYDUMP +
                      error code &COPYDUMPCC..)
   ISPEXEC SETMSG MSG(IPZ000)
   RETURN CODE(&COPYDUMPCC)
  END
 END
 SYSCALL RESTORE_CONTENTS &OLDDSN &NEWDSN
 IF &SYS1P = T THEN DO
  ALLOC FI(CLRPRINT) DUMMY REU
  ALLOC FI(CLRIN) DUMMY REU
  ALLOC FI(CLRUT1) DUMMY REU +
                   RECFM(F) LRECL(4104) BLKSIZE(4104) DSORG(PS)
  ALLOC FI(CLRUT2) DA(&OLDDSN) SHR REU
  XINV IEBGENER +
       SYSPRINT(CLRPRINT) SYSIN(CLRIN) SYSUT1(CLRUT1) SYSUT2(CLRUT2)
  SET IEBCC = &LASTCC
  IF &IEBCC = 0 THEN DO
   SET IPSMSG = &STR(Dump moved.)
   SET IPLMSG = &STR(&OLDDSN copied to &NEWDSN and cleared.)
   ISPEXEC SETMSG MSG(IPZ000)
  END
  ELSE DO
   SET IPSMSG = &STR(Copied, not moved.)
   SET IPLMSG = &STR(&OLDDSN clear failed, IEBGENER code &IEBCC..)
   ISPEXEC SETMSG MSG(IPZ000)
  END
  FREE FI(CLRUT1,CLRUT2,CLRIN,CLRPRINT)
 END
 ELSE DO
  NOTE SPACE(1)
  SYSCALL TSO_COMMAND CMD('XDELETE '&OLDDSN'')
  NOTE SPACE(1)
  SET DELCC = &LASTCC
  IF &DELCC = 0 THEN DO
   SET IPSMSG = &STR(Dump moved.)
   SET IPLMSG = &STR(&OLDDSN copied to &NEWDSN and deleted.)
   ISPEXEC SETMSG MSG(IPZ000)
  END
  ELSE DO
   SET IPSMSG = &STR(Copied, not moved.)
   SET IPLMSG = &STR(&OLDDSN delete failed, XDELETE code &DELCC..)
   ISPEXEC SETMSG MSG(IPZ000)
  END
 END

END DO_IT


NGLOBAL TEMP_CLIST_NAME


SAVE_CONTENTS: PROC 2 OLDDSN NEWDSN

EVALDEF CLIST(DECIMAL +
              CONFIRM      (EVALDEFCONFIRM      ) +
              DISPLAY      (EVALDEFDISPLAY      ) +
              DATASET      (EVALDEFDATASET      ) +
              FLAG         (EVALDEFFLAG         ) +
              LENGTH       (EVALDEFLENGTH       ) +
              PRINT        (EVALDEFPRINT        ) +
              PROBLEM      (EVALDEFPROBLEM      ) +
              QUALIFICATION(EVALDEFQUALIFICATION) +
              TERMINAL     (EVALDEFTERMINAL     ) +
              TEST         (EVALDEFTEST         ) +
              VERIFY       (EVALDEFVERIFY       ) +
             )

SET TEMP_CLIST_NAME = &STR('&SYSUID..$$$$TEMP.IPMOVE.CLIST')
SET STAT = &SYSDSN(&TEMP_CLIST_NAME)
IF &STAT = OK THEN SET DISP = OLD
ELSE SET DISP = NEW
ALLOC F(IPSVDUMP) DA(&TEMP_CLIST_NAME) T SP(50 50) &DISP REU +
      RECFM(V B) LRECL(255) BLKSIZE(6233) DSORG(PS)
OPENFILE IPSVDUMP OUTPUT
CONTROL NOFLUSH
ERROR DO
 SET CC = &LASTCC
 IF &CC = 12 AND &MIGHTFAIL = Y THEN RETURN
 WRITE Error processing IPCS subcommand &SYSSCMD - return code &CC
 WRITENR Continue ((Y)/N) ?
 CONTROL CAPS
 READ ANS
 CONTROL NOCAPS
 IF &ANS = N THEN GOTO DIE
 ELSE RETURN
END
SET IPSVDUMP = &STR(PROC 0 XTRACE)
PUTFILE IPSVDUMP
SET IPSVDUMP = &STR(+
               IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST)
PUTFILE IPSVDUMP
SET IPSVDUMP = &STR(CONTROL NOCAPS NOFLUSH)
PUTFILE IPSVDUMP
SET IPSVDUMP = &STR(SETDEF DSN(&NEWDSN) &EVALDEFQUALIFICATION +)
PUTFILE IPSVDUMP
SET IPSVDUMP = &STR(+
           &EVALDEFCONFIRM +
           DISPLAY(&EVALDEFDISPLAY) +
           FLAG(&EVALDEFFLAG) +
           LENGTH(&EVALDEFLENGTH) +
           &EVALDEFPRINT +
           &EVALDEFPROBLEM +
           &EVALDEFTERMINAL +
           &EVALDEFTEST +
           &EVALDEFVERIFY +
  )
PUTFILE IPSVDUMP
SET EVALSYMBOL = @
SET GE = &STR(GE)
LOOP:+
CONTROL LIST
SET CC = 0
SET MIGHTFAIL = Y
EVALSYM &GE &EVALSYMBOL +
        CLIST(HEXADECIMAL +
              ADDRESS      (EVALSYMADDRESS      ) +
              SYMBOL       (EVALSYMSYMBOL       ) +
             )
IF &CC = 0 THEN DO
 SET MIGHTFAIL = N
 EVALSYM &EVALSYMSYMBOL +
         CLIST(DECIMAL +
               DATATYPE     (EVALSYMDATATYPE     ) +
               DIMENSION    (EVALSYMDIMENSION    ) +
               DROP         (EVALSYMDROP         ) +
               ENTRY        (EVALSYMENTRY        ) +
               LENGTH       (EVALSYMLENGTH       ) +
               POSITION     (EVALSYMPOSITION     ) +
               QUALIFICATION(EVALSYMQUALIFICATION) +
               REMARK       (EVALSYMREMARK       ) +
              )
 SELECT &STR(&EVALSYMSYMBOL &EVALSYMDROP)
  WHEN (COMMON NODROP   | CVT NODROP   | GDA NODROP| PRIVATE NODROP +
      | PRIVATEX NODROP | TITLE NODROP | X NODROP  | X DROP) DO

   NOTE 'Skipping '&OLDDSN' ==> &EVALSYMSYMBOL' ASIS
  END
  OTHERWISE DO
   IF &NRSTR(&EVALSYMREMARK) ^= THEN DO
    SET FUCK_ME_HARDER = &NRSTR(&EVALSYMREMARK)
/*  SYSCALL QUOTIFY FUCK_ME_HARDER
    SET EVALSYMREMARK = &NRSTR(&FUCK_ME_HARDER)
    SET REMARK = &NRSTR(REMARK('&EVALSYMREMARK'))
   END
   ELSE +
    SET REMARK =
   IF &NRSTR(&EVALSYMDIMENSION) > 0 THEN +
    SET DIMENSION = &NRSTR(DIMENSION(&EVALSYMDIMENSION))
   ELSE +
    SET DIMENSION =
   SET IPSVDUMP = &STR(+
       NOTE 'Restoring '&NEWDSN' ==> &EVALSYMSYMBOL' ASIS)
   PUTFILE IPSVDUMP
   SET IPSVDUMP = &STR(+
    EQ &EVALSYMSYMBOL &EVALSYMADDRESS.. +
       &EVALSYMDATATYPE +
       &DIMENSION +
       &EVALSYMDROP +
       ENTRY(&EVALSYMENTRY) +
       LENGTH(&EVALSYMLENGTH) +
       POSITION(&EVALSYMPOSITION) +
       &QUALIFICATION +
       &NRSTR(&REMARK) +
      )
   PUTFILE IPSVDUMP
   NOTE 'Saving   '&OLDDSN' ==> &EVALSYMSYMBOL' ASIS
  END
 END
 SET EVALSYMBOL = &NRSTR(&EVALSYMSYMBOL)
 SET GE = &STR(GT)
 GOTO LOOP
END
RETURN:+
CONTROL NOCONLIST NOSYMLIST
ERROR OFF
CLOSFILE IPSVDUMP
TSO FREE F(IPSVDUMP)
RETURN
DIE:+
WRITE DYING...
ERROR OFF
CLOSFILE IPSVDUMP
TSO FREE F(IPSVDUMP)
EXIT CODE(16)

END SAVE_CONTENTS


RESTORE_CONTENTS: PROC 2 OLDDSN NEWDSN

 EXEC &TEMP_CLIST_NAME '&XTRACE'

END RESTORE_CONTENTS


TSO_COMMAND: PROC 0 CMD()

 SET CMDL = &NRSTR(&CMD)
 SYSCALL QUOTIFY CMDL
/*                                                */
/* SET TSOANS = &STR()                            */
/* DO WHILE &TSOANS ^= Y && &TSOANS ^= N          */
/*  WRITENR &NRSTR(&CMDL) (Y/N) ?                 */
/*  READ TSOANS                                   */
/*  IF &NRSTR(&TSOANS) = N THEN RETURN CODE(0)    */
/*  IF &NRSTR(&TSOANS) ^= Y THEN DO               */
/*   WRITE WHAT?                                  */
/*  END                                           */
/* END                                            */
/*                                                */
 NOTE '&NRSTR(&CMDL)' ASIS
 SET SYSOUTTRAP = 32767
 &NRSTR(&CMD)
 SET RC = &LASTCC
 DO I = 1 TO &SYSOUTLINE
  SET LINE = &SYSNSUB(2,&&SYSOUTLINE&I)
  SYSCALL QUOTIFY LINE
  NOTE '&NRSTR(&LINE)' ASIS
 END
 SET SYSOUTTRAP = 0
 RETURN CODE(&RC)

END TSO_COMMAND

QUOTIFY: PROC 1 IN
SYSREF IN
IF &SYSINDEX(',&NRSTR(&IN)) = 0 THEN DO
 RETURN
END
SET L = &LENGTH(&NRSTR(&IN))
DO N = 1 TO &L
 SET C = &SUBSTR(&N,&NRSTR(&IN))
 IF &NRSTR(&C) = ' THEN DO
  SET OUT = &NRSTR(&OUT)''
 END
 ELSE SET OUT = &NRSTR(&OUT&C)
END
SET IN = &NRSTR(&OUT)
RETURN

END QUOTIFY

./ ADD NAME=IPPRIM
/**********************************************************************/
/*                                                                    */
/*                  IPCS Dialogs Initialization                       */
/*                                                                    */
/* PFK settings are in 'SYSPGMR.CMD.TABLE(IPCSPROF)', so they         */
/* do not have to be set here.  This enables this CLIST to run under  */
/* APPLID ISR, so ZTRAIL can be passed from the selection menu.       */
/*                                                                    */
/**********************************************************************/
 PROC 0 APPL(BLSG) XTRACE
 IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
 CONTROL NOFLUSH NOCAPS
 ISPEXEC VGET (ZTRAIL) SHARED
 ISPEXEC SELECT +
     PGM(BLSG) +
     PARM(CMD(%IPPRIM2 O('&ZTRAIL') &XTRACE) NEWAPPL(&APPL) PASSLIB) +
     NEWAPPL(&APPL) +
     PASSLIB
 SET MYCC = &LASTCC
 IF &MYCC > 4 THEN DO
  ISPEXEC DISPLAY PANEL(IPERROR)
  EXIT
 END
 EXIT
/***********************************************************************
/*
/* Source:
/*
/* "MVS/XA2.1.2 Installation and User's Guide"
/* IBM International Systems Centers
/* GG24-1596-1
/* (c) Copyright International Business Machines Corporation 1983, 1984
/*
/* Page 158
/*
/***********************************************************************
./ ADD NAME=IPPRIM2
PROC 0 OPT() XTRACE
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
IF &STR(&OPT) ^= THEN SET OPT = &STR( OPT(&OPT))
ELSE SET OPT =
ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPPRIM3 &XTRACE)
ISPEXEC VGET (IPDDSN) SHARED
IF &SUBSTR(1:7,&IPDDSN       ) = &SUBSTR(1:7,DSNAME()) THEN DO
 SET SYSDVAL = &SUBSTR(7:&LENGTH(&STR(&IPDDSN)),&IPDDSN)
 READDVAL IPDDSN
END
ELSE SET IPDDSN =
ISPEXEC VPUT (IPDDSN) SHARED
ISPEXEC SELECT PANEL(IPPRIM)&OPT
EXIT
./ ADD NAME=IPPRIM3
PROC 0 XTRACE
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
EVALDEF DIALOG(SOURCE(IPDDSN))
ISPEXEC VPUT (IPDDSN) SHARED
EXIT
./ ADD NAME=IPRB

/**********************************************************************/
/*                                                                    */
/* This CLIST invokes an ISPF dialog which displays a list of RB's.   */
/*                                                                    */
/* The positional parameter is a TCB address (see IPTCB).             */
/*                                                                    */
/**********************************************************************/

PROC 1 TCBADDR XTRACE
IF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST
CONTROL NOFLUSH NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
 WRITE *** You must be in IPCS to use this CLIST. ***
 EXIT C(16) Q
END
EVAL &TCBADDR+1 L(3) PTR CLIST(S(RBADDR))
IF &LASTCC=12 THEN DO
 NOTE 'IPRB: Error accessing TCB at &TCBADDR' ASIS
 EXIT C(16) Q
END
/******************************************************************/
/* Create table to contain RBs for this TCB                       */
/******************************************************************/
ISPEXEC CONTROL ERRORS RETURN
ISPEXEC TBCREATE IPRBTBL +
        KEYS() +
        NAMES(IRBSEL IRBEXIT IRBADDR IRBTYPE +
              IRBNAME IRBINT IRBPSW1 IRBPSW2 IRBWHERE +
              IRBREG0 IRBREG1 IRBREG2 IRBREG3 IRBREG4 IRBREG5 +
              IRBREG6 IRBREG7 IRBREG8 IRBREG9 IRBREGA IRBREGB +
              IRBREGC IRBREGD IRBREGE IRBREGF) +
        NOWRITE REPLACE
IF &LASTCC > 4 THEN DO
 ISPEXEC DISPLAY PANEL(ISPTERM)
 GOTO EXIT
END

/******************************************************************/
/* Process all RBs for this address space                         */
/******************************************************************/

DO WHILE &RBADDR^=0
 ISPEXEC TBVCLEAR IPRBTBL
 INTEGER X'&RBADDR' PTR DIALOG(S(IRBADDR))
 EVAL &RBADDR..-01 LE(1) HEX DIALOG(S(IRBINT))
 EVAL &RBADDR..+10 LE(4) PTR DIALOG(S(IRBPSW1))
 EVAL &RBADDR..+14 LE(4) PTR DIALOG(S(IRBPSW2))

 /******************************************************************/
 /* Figure out the RB type.                                        */
 /******************************************************************/

  COMPARE ADDR(&RBADDR..+A) LE(1) +
          WITH(VALUE(X'00')) MASK(X'E0')        /* Is it a PRB?
  IF &LASTCC = 0 THEN +
   SET IRBTYPE = PRB
  ELSE DO
   COMPARE ADDR(&RBADDR..+A) LE(1) +
           WITH(VALUE(X'C0')) MASK(X'E0')        /* Is it an SVRB?
   IF &LASTCC = 0 THEN +
    SET IRBTYPE = SVRB
   ELSE DO
    COMPARE ADDR(&RBADDR..+A) LE(1) +
            WITH(VALUE(X'60')) MASK(X'E0')        /* Is it a TIRB?
    IF &LASTCC = 0 THEN +
     SET IRBTYPE = TIRB
    ELSE DO
     COMPARE ADDR(&RBADDR..+A) LE(1) +
             WITH(VALUE(X'40')) MASK(X'E0')        /* Is it an IRB?
     IF &LASTCC = 0 THEN +
      SET IRBTYPE = IRB
     ELSE DO
      COMPARE ADDR(&RBADDR..+A) LE(1) +
              WITH(VALUE(X'80')) MASK(X'E0')        /* Is it an SIRB?
      IF &LASTCC = 0 THEN +
       SET IRBTYPE = SIRB
      ELSE +
       SET IRBTYPE = ???
    END
   END
  END
 END

/**********************************************************************/
/*                                                                    */
/* Resolve the PSW address.                                           */
/*                                                                    */
/**********************************************************************/

 SYSCALL IPRBWHR &IRBPSW2
 ISPEXEC VGET (IRBWHERE)

 /******************************************************************/
 /* Try to get a module name to identify this RB.                  */
 /******************************************************************/

 SET IRBNAME = &STR(********)

 /* To extract the CDE module name, RB must be a PRB, else no sale. */

GETCDE:+
 COMPARE ADDRESS(&RBADDR..+A) LENGTH(1) WITH(VALUE(X'00')) MASK(X'E0')
 IF &LASTCC = 0 THEN DO
  EVAL &RBADDR..+D LE(3) PTR CLIST(S(CDEADDR))
  IF &CDEADDR ^= 0 THEN DO
   EVAL &CDEADDR..+8 LE(8) CHAR CLIST(S(IRBNAME))
  END
 END

/**********************************************************************/
/*                                                                    */
/* Get the registers.                                                 */
/*                                                                    */
/**********************************************************************/

 EVAL &RBADDR..+20 L(4) HEX CLIST(S(IRBREG0))
 EVAL &RBADDR..+24 L(4) HEX CLIST(S(IRBREG1))
 EVAL &RBADDR..+28 L(4) HEX CLIST(S(IRBREG2))
 EVAL &RBADDR..+2C L(4) HEX CLIST(S(IRBREG3))
 EVAL &RBADDR..+30 L(4) HEX CLIST(S(IRBREG4))
 EVAL &RBADDR..+34 L(4) HEX CLIST(S(IRBREG5))
 EVAL &RBADDR..+38 L(4) HEX CLIST(S(IRBREG6))
 EVAL &RBADDR..+3C L(4) HEX CLIST(S(IRBREG7))
 EVAL &RBADDR..+40 L(4) HEX CLIST(S(IRBREG8))
 EVAL &RBADDR..+44 L(4) HEX CLIST(S(IRBREG9))
 EVAL &RBADDR..+48 L(4) HEX CLIST(S(IRBREGA))
 EVAL &RBADDR..+4C L(4) HEX CLIST(S(IRBREGB))
 EVAL &RBADDR..+50 L(4) HEX CLIST(S(IRBREGC))
 EVAL &RBADDR..+54 L(4) HEX CLIST(S(IRBREGD))
 EVAL &RBADDR..+58 L(4) HEX CLIST(S(IRBREGE))
 EVAL &RBADDR..+5C L(4) HEX CLIST(S(IRBREGF))

/**********************************************************************/
/*                                                                    */
/* Add this RB info to the table.                                     */
/*                                                                    */
/**********************************************************************/

 ISPEXEC TBADD IPRBTBL
 IF &LASTCC > 4 THEN DO
  ISPEXEC DISPLAY PANEL(ISPTERM)
  GOTO EXIT
 END

/**********************************************************************/
/*                                                                    */
/* Determine if another RB is chained.  If so, prepare to process it. */
/* In any case, set the chain pointer.                                */
/*                                                                    */
/**********************************************************************/

 COMPARE ADDR(&RBADDR..+B) LE(1) +
         WITH(VALUE(X'80')) MASK(X'80') /* Does NEXTRB point to TCB?
 IF &LASTCC = 0 THEN DO
  SET RBADDR = &STR(000000)
 END
 ELSE DO
  EVAL &RBADDR..+1D LE(3) PTR CLIST(S(RBADDR))
  IF &LASTCC=12 THEN DO
   NOTE '==> Error: Next RB not available from RB(&RBADDR)'
   EXIT C(4)
  END
 END
END

/******************************************************************/
/* Display the table of RB's.                                    */
/******************************************************************/

REDISP:+
ISPEXEC TBTOP IPRBTBL
IF &LASTCC ^= 0 THEN DO
 ISPEXEC DISPLAY PANEL(ISPTERM)
 GOTO EXIT
END
SET TABLECC = 0
DO WHILE &TABLECC < 8
 IF &TABLECC = 4 THEN DO /* ISPEXEC TBDISPL
  WRITE Multiple table entries not allowed
  SET IRBSEL =
  SET IRBEXIT =
  GOTO REDISP
 END
 ELSE ISPEXEC TBDISPL IPRBTBL PANEL(IPRBTBL)
 SET TABLECC = &LASTCC
 IF &TABLECC > 8 THEN DO
  ISPEXEC DISPLAY PANEL(ISPTERM)
  GOTO EXIT
 END
 IF &TABLECC < 8 THEN DO
  SET IRBSEL  = &STR(&SYSCAPS(&IRBSEL))
  SET IRBEXIT = &STR(&SYSCAPS(&IRBEXIT))
  IF &STR(&IRBSEL&IRBEXIT) ^= THEN DO
   ISPEXEC CONTROL DISPLAY SAVE
   IF &IRBSEL = THEN DO
    IF &STR(&IRBEXIT) ^= THEN +
    ISPEXEC SELECT PGM(BLSGSCMD) PARM(%&IRBEXIT RB(&IRBADDR..) &XTRACE)
   END
   ELSE DO
    ISPEXEC SETMSG MSG(IPZ002)
    SET IRBSEL =
    SET IRBEXIT =
    GOTO REDISP
   END
   ISPEXEC CONTROL DISPLAY RESTORE
  END
  IF &NRSTR(&IRBCMD) ^= THEN DO
   ISPEXEC CONTROL DISPLAY SAVE
   ISPEXEC SELECT PGM(BLSGSCMD) PARM(&IRBCMD)
   ISPEXEC CONTROL DISPLAY RESTORE
  END
 END
END
ISPEXEC TBEND IPRBTBL
GOTO EXIT
EXIT:+
ISPEXEC CONTROL DISPLAY REFRESH
EXIT

IPRBWHR:PROC 1 ADDRESS

/******************************************************************/
/*                                                                */
/* Process an RB PSW address.                                     */
/*                                                                */
/* This is done by means of executing a TCB exit routine that     */
/* determines the load module and offset, returning it in ISPF    */
/* variables VITPLACE, VITNAME and VITLOC.                        */
/*                                                                */
/******************************************************************/

 SET I = &SYSINDEX(&SUBSTR(1,&ADDRESS),89ABCDEF)
 IF &I ^= 0 THEN +
  SET ADDRESS = &SUBSTR(&I,01234567)&SUBSTR(2:8,&ADDRESS)
 TCBEXIT VITWHR &ADDRESS..
 IF &LASTCC ^= 0 THEN DO
  WRITE Error: TCB exit VITWHR unable to process address &ADDRESS..
  SET IRBWHERE = &STR(*ERROR*)
 END
 ELSE DO
  ISPEXEC VGET (VITNAME VITPLACE VITLOC VITOFF) SHARED
  SET VGETCC = &LASTCC
  IF &VGETCC ^= 0 THEN DO
   WRITE Error: Return code from VGET was &VGETCC..
   SET IRBWHERE = &STR(*ERROR*)
  END
  ELSE IF &NRSTR(&VITNAME) = UNAVAILABLE THEN DO
   SET IRBWHERE = UNAVAILABLE
  END
  ELSE DO
   SET IRBWHERE = &SUBSTR(1:8,&VITNAME        )&STR(+&VITOFF)
  END
 END
 ISPEXEC VPUT (IRBWHERE)

END IPRBWHR

./ ADD NAME=IPSHOW
PROC 1 EXPRESSION
CONTROL NOCAPS
TCBEXIT YITADDR &NRSTR(&EXPRESSION) POSITION(+0)
IF &LASTCC = 0 THEN DO
 WRITE &NRSTR(&EXPRESSION) is at &YITHEX..
END
ELSE DO
 WRITE Erroneous address: &NRSTR(&EXPRESSION)
END
EXIT
./ ADD NAME=IPTBDISP
PROC 1 TBPREF +
       THING(TCB) +
       ADDRESS(UNKNOWN) +
       EXTRA() +
       SCOMMAND('%IPTBDUM') +
       SEL(&TBPREF.SEL) TABLE(&TBPREF.TBL) PANEL(&TABLE.) +
       XTRACE
/**********************************************************************/
/* General-purpose IP... table displayer                              */
/**********************************************************************/

IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
DISP:+
ISPEXEC CONTROL ERRORS CANCEL
ISPEXEC TBTOP &TABLE
REDISP:+
SET TABLECC = 0
DO WHILE &TABLECC < 8
 IF &TABLECC = 4 THEN DO
  ISPEXEC SETMSG MSG(IPZ003)
  GOTO REDISP
 END
 ELSE DO
  ISPEXEC TBDISPL &TABLE PANEL(&PANEL)
 END
 SET TABLECC = &LASTCC
 IF &TABLECC < 8 THEN DO
  IF &NRSTR(&TBLCMD) ^= THEN SYSCALL SUBCOMMAND TBLCMD
  SET &&SEL =
 END
 IF &NRSTR(&ZCMD) ^= THEN SYSCALL SUBCOMMAND ZCMD
 SET ZCMD =
END
ISPEXEC TBEND &TABLE
ISPEXEC CONTROL DISPLAY REFRESH
EXIT

SUBCOMMAND: PROC 1 CMD
 SYSREF CMD
 ISPEXEC CONTROL DISPLAY SAVE
 ISPEXEC CONTROL ERRORS RETURN
 ISPEXEC SELECT PGM(BLSGSCMD) PARM(&NRSTR(&CMD))
 ISPEXEC CONTROL ERRORS CANCEL
 ISPEXEC CONTROL DISPLAY RESTORE
 RETURN
END
./ ADD NAME=IPTCB

/**********************************************************************/
/*                                                                    */
/* This CLIST invokes an ISPF dialog which displays a list of TCB's.  */
/*                                                                    */
/**********************************************************************/

PROC 0 XTRACE
IF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
 WRITE *** You must be in IPCS to use this CLIST. ***
 EXIT C(16) Q
END

/**********************************************************************/
/*                                                                    */
/* Get the desired ASID.                                              */
/*                                                                    */
/**********************************************************************/

%GETASID &XTRACE
SET ASID = &LASTCC
INTEGER &ASID PTR(4) CLIST(S(ASIDX))
INTEGER &ASID UNS    CLIST(S(ASIDN))

/*  EVAL 224. PTR CLIST(S(ASCBADDR))
/*  IF &LASTCC ^= 0 THEN DO
/*   NOTE '==> Error: ASCB address not available at 224.' ASIS
/*   EXIT C(16) Q
/*  END

/**********************************************************************/
/*                                                                    */
/* Get the ASCB for this ASID.  Note that instead of using the PSA's  */
/* ASCBNEW or ASCBOLD pointer, we use the ASID to index into the ASVT */
/* to find it.  In that way you can map the TCB chain from the ASID   */
/* that you requested using SETDEF.                                   */
/*                                                                    */
/**********************************************************************/

CONTROL NOFLUSH
EVALSYM CVT
IF &LASTCC = 12 THEN DO
 EQ CVT 10.%
END

EVAL CVT+22C L(4) PTR CLIST(S(ASVTADDR))
EVAL 10.%+22C L(4) PTR CLIST(S(ASVTADDR))
IF &LASTCC ^= 0 THEN DO
 NOTE '==> Error: ASVT address not available from CVT+22C' ASIS
 EXIT C(16) Q
END
EVAL &ASVTADDR..+204 L(4) UNS CLIST(S(ASVTMAXU))
IF &LASTCC ^= 0 THEN DO
 NOTE '==> Error: ASVTMAXU not available from ASVT at &ASVTADDR' ASIS
 EXIT C(16) Q
END
IF &ASIDN > &ASVTMAXU THEN DO
 NOTE '==> Error: ASID &ASID is invalid, greater than maximum' ASIS
 EXIT C(16) Q
END
SET ASVTOFFS = &ASIDN*4
EVAL &ASVTADDR..+20C+&ASVTOFFS.N L(4) PTR CLIST(S(ASCBADDR))
IF &LASTCC ^= 0 THEN DO
 NOTE '==> Error: ASCB address not available at 224.' ASIS
 EXIT C(16) Q
END
SELECT &SUBSTR(1,&ASCBADDR)
 WHEN (8|9|A|B|C|D|E|F) DO
  NOTE '==> Error: ASID &ASID is not assigned.' ASIS
  EXIT C(16) Q
 END
END

EVAL &ASCBADDR..+AC L(4) PTR CLIST(S(JOBNAMEADDR))
IF &STR(&JOBNAMEADDR) = &STR(00000000) THEN DO
 EVAL &ASCBADDR..+B0 L(4) PTR CLIST(S(JOBNAMEADDR))
END
EVAL &JOBNAMEADDR.. L(8) CHAR CLIST(S(JOBNAME))

EVAL &ASCBADDR..+6C PTR CLIST(S(ASXBADDR))
IF &LASTCC=12 THEN DO
 NOTE '==> Error: ASXB not available for ASID(&ASID)' ASIS
 EXIT C(16) Q
END
SET TCBCTR = 1
EVAL &ASXBADDR..+5 LE(3) PTR CLIST(S(TCBADDR))
IF &LASTCC=12 THEN DO
 L &ASXBADDR..+5 LE(3) PTR
 NOTE '==> Error: TCB&TCBCTR not available for ASID(&ASID)' ASIS
 EXIT C(16) Q
END

/******************************************************************/
/* Create table to contain TCBs for this address space            */
/******************************************************************/

ISPEXEC CONTROL ERRORS RETURN
ISPEXEC TBCREATE IPTCBTBL +
                 KEYS() +
                 NAMES(ITTSEL ITTEXIT ITTADDR ITTNAME +
                       ITTSTUFF +
                       ITTCOMP ITTRTWA +
                       ITTMOM ITTKID ITTSIS) +
                 NOWRITE REPLACE
IF &LASTCC > 4 THEN DO
 ISPEXEC DISPLAY PANEL(ISPTERM)
 GOTO EXIT
END

/******************************************************************/
/* Process all TCBs for this address space                        */
/******************************************************************/

DO WHILE &TCBADDR^=0
 ISPEXEC TBVCLEAR IPTCBTBL
 INTEGER X'&TCBADDR' PTR DIALOG(S(ITTADDR))
 SET MAXCC = 0
 EVAL &TCBADDR..+10 LE(4) HEX DIALOG(S(ITTCOMP))
 EVAL &TCBADDR..+E0 LE(4) PTR DIALOG(S(ITTRTWA))
 EVAL &TCBADDR..+85 LE(3) PTR DIALOG(S(ITTMOM))
 EVAL &TCBADDR..+89 LE(3) PTR DIALOG(S(ITTKID))
 EVAL &TCBADDR..+81 LE(3) PTR DIALOG(S(ITTSIS))

 EVAL &TCBADDR..+7D LE(3) PTR CLIST(S(JSTCB))
 EVAL &TCBADDR..+20 LE(2) UNS CLIST(S(NONDISP))

 IF &MAXCC = 12 THEN DO
  NOTE '==> Error: Cannot access TCB at &TCBADDR for ASID(&ASID)' ASIS
  GOTO REDISP
 END

 /******************************************************************/
 /* Determine if this TCB is nondispatchable or a job step TCB     */
 /******************************************************************/

 IF &STR(&JSTCB) = &STR(&TCBADDR) THEN DO
  SET JOBSTEPTCB = J
 END
 ELSE DO
  SET JOBSTEPTCB = &STR( )
 END

 IF &NONDISP ^= 0 THEN DO
  SET NONDISPATCHABLE = N
 END
 ELSE DO
  SET NONDISPATCHABLE = &STR( )
 END

 SET ITTSTUFF = &STR(&JOBSTEPTCB&NONDISPATCHABLE)

 /******************************************************************/
 /* Try to get a module name to identify this TCB.                 */
 /******************************************************************/

 EVAL &TCBADDR..+01 LE(3) PTR CLIST(S(RBADDR))
 IF &LASTCC = 12 THEN DO
  NOTE '==> Error: Cannot get RB pointer from TCB at &TCBADDR' ASIS
  GOTO NOCDE
 END

 SET ITTNAME = &STR(********)

 /* To extract the CDE module name, RB must be a PRB, else no sale. */

GETCDE:+
 COMPARE ADDRESS(&RBADDR..+A) LENGTH(1) WITH(VALUE(X'00')) MASK(X'E0')
 SET COMPCC = &LASTCC
 IF &COMPCC = 12 THEN DO
  NOTE '==> Error: RB at &RBADDR not available for TCB at &TCBADDR' ASIS
  GOTO NOCDE
 END
 IF &COMPCC = 0 THEN DO
  EVAL &RBADDR..+D LE(3) PTR CLIST(S(CDEADDR))
  IF &CDEADDR ^= 0 THEN GOTO GOTCDE
 END

 COMPARE ADDR(&RBADDR..+B) LE(1) +
         WITH(VALUE(X'80')) MASK(X'80') /* Does NEXTRB point to TCB?
 IF &LASTCC = 0 THEN GOTO NOCDE
 EVAL &RBADDR..+1D PTR LE(3) CLIST(S(RBADDR))
 GOTO GETCDE

GOTCDE:+
 EVAL &CDEADDR..+8 LE(8) CHAR CLIST(S(ITTNAME))

NOCDE:+
 IF &ITTCOMP = 0 THEN SET ITTCOMP =
 IF &ITTRTWA = 0 THEN SET ITTRTWA =
 IF &ITTMOM  = 0 THEN SET ITTMOM  =
 IF &ITTKID  = 0 THEN SET ITTKID  =
 IF &ITTSIS  = 0 THEN SET ITTSIS  =

 ISPEXEC TBADD IPTCBTBL
 IF &LASTCC > 4 THEN DO
  ISPEXEC DISPLAY PANEL(ISPTERM)
  GOTO EXIT
 END
 SET &TCBCTR=&TCBCTR+1
 SYSCALL GET_NEXT_TCB TCBADDR ASID
 IF &LASTCC = 12 THEN EXIT
END

/******************************************************************/
/* Display the table of TCB's.                                    */
/******************************************************************/

REDISP:+
ISPEXEC TBTOP IPTCBTBL
IF &LASTCC ^= 0 THEN DO
 ISPEXEC DISPLAY PANEL(ISPTERM)
 GOTO EXIT
END
SET TABLECC = 0
DO WHILE &TABLECC < 8
 IF &TABLECC = 4 THEN DO /* ISPEXEC TBDISPL
  WRITE Multiple table entries not allowed
  SET ITTSEL =
  SET ITTEXIT =
  GOTO REDISP
 END
 ELSE ISPEXEC TBDISPL IPTCBTBL PANEL(IPTCBTBL)
 SET TABLECC = &LASTCC
 IF &TABLECC > 8 THEN DO
  ISPEXEC DISPLAY PANEL(ISPTERM)
  GOTO EXIT
 END
 IF &TABLECC < 8 THEN DO
  SET ITTSEL  = &STR(&SYSCAPS(&ITTSEL))
  SET ITTEXIT = &STR(&SYSCAPS(&ITTEXIT))
  IF &STR(&ITTSEL&ITTEXIT) ^= THEN DO
   ISPEXEC CONTROL DISPLAY SAVE
   IF &ITTSEL = THEN DO
    IF &STR(&ITTEXIT) ^= THEN +
    ISPEXEC SELECT PGM(BLSGSCMD) PARM(%&ITTEXIT TCB(&ITTADDR..) &XTRACE)
   END
   ELSE IF &ITTSEL = R THEN DO
    ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPRB   &ITTADDR.. &XTRACE)
   END
   ELSE IF &ITTSEL = D THEN DO
    ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPDEB  &ITTADDR.. &XTRACE)
   END
   ELSE IF &ITTSEL = V THEN DO
    ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPVS &ITTADDR &XTRACE)
   END
   ELSE DO
    ISPEXEC SETMSG MSG(IPZ002)
    SET ITTSEL =
    SET ITTEXIT =
    GOTO REDISP
   END
   ISPEXEC CONTROL DISPLAY RESTORE
  END
  IF &NRSTR(&ITTCMD) ^= THEN DO
   ISPEXEC CONTROL DISPLAY SAVE
   ISPEXEC SELECT PGM(BLSGSCMD) PARM(&ITTCMD)
   ISPEXEC CONTROL DISPLAY RESTORE
  END
 END
END
ISPEXEC TBEND IPTCBTBL
GOTO EXIT
EXIT:+
ISPEXEC CONTROL DISPLAY REFRESH
EXIT

GET_NEXT_TCB: PROC 2 TCBADDR ASID
 SYSREF TCBADDR ASID
 /* This is the old way, which doesn't get all the TCBs. */
 /*
 /*EVAL &TCBADDR..+75 LE(3) PTR CLIST(S(TCBADDR))
 /*IF &LASTCC=12 THEN DO
 /* NOTE '==> Error: Cannot access next TCB pointer from &TCBADDR for +
 /*                  ASID(&ASID)' ASIS
 /* RETURN CODE(4)
 /*END
 /*RETURN CODE(0)

/**********************************************************************/
/*                                                                    */
/* Correct logic to get all the TCB's:                                */
/*                                                                    */
/* Start from the top (chain through mothers till no more), and...    */
/*                                                                    */
/*  PROCESS:                                                          */
/*  Process this TCB                                                  */
/*  Get daughter (+88)                                                */
/*   Yes -> PROCESS                                                   */
/*   No...                                                            */
/*  GETSIS:                                                           */
/*  Get sister (+80)                                                  */
/*   Yes -> PROCESS                                                   */
/*   No...                                                            */
/*  Get mother (+84)                                                  */
/*   Yes -> GETSIS                                                    */
/*   No -> exit                                                       */
/*                                                                    */
/**********************************************************************/

 EVAL &TCBADDR..+89 LE(3) PTR CLIST(S(NTCBADDR)) /* daughter TCB */
 IF &LASTCC = 12 THEN GOTO ERROR
 IF &NTCBADDR ^= 0 THEN GOTO PROCESS
GETSIS:+
 EVAL &TCBADDR..+81 LE(3) PTR CLIST(S(NTCBADDR)) /* sister TCB */
 IF &LASTCC = 12 THEN GOTO ERROR
 IF &NTCBADDR ^= 0 THEN GOTO PROCESS
 EVAL &TCBADDR..+85 LE(3) PTR CLIST(S(NTCBADDR)) /* mother TCB */
 IF &LASTCC = 12 THEN GOTO ERROR
 IF &NTCBADDR ^= 0 THEN DO
  SET TCBADDR = &STR(&NTCBADDR)
  GOTO GETSIS
 END
PROCESS: +
 SET TCBADDR = &STR(&NTCBADDR)
 RETURN
ERROR: +
  NOTE '==> Error: Cannot access next TCB pointer from &TCBADDR for +
                   ASID(&ASID)' ASIS
  RETURN CODE(12)

END /* GET_NEXT_TCB */

./ ADD NAME=IPVASID
PROC 0 XTRACE
NGLOBAL ACTIVE
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
SET SETDEFASID = none
SET SYSDVAL = &STR(*** **** ****** ******** +
                   *** **** ****** ******** +
                   *** **** ****** ********)
READDVAL DEFASID DEFASIDX DEFASCB DEFJOBN +
         CURASID CURASIDX CURASCB CURJOBN +
         HDRASID HDRASIDX HDRASCB HDRJOBN
EVALDEF CLIST(QUAL(DEFQUAL) DATASET(DEFDATASET))
IF &STR(&DEFDATASET) = ACTIVE THEN DO
 SET ACTIVE = ACTIVE
END
IF &SUBSTR(1:4,&DEFQUAL    ) = ASID THEN DO
 SET SETDEFASID = &SUBSTR(6:&LENGTH(&STR(&DEFQUAL))-1,&DEFQUAL)
 INTEGER &SETDEFASID UNS    CLIST(S(DEFASID))
 INTEGER &SETDEFASID PTR(4) CLIST(S(DEFASIDX))
 SYSCALL GET_ASCB DEFASCB &DEFASID &DEFASIDX
 SYSCALL GET_JOBNAME DEFJOBN &DEFASCB
END
EVAL 224. PTR CLIST(S(CURASCB)) &ACTIVE
IF &LASTCC ^= 0 THEN DO
 NOTE  'Error:  PSA ASCB pointer not accessible at 224.' ASIS
 IF &ACTIVE = THEN DO
  NOTE '        Dump may be unusable (possibly not a SYSMDUMP).' ASIS
 END
 NOTE SPACE(1)
 EXIT C(12) Q
END
EVAL 224.?+24 L(2) UNS CLIST(S(CURASID)) &ACTIVE
IF &LASTCC ^= 0 THEN DO
 NOTE  'Error:  Couldn''t get ASID from the current ASCB.' ASIS
 IF &ACTIVE = THEN DO
  NOTE '        Dump may be unusable (possibly not a SYSMDUMP).' ASIS
 END
 NOTE SPACE(1)
 EXIT C(12) Q
END
ELSE DO
 INTEGER &CURASID PTR(4) CLIST(S(CURASIDX))
 SYSCALL GET_JOBNAME CURJOBN &CURASCB
END
IF &ACTIVE = THEN DO
 /* Offset of SDUMP common section... */
 EVAL 168. HEADER L(2) HEX CLIST(S(COMMOFF))
 IF &STR(&COMMOFF) ^= &STR(0000) THEN DO
  EVAL &COMMOFF..+48 HEADER L(2) UNS CLIST(S(PASID))
  INTEGER &PASID PTR(4) CLIST(S(PASIDX))
  EVAL &COMMOFF..+4A HEADER L(2) UNS CLIST(S(SASID))
  INTEGER &SASID PTR(4) CLIST(S(SASIDX))
  EVAL &COMMOFF..+4C HEADER L(2) UNS CLIST(S(HASID))
  INTEGER &HASID PTR(4) CLIST(S(HASIDX))
  SET HDRASID = &HASID
  INTEGER &HDRASID PTR(4) CLIST(S(HDRASIDX))
 END
 SYSCALL GET_ASCB HDRASCB &HDRASID &HDRASIDX
 SYSCALL GET_JOBNAME HDRJOBN &HDRASCB
END
ISPEXEC VPUT (DEFASID DEFASIDX DEFASCB DEFJOBN +
              CURASID CURASIDX CURASCB CURJOBN +
              HDRASID HDRASIDX HDRASCB HDRJOBN) SHARED
SET IPASID  = &STR(&DEFASID)
SET IPASIDX = &STR(&DEFASIDX)
SET IPASCB  = &STR(&DEFASCB)
SET IPJOBN  = &STR(&DEFJOBN)
ISPEXEC DISPLAY PANEL(IPCASID) /* choose ASID */
IF &LASTCC > 8 THEN ISPEXEC DISPLAY PANEL(ISPTERM)
IF &STR(&OTHASID) ^= &STR() THEN DO
 INTEGER &OTHASID UNS    CLIST(S(IPASID))
 INTEGER &OTHASID PTR(4) CLIST(S(IPASIDX))
 SET IPASCB = &STR(*UNSET*)
 SET IPJOBN = &STR(*UNSET*)
END
ISPEXEC VPUT (IPASID IPASIDX IPASCB IPJOBN) SHARED
EXIT C(0)

/*IF &SETDEFASID ^= &IPASID THEN DO
/* NOTE 'Warning:  The ASID found in the current ASCB'              ASIS
/* NOTE '          does not match the one that IPCS specified.'     ASIS
/* NOTE '          IPDSN is setting the ASID for IPCS to &IPASID'   ASIS
/* NOTE '          instead of its present setting of &SETDEFASID..' ASIS
/* SETDEF ASID(&IPASID)
/*END

GET_ASCB: PROC 3 AVAR ASIDN ASIDX
 SYSREF AVAR
 SET AVAR = &STR(******)
 IF &STR(&ASIDN) = &STR(***) THEN RETURN CODE(16)

/**********************************************************************/
/*                                                                    */
/* Get the ASCB for this ASID.  Note that instead of using the PSA's  */
/* ASCBNEW or ASCBOLD pointer, we use the ASID to index into the ASVT */
/* to find it.  In that way you can map the TCB chain from the ASID   */
/* that you requested using SETDEF.                                   */
/*                                                                    */
/**********************************************************************/

 IF &ACTIVE = ACTIVE THEN +
  EVAL 10.%+22C L(4) PTR CLIST(S(ASVTADDR))
 ELSE +
  EVAL CVT+22C L(4) PTR CLIST(S(ASVTADDR))
 IF &LASTCC ^= 0 THEN DO
  NOTE '==> Error: ASVT address not available from CVT+22C' ASIS
  RETURN CODE(16)
 END
 EVAL &ASVTADDR..+204 L(4) UNS CLIST(S(ASVTMAXU))
 IF &LASTCC ^= 0 THEN DO
  NOTE '==> Error: ASVTMAXU not available from ASVT at &ASVTADDR' ASIS
  RETURN CODE(16)
 END
 IF &ASIDN > &ASVTMAXU THEN DO
  NOTE '==> Error: ASID &ASID is invalid, greater than maximum' ASIS
  RETURN CODE(16)
 END
 SET ASVTOFFS = &ASIDN*4
 EVAL &ASVTADDR..+20C+&ASVTOFFS.N L(4) PTR CLIST(S(ASCBADDR))
 IF &LASTCC ^= 0 THEN DO
  NOTE '==> Error: ASCB address not available at 224.' ASIS
  RETURN CODE(16)
 END
 SELECT &SUBSTR(1,&ASCBADDR)
  WHEN (8|9|A|B|C|D|E|F) DO
   NOTE '==> Error: ASID &ASID is not assigned.' ASIS
   RETURN CODE(16)
  END
 END
 SET AVAR = &STR(&ASCBADDR)
 RETURN CODE(0)
END

GET_JOBNAME: PROC 2 JOBNAME ASCBADDR
 SYSREF JOBNAME
 SET JOBNAME = &STR(********)
 IF &STR(&ASCBADDR) = &STR(******) THEN RETURN CODE(16)
 EVAL &ASCBADDR..+AC L(4) PTR CLIST(S(JOBNAMEADDR))
 IF &STR(&JOBNAMEADDR) = &STR(00000000) THEN DO
  EVAL &ASCBADDR..+B0 L(4) PTR CLIST(S(JOBNAMEADDR))
 END
 EVAL &JOBNAMEADDR.. L(8) CHAR CLIST(S(JOBNAME))
 RETURN
END

/* GET_JOBNAME: PROC 1 IPASID ACTIVE
/*  SET IPASIDX = &STR(**)
/*  SET IPJOBN  = unavail.
/*  ERROR GOTO VPUT_IT_ANYWAY
/*  INTEGER &IPASID PTR DIALOG(S(IPASIDX))
/*  EVAL 224.?+AC PTR CLIST(S(ASCBJBNI)) &ACTIVE
/*  IF &ASCBJBNI ^= 0 THEN DO
/*   EVAL 224.?+AC? LE(8) CHAR CLIST(S(IPJOBN)) &ACTIVE
/*  END
/*  ELSE DO
/*   EVAL 224.?+B0 PTR CLIST(S(ASCBJBNM)) &ACTIVE
/*   IF &ASCBJBNM ^= 0 THEN DO
/*    EVAL 224.?+B0? LE(8) CHAR CLIST(S(IPJOBN)) &ACTIVE
/*   END
/*  END
/*  VPUT_IT_ANYWAY: ERROR OFF
/*  ISPEXEC VPUT (IPASID IPASIDX IPJOBN) SHARED
/* END
./ ADD NAME=IPVIEW
PROC 0 XTRACE
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
ELSE CONTROL NOLIST
CONTROL NOCAPS
ISPEXEC SELECT PGM(BLSGSCMD) PARM(%IPTCB &XTRACE)
EXIT C(&LASTCC)
./ ADD NAME=IPVS

/**********************************************************************/
/*                                                                    */
/* VS - Virtual Storage Control Block Analysis                        */
/*                                                                    */
/* Reference: MVS/XA SLL: Virtual Storage Management, Part I          */
/*            LY28-1790-0                                             */
/*                                                                    */
/**********************************************************************/

PROC 1 TCB XTRACE
IF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST
CONTROL NOFLUSH NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
 WRITE *** You must be in IPCS to use this CLIST. ***
 EXIT C(16) Q
END

EVAL 10.%+230 LE(4) PTR CLIST(S(GDA))

EVAL &GDA..+6C LE(4) PTR DIALOG(S(GDACSA  )) /* lowest addr of CSA
EVAL &GDA..+70 LE(4) PTR DIALOG(S(GDACSASZ)) /* size of CSA
EVAL &GDA..+7C LE(4) PTR DIALOG(S(GDAECSA )) /* lowest addr of ECSA
EVAL &GDA..+80 LE(4) PTR DIALOG(S(GDAECSAS)) /* size of ECSA
EVAL &GDA..+8C LE(4) PTR DIALOG(S(GDACSACV)) /* CSA converted to SQA
EVAL &GDA..+90 LE(4) PTR DIALOG(S(GDASQA  )) /* lowest addr of SQA
EVAL &GDA..+94 LE(4) PTR DIALOG(S(GDASQASZ)) /* size of SQA
EVAL &GDA..+98 LE(4) PTR DIALOG(S(GDAESQA )) /* lowest addr of ESQA
EVAL &GDA..+9C LE(4) PTR DIALOG(S(GDAESQAS)) /* size of ESQA
EVAL &GDA..+A0 LE(4) PTR DIALOG(S(GDAPVT  )) /* lowest addr of private
EVAL &GDA..+A4 LE(4) PTR DIALOG(S(GDAPVTSZ)) /* size of private
EVAL &GDA..+A8 LE(4) PTR DIALOG(S(GDAEPVT )) /* lowest addr of eprivate
EVAL &GDA..+AC LE(4) PTR DIALOG(S(GDAEPVTS)) /* size of eprivate

ISPEXEC VPUT (+
  GDACSA GDACSASZ GDAECSA GDAECSAS GDACSACV GDASQA GDASQASZ GDAESQA +
  GDAESQAS GDAPVT GDAPVTSZ GDAEPVT GDAEPVTS +
             ) SHARED

SET VVTCB = &STR(&TCB)
ISPEXEC VPUT (VVTCB) SHARED
ISPEXEC CONTROL ERRORS CANCEL
ISPEXEC SELECT PANEL(IPVS)
ISPEXEC CONTROL ERRORS RETURN

./ ADD NAME=IPVSAE
PROC 1 TCBADDR XTRACE
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS

/******************************************************************/
/* Create table of AE's for this TCB                              */
/******************************************************************/

ISPEXEC TBCREATE AETBL +
        KEYS() +
        NAMES(AESEL AEADDR AETYPE +
              AENEXT AEPREV AEAREA EAEAREA AESIZE AEAREAN AESIZEN +
             ) +
        NOWRITE REPLACE

/******************************************************************/
/* Extract pointers to the AE's from the TCB                      */
/******************************************************************/

EVAL &TCBADDR..+9C L(4) PTR CLIST(S(TCBAE))
IF &LASTCC > 0 THEN DO
 NOTE 'Error: TCBAE not available for TCB at &TCBADDR..' ASIS
 EXIT C(16) Q
END

EVAL &TCBADDR..+12C L(4) PTR CLIST(S(TCBEAE))
IF &LASTCC > 0 THEN DO
 NOTE 'Error: TCBEAE not available for TCB at &TCBADDR..' ASIS
 EXIT C(16) Q
END

/**********************************************************************/
/* Process all the AE's                                               */
/**********************************************************************/

SYSCALL PROCESS_AE &TCBAE &XTRACE
SYSCALL PROCESS_AE &TCBEAE EXTENDED &XTRACE

%IPTBDISP AE ADDR(&TCBADDR)

EXIT


PROCESS_AE: PROC 1 AEADDR EXTENDED XTRACE

 DO WHILE &STR(&AEADDR) ^= &STR(00000000)

  EVAL &AEADDR..+00 LE(4)            PTR     CLIST(S(AENEXT))
  EVAL &AEADDR..+04 LE(4)            PTR     CLIST(S(AEPREV))
  EVAL &AEADDR..+08 LE(4)            SIGNED  CLIST(S(AEAREAN))
  EVAL &AEADDR..+0C LE(4)            SIGNED  CLIST(S(AESIZEN))
  INTEGER &AEAREAN                   PTR(8)  CLIST(S(AEAREA))
  INTEGER &AESIZEN                   PTR     CLIST(S(AESIZE))
  INTEGER &EVAL(&AEAREAN + &AESIZEN) PTR(8)  CLIST(S(EAEAREA))

 /*********************************************************************/
 /* Add AE info to the table.                                         */
 /*********************************************************************/

  IF &EXTENDED = EXTENDED THEN SET AETYPE = ABOVE
  ELSE SET AETYPE = BELOW
  ISPEXEC TBADD AETBL

 /*********************************************************************/
 /* Chain to next AE.                                                 */
 /*********************************************************************/

  SET AEADDR = &STR(&AENEXT)
 END

END PROCESS_AE

./ ADD NAME=IPVSCMAP

/**********************************************************************/
/*                                                                    */
/* This CLIST produces a table displaying allocated CSA storage.      */
/*                                                                    */
/* Reference: MVS/XA SLL: Virtual Storage Management, Part I          */
/*            LY28-1790-0                                             */
/*                                                                    */
/**********************************************************************/

PROC 1 TCBADDRESS XTRACEVALUE
NGLOBAL TCBADDR XTRACE +
        ZERRSM ZERRLM ZERRMSG ZERRHM ZERRALRM +
        CMAPSEL +
        CMAPSPID CMAPKEY +
        CMAPLOC +
        CMAPAREA CMAPAREE CMAPSIZE +
        CMAPARNA CMAPARNE CMAPSIZN

IF &XTRACEVALUE ^= THEN DO
 CONTROL LIST CONLIST SYMLIST
 SET XTRACE = XTRACE
END
ELSE SET XTRACE =
CONTROL NOCAPS
SET TCBADDR = &STR(&TCBADDRESS..)

/******************************************************************/
/* Create table to contain all virtual storage info               */
/******************************************************************/

ISPEXEC TBCREATE CMAPTBL +
        KEYS() +
        NAMES(CMAPSEL +
              CMAPSPID CMAPKEY +
              CMAPLOC +
              CMAPAREA CMAPAREE CMAPSIZE +
              CMAPARNA CMAPARNE CMAPSIZN +
             ) +
        NOWRITE REPLACE

EVALSYM GDA
IF &LASTCC = 12 THEN DO
 EQ GDA CVT+230?
END
EVAL GDA+88 LE(4) UNS CLIST(S(GDASPT))
IF &LASTCC = 12 | &GDASPT = 0 THEN DO
 NOTE 'Error: No valid GDASPT pointer.' ASIS
 EXIT C(12) Q
END

DO &SP = 0 TO 3
 DO &PK = 0 TO 15
  SET N = &GDASPT+4+(24*&PK+384*&SP)
  INTEGER &EVAL(&N+0)  PTR(8) CLIST(S(P0))
  INTEGER &EVAL(&N+4)  PTR(8) CLIST(S(P4))
  INTEGER &EVAL(&N+8)  PTR(8) CLIST(S(P8))
  INTEGER &EVAL(&N+12) PTR(8) CLIST(S(P12))
  INTEGER &EVAL(&N+16) PTR(8) CLIST(S(P16))
  INTEGER &EVAL(&N+20) PTR(8) CLIST(S(P20))
  SET SPTADDR = &STR(&P0)
  SELECT &SP
   WHEN (0) SET CMAPSPID = 227
   WHEN (1) SET CMAPSPID = 228
   WHEN (2) SET CMAPSPID = 231
   WHEN (3) SET CMAPSPID = 241
  END
  SET CMAPKEY = &PK
  EVAL &P0   LE(4) UNS CLIST(S(NSPTFBDQE))
  EVAL &P4   LE(4) UNS CLIST(S(NSPTLBDQE))
  EVAL &P8   LE(4) UNS CLIST(S(NSPTFADQE))
  EVAL &P12  LE(4) UNS CLIST(S(NSPTLADQE))
  EVAL &P16  LE(4) UNS CLIST(S(NSPTFEDQE))
  EVAL &P20  LE(4) UNS CLIST(S(NSPTLEDQE))
  INTEGER &NSPTFBDQE PTR(8) CLIST(S(SPTFBDQE))
  INTEGER &NSPTLBDQE PTR(8) CLIST(S(SPTLBDQE))
  INTEGER &NSPTFADQE PTR(8) CLIST(S(SPTFADQE))
  INTEGER &NSPTLADQE PTR(8) CLIST(S(SPTLADQE))
  INTEGER &NSPTFEDQE PTR(8) CLIST(S(SPTFEDQE))
  INTEGER &NSPTLEDQE PTR(8) CLIST(S(SPTLEDQE))

  IF &NSPTFBDQE ^= &N+0  | &NSPTLBDQE ^= &N+0  THEN DO
   SYSCALL PROCESS_DQE BELOW &P0  00  &XTRACE
  END
  IF &NSPTFADQE ^= &N+8  | &NSPTLADQE ^= &N+8  THEN DO
   SYSCALL PROCESS_DQE ANY   &P0  08  &XTRACE
  END
  IF &NSPTFEDQE ^= &N+16 | &NSPTLBDQE ^= &N+16 THEN DO
   SYSCALL PROCESS_DQE ABOVE &P0  10  &XTRACE
  END
 END
END

%IPTBDISP CMAP &XTRACE

EXIT C(0)


PROCESS_DQE: PROC 3 DQETYPE P OFFSET

 SET LOCATIVE =
 SYSCALL ADDRESSIFY LOCATIVE &P..+&OFFSET

 EVAL &LOCATIVE..+0 LE(4) PTR CLIST(S(DQEADDR))
 EVAL &LOCATIVE..+4 LE(4) PTR CLIST(S(DQELADDR))

 DO UNTIL &STR(&DQEADDR) = &STR(&DQELADDR) +
     WHILE &STR(&DQEADDR) ^= &STR(&LOCATIVE)
  EVAL &DQEADDR..+00 LE(4) PTR    CLIST(S(DQENEXT))
  EVAL &DQEADDR..+04 LE(4) PTR    CLIST(S(DQEPREV))
  EVAL &DQEADDR..+08 LE(4) PTR    CLIST(S(DQEFFQE))
  EVAL &DQEADDR..+0C LE(4) PTR    CLIST(S(DQELFQE))
  EVAL &DQEADDR..+10 LE(4) SIGNED CLIST(S(DQEAREA))
  EVAL &DQEADDR..+14 LE(4) SIGNED CLIST(S(DQESIZE))

/**********************************************************************/
/* Set table variables from DQE info.                                 */
/**********************************************************************/

  SET CMAPLOC  = &STR(&DQETYPE)

/**********************************************************************/
/* For each DQE, process all FQE's                                    */
/**********************************************************************/

  SYSCALL PROCESS_FQE &DQEADDR &DQEAREA &DQESIZE &DQEFFQE &DQELFQE

/**********************************************************************/
/* Chain to next DQE.                                                 */
/**********************************************************************/

  SET DQEADDR = &STR(&DQENEXT)

 END

END PROCESS_DQE


PROCESS_FQE: PROC 5 DQEADDR DQEAREA DQESIZE DQEFFQE DQELFQE

/**********************************************************************/
/* If there are no FQE's, the entire area defined by this DQE is      */
/* allocated.  Add it to the table as a single entry (e.g. 4K block). */
/**********************************************************************/

 IF &STR(&DQEFFQE) = &STR(&DQEADDR) THEN DO
  SET CMAPARNA = &DQEAREA
  SET CMAPSIZN = &DQESIZE
  SYSCALL TBADD
 END

 ELSE DO
  SET ALLOCAREA = &DQEAREA
  SET ALLOCEND = &DQEAREA + &DQESIZE
  SET FQEADDR = &STR(&DQEFFQE)
  DO UNTIL &STR(&A)        = &STR(&DQELFQE) +
     WHILE &STR(&FQEADDR) ^= &STR(&DQEADDR)
   EVAL &FQEADDR..+00 LE(4) SIGNED CLIST(S(FQEAREA))
   EVAL &FQEADDR..+04 LE(4) SIGNED CLIST(S(FQESIZE))
   EVAL &FQEADDR..+08 LE(4) PTR    CLIST(S(FQENEXT))

/**********************************************************************/
/* Since the FQE's map chunks of free storage, interpolate where the  */
/* allocated storage is and create table entries for the allocated    */
/* storage, not the free storage.                                     */
/**********************************************************************/

   SET CMAPSIZN = &FQEAREA - &ALLOCAREA
   IF &CMAPSIZN ^= 0 THEN DO
    SET CMAPARNA = &ALLOCAREA
    SYSCALL TBADD
   END

   SET ALLOCAREA = &FQEAREA + &FQESIZE

/**********************************************************************/
/* Chain to next FQE.                                                 */
/**********************************************************************/

   SET A = &STR(&FQEADDR)
   SET FQEADDR = &STR(&FQENEXT)
  END

/**********************************************************************/
/* Check last possible unfreed chunk.                                 */
/**********************************************************************/

  SET CMAPSIZN = &ALLOCEND - &ALLOCAREA
  IF &CMAPSIZN ^= 0 THEN DO
   SET CMAPARNA = &ALLOCAREA
   SYSCALL TBADD
  END

 END

END PROCESS_FQE

TBADD: PROC 0
 SET CMAPARNE = &CMAPARNA + &CMAPSIZN
 INTEGER &CMAPARNA PTR(8) CLIST(S(CMAPAREA))
 INTEGER &CMAPARNE PTR(8) CLIST(S(CMAPAREE))
 INTEGER &CMAPSIZN PTR    CLIST(S(CMAPSIZE))

 WRITE +
       &CMAPTYPE &CMAPSPID &CMAPKEY +
       &CMAPLOC &CMAPAREA &CMAPAREE &CMAPSIZE

 ISPEXEC TBADD CMAPTBL
 RETURN
END

ADDRESSIFY: PROC 2 NEWADDRESS OLDADDRESS
 SYSREF NEWADDRESS
 TCBEXIT YITADDR &NRSTR(&OLDADDRESS) POSITION(+0)
 IF &LASTCC ^= 0 THEN DO
  NOTE 'Invalid address: &NRSTR(&OLDADDRESS)' ASIS
  EXIT C(16) Q
 END
 SET NEWADDRESS = &STR(&YITHEX)
 RETURN
END ADDRESSIFY

./ ADD NAME=IPVSCSA
PROC 1 TCBADDR XTRACE
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
EVALSYM GDA
IF &LASTCC = 12 THEN DO
 EQ GDA CVT+230?
END
EVAL GDA+88 LE(4) UNS CLIST(S(GDASPT))
IF &LASTCC = 12 | &GDASPT = 0 THEN DO
 NOTE 'Error: No valid GDASPT pointer.' ASIS
 EXIT C(12) Q
END

ISPEXEC TBCREATE SPTTBL +
        KEYS() +
        NAMES(SPTSEL SPTADDR SPTSP SPTPK +
              SPTFBDQE SPTLBDQE +
              SPTFADQE SPTLADQE +
              SPTFEDQE SPTLEDQE +
             ) +
        NOWRITE REPLACE

DO &SP = 0 TO 3
 DO &PK = 0 TO 15
  /* SET TOTALOFF = 24*&SP + 96*&PK
  SET TOTALOFF = 24*&PK + 384*&SP
  SET N = &GDASPT+4+&TOTALOFF
  INTEGER &EVAL(&N+0)  PTR(8) CLIST(S(P0))
  INTEGER &EVAL(&N+4)  PTR(8) CLIST(S(P4))
  INTEGER &EVAL(&N+8)  PTR(8) CLIST(S(P8))
  INTEGER &EVAL(&N+12) PTR(8) CLIST(S(P12))
  INTEGER &EVAL(&N+16) PTR(8) CLIST(S(P16))
  INTEGER &EVAL(&N+20) PTR(8) CLIST(S(P20))
  SET SPTSEL =
  SET SPTADDR = &STR(&P0)
  SELECT &SP
   WHEN (0) SET SPTSP = 227
   WHEN (1) SET SPTSP = 228
   WHEN (2) SET SPTSP = 231
   WHEN (3) SET SPTSP = 241
  END
  SET SPTPK = &PK
  EVAL &P0   LE(4) UNS CLIST(S(NSPTFBDQE))
  EVAL &P4   LE(4) UNS CLIST(S(NSPTLBDQE))
  EVAL &P8   LE(4) UNS CLIST(S(NSPTFADQE))
  EVAL &P12  LE(4) UNS CLIST(S(NSPTLADQE))
  EVAL &P16  LE(4) UNS CLIST(S(NSPTFEDQE))
  EVAL &P20  LE(4) UNS CLIST(S(NSPTLEDQE))
  INTEGER &NSPTFBDQE PTR(8) CLIST(S(SPTFBDQE))
  INTEGER &NSPTLBDQE PTR(8) CLIST(S(SPTLBDQE))
  INTEGER &NSPTFADQE PTR(8) CLIST(S(SPTFADQE))
  INTEGER &NSPTLADQE PTR(8) CLIST(S(SPTLADQE))
  INTEGER &NSPTFEDQE PTR(8) CLIST(S(SPTFEDQE))
  INTEGER &NSPTLEDQE PTR(8) CLIST(S(SPTLEDQE))

  SET MISSING = 0
  IF &NSPTFBDQE = &N+0 && &NSPTLBDQE = &N+0 THEN DO
   SET SPTFBDQE =
   SET SPTLBDQE =
   SET MISSING = &MISSING+1
  END
  IF &NSPTFADQE = &N+8 && &NSPTLADQE = &N+8 THEN DO
   SET SPTFADQE =
   SET SPTLADQE =
   SET MISSING = &MISSING+1
  END
  IF &NSPTFEDQE = &N+16 && &NSPTLEDQE = &N+16 THEN DO
   SET SPTFEDQE =
   SET SPTLEDQE =
   SET MISSING = &MISSING+1
  END

  IF &MISSING < 3 THEN DO
   ISPEXEC TBADD SPTTBL
  END
 END
END

TCBX YITADDR GDA POS(+0)
%IPTBDISP SPT ADDRESS(&YITHEX)

EXIT

./ ADD NAME=IPVSDQE
PROC 0 THING() POINTER() ADDRESS() EXTRA() XTRACE
IF &XTRACE = XTRACE THEN CONTROL SYMLIST CONLIST LIST
CONTROL NOCAPS

SET POINTER = &STR(&&&POINTER)
SET ADDRESS = &STR(&&&ADDRESS)
IF &STR(&EXTRA) ^= THEN DO
 SET SYSDVAL = &NRSTR(&EXTRA)
 READDVAL X1 X2
 SET AMP = &&
 SET EXTRA = &NRSTR(,&X1 at &AMP.&X2)
END

/**********************************************************************/
/* Get the variables from the current table row.                      */
/**********************************************************************/

ISPEXEC TBGET &THING.TBL

/**********************************************************************/
/* Create a table to hold the DQE entries.                            */
/**********************************************************************/

ISPEXEC TBCREATE DQETBL +
        KEYS() +
        NAMES(DQESEL DQETYPE DQEADDR +
              DQEFFQE DQELFQE DQEAREA DQESIZE +
             ) +
        NOWRITE REPLACE

/**********************************************************************/
/* Access information from SPQA or SPT.  We retrieve info from the    */
/* DFE's chained thereoff, and create a table of DQE's.               */
/*                                                                    */
/* There are 3 queues of DQE's.                                       */
/*                                                                    */
/* (In the following, "Thing" is SPSA (for private) or SPT (for CSA). */
/*                                                                    */
/* Thing + 00 ==> first DQE for storage backed below 16M              */
/* Thing + 04 ==> last  DQE for storage backed below 16M              */
/* Thing + 08 ==> first DQE for storage backed anywhere               */
/* Thing + 0C ==> last  DQE for storage backed anywhere               */
/* Thing + 10 ==> first DQE for storage backed above 16M (????)       */
/* Thing + 14 ==> last  DQE for storage backed above 16M (????)       */
/*                                                                    */
/**********************************************************************/

/**********************************************************************/
/* For each DQE queue, process all DQE's.                             */
/**********************************************************************/

SYSCALL PROCESS_DQE BELOW &POINTER 00
SYSCALL PROCESS_DQE ANY   &POINTER 08
SYSCALL PROCESS_DQE ABOVE &POINTER 10

/******************************************************************/
/* Display the table of DQE's                                     */
/******************************************************************/

%IPTBDISP DQE THING(&THING) ADDRESS(&ADDRESS) EXTRA('&EXTRA')

EXIT

PROCESS_DQE: PROC 3 DQETYPE P OFFSET

 TCBEXIT YITADDR &P..+&OFFSET+0 POS(+0)
 SET LOCATIVE = &STR(&YITHEX)
 EVAL &LOCATIVE..+0 LE(4) PTR CLIST(S(DQEADDR))
 EVAL &LOCATIVE..+4 LE(4) PTR CLIST(S(DQELADDR))

 DO UNTIL &STR(&DQEADDR) = &STR(&DQELADDR) +
     WHILE &STR(&DQEADDR) ^= &STR(&LOCATIVE)
  SET A = &STR(&DQEADDR)
  SET T = &STR(&DQETYPE)
  ISPEXEC TBVCLEAR DQETBL
  SET DQEADDR = &STR(&A)
  SET DQETYPE = &STR(&T)
  EVAL &DQEADDR..+00 LE(4) PTR DIALOG(S(DQENEXT))
  EVAL &DQEADDR..+04 LE(4) PTR DIALOG(S(DQEPREV))
  EVAL &DQEADDR..+08 LE(4) PTR DIALOG(S(DQEFFQE))
  EVAL &DQEADDR..+0C LE(4) PTR DIALOG(S(DQELFQE))
  EVAL &DQEADDR..+10 LE(4) PTR DIALOG(S(DQEAREA))
  EVAL &DQEADDR..+14 LE(4) HEX DIALOG(S(DQESIZE))

/**********************************************************************/
/* Add DQE info to the table.                                         */
/**********************************************************************/

  IF &DQEFFQE = &DQELFQE && &DQEFFQE = &DQEADDR THEN DO
   SET DQEFFQE =
   SET DQELFQE =
  END

  ISPEXEC TBADD DQETBL

/**********************************************************************/
/* Chain to next DQE.                                                 */
/**********************************************************************/

  SET DQEADDR = &STR(&DQENEXT)

 END

END PROCESS_DQE
./ ADD NAME=IPVSFQE

/**********************************************************************/
/*                                                                    */
/* This CLIST is invoked by IPVVDQE.  Table DQETBL must be open.      */
/*                                                                    */
/* Reference: MVS/XA SLL: Virtual Storage Management, Part I          */
/*            LY28-1790-0                                             */
/*                                                                    */
/**********************************************************************/

PROC 0 XTRACE
IF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST

/**********************************************************************/
/* Get the variables from the current table row.                      */
/**********************************************************************/

ISPEXEC TBGET DQETBL
IF &STR(&DQEFFQE) = THEN DO
 ISPEXEC SETMSG MSG(IPZ005)
 EXIT
END

/**********************************************************************/
/* Access information from FQE's.
/**********************************************************************/

ISPEXEC TBCREATE FQETBL +
        KEYS() +
        NAMES(FQESEL FQEADDR +
              FQEAREA FQESIZE +
              EFQEAREA +
             ) +
        NOWRITE REPLACE

/**********************************************************************/
/* For each DQE queue, process all FQE's                              */
/**********************************************************************/

IF &STR(&DQEFFQE) = &STR(&DQEADDR) THEN DO
 GOTO DISP
END

SET FQEADDR = &STR(&DQEFFQE)
DO UNTIL &STR(&A)        = &STR(&DQELFQE) +
   WHILE &STR(&FQEADDR) ^= &STR(&DQEADDR)
 INTEGER X'&FQEADDR' PTR DIALOG(S(FQEADDR))
 SET A = &STR(&FQEADDR)
 ISPEXEC TBVCLEAR FQETBL
 SET FQEADDR = &STR(&A)
 EVAL &FQEADDR..+00 LE(4) PTR CLIST(S(FQEAREA))
 EVAL &FQEADDR..+04 LE(4) HEX CLIST(S(FQESIZE))
 EVAL &FQEADDR..+08 LE(4) PTR CLIST(S(FQENEXT))

 TCBEXIT YITADDR &FQEAREA..+&FQESIZE POS(+0)
 SET EFQEAREA = &SUBSTR(1:8,&YITHEX        )

 ISPEXEC TBADD FQETBL

/**********************************************************************/
/* Chain to next FQE.                                                 */
/**********************************************************************/

 SET A = &STR(&FQEADDR)
 SET FQEADDR = &STR(&FQENEXT)

END

/******************************************************************/
/* Display the table of DE's                                      */
/******************************************************************/

DISP:+
%IPTBDISP FQE ADDRESS(&DQEADDR) &XTRACE
   SET SELCMD = &STR(%DUMPCB AREA &FQEAREA.. X'&FQESIZE')

./ ADD NAME=IPVSLSQA
PROC 1 TCBADDR XTRACE
/**********************************************************************/
/* This subprocedure analyzes local system queue area virtual storage.*/
/**********************************************************************/

NGLOBAL ASCBLDA
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS

/**********************************************************************/
/* LSQA areas are accessed as follows:                                */
/* ASCB -> LDA -> AQAT,SQAT                                           */
/* TCB -> AE                                                          */
/**********************************************************************/

EVAL 224.?+30 L(4) PTR CLIST(S(ASCBLDA))
IF &LASTCC=12 THEN DO
 NOTE 'IPVSM: Error accessing ASCBLDA at 224.?+30' ASIS
 EXIT C(16) Q
END

/******************************************************************/
/* Create table of DFE's for this LDA                             */
/******************************************************************/

ISPEXEC TBCREATE DFETBL +
        KEYS() +
        NAMES(DFESEL DFEADDR DFETYPE DFESPID +
              DFEANEXT DFEAPREV DFESNEXT DFESPREV DFEAREA DFESIZE +
              DFEAREAN DFESIZEN +
             ) +
        NOWRITE REPLACE

/******************************************************************/
/* Extract pointers from the LDA                                  */
/******************************************************************/

EVAL &ASCBLDA..+04 L(4) PTR CLIST(S(LDASQAT))
EVAL &ASCBLDA..+08 L(4) PTR CLIST(S(LDAAQAT))
EVAL &ASCBLDA..+1C L(4) PTR CLIST(S(LDAESQAT))
EVAL &ASCBLDA..+20 L(4) PTR CLIST(S(LDAEAQAT))
EVAL &ASCBLDA..+0C L(4) PTR CLIST(S(LDAADF))   /* -> first  DFE
EVAL &ASCBLDA..+10 L(4) PTR CLIST(S(LDAADL))   /* -> last   DFE
EVAL &ASCBLDA..+24 L(4) PTR CLIST(S(LDAEADF))  /* -> first EDFE
EVAL &ASCBLDA..+28 L(4) PTR CLIST(S(LDAEADL))  /* -> last  EDFE
EVAL &ASCBLDA..+34 L(4) PTR CLIST(S(LDAFBQAF)) /* -> first  FBQE
EVAL &ASCBLDA..+38 L(4) PTR CLIST(S(LDAFBQAL)) /* -> last   FBQE
EVAL &ASCBLDA..+44 L(4) PTR CLIST(S(LDAEBQAF)) /* -> first EFBQE
EVAL &ASCBLDA..+48 L(4) PTR CLIST(S(LDAEBQAL)) /* -> last  EFBQE

/**********************************************************************/
/* Process all the DFE's                                              */
/**********************************************************************/

SYSCALL PROCESS_DFE &LDAADF &LDAADL &XTRACE
SYSCALL PROCESS_DFE &LDAEADF &LDAEADL EXTENDED &XTRACE

%IPTBDISP DFE THING(LDA) ADDR(&ASCBLDA)

EXIT


PROCESS_DFE: PROC 2 FIRSTDFE LASTDFE EXTENDED XTRACE
 SET DFEADDR = &STR(&FIRSTDFE)
 DO UNTIL &STR(&A)        = &STR(&FIRSTDFE) +

  INTEGER X'&DFEADDR' PTR DIALOG(S(DFEADDR))
  SET A = &STR(&DFEADDR)
  ISPEXEC TBVCLEAR DFETBL
  SET DFEADDR = &STR(&A)
  EVAL &DFEADDR..+00 LE(4) PTR DIALOG(S(DFEANEXT))
  EVAL &DFEADDR..+04 LE(4) PTR DIALOG(S(DFEAPREV))
  EVAL &DFEADDR..+08 LE(4) PTR DIALOG(S(DFESNEXT))
  EVAL &DFEADDR..+0C LE(4) PTR DIALOG(S(DFESPREV))
  EVAL &DFEADDR..+10 LE(4) PTR DIALOG(S(DFEAREA))
  EVAL &DFEADDR..+14 LE(4) PTR DIALOG(S(DFESIZE))
  EVAL &DFEADDR..+10 LE(4) SIG DIALOG(S(DFEAREAN))
  EVAL &DFEADDR..+14 LE(4) SIG DIALOG(S(DFESIZEN))

/**********************************************************************/
/* Add DFE info to the table.                                         */
/**********************************************************************/

  IF &DFEAREAN = 0 && &DFESIZEN = 0 THEN SET DFETYPE = DUMMY
  ELSE SET DFETYPE =
  SET DFESPID = &STR(   )
  IF &EXTENDED = EXTENDED THEN SET DFETYPE = E&DFETYPE
  ISPEXEC TBADD DFETBL

/**********************************************************************/
/* Chain to next DFE.                                                 */
/**********************************************************************/

  SET DFEADDR = &STR(&DFEANEXT)
  SET A       = &STR(&DFEADDR)
 END

END PROCESS_DFE

./ ADD NAME=IPVSPMAP

/**********************************************************************/
/*                                                                    */
/* This CLIST produces a table displaying allocated virtual storage.  */
/*                                                                    */
/* Reference: MVS/XA SLL: Virtual Storage Management, Part I          */
/*            LY28-1790-0                                             */
/*                                                                    */
/**********************************************************************/

PROC 1 TCBADDRESS SUBPOOLLIST() LINEMODEVALUE XTRACEVALUE
NGLOBAL TCBADDR SUBPOOLS XTRACE LINEMODE +
        ZERRSM ZERRLM ZERRMSG ZERRHM ZERRALRM +
        PMAPSEL PMAPTYPE PMAPTCB PMAPSPID PMAPKEY PMAPSHR PMAPLOC +
        PMAPAREA PMAPAREE PMAPSIZE +
        PMAPARNA PMAPARNE PMAPSIZN

IF &XTRACEVALUE ^= THEN DO
 CONTROL LIST CONLIST SYMLIST
 SET XTRACE = XTRACE
END
ELSE SET XTRACE =
CONTROL NOCAPS
SET LINEMODE = &STR(&LINEMODEVALUE)
SET TCBADDR  = &STR(&TCBADDRESS..)
SET SUBPOOLS = &STR(&SUBPOOLLIST)

IF &LINEMODE ^= THEN DO
 NOTE SPACE(1)
 NOTE '--- IPCS Virtual Storage Map for TCB at &TCBADDRESS.. ---' ASIS
 NOTE SPACE(1)
 NOTE 'Type  Owner TCB  Subpool Key Shared  Location  +
       From      To        Size' ASIS
 NOTE SPACE(1)
END

/**********************************************************************/
/* Access subpools by SPQE.  There are 3 pointers to SPQE's in TCB:   */
/*                                                                    */
/* TCBSWA    -> SPQE chain for subpools 236 & 237 (SWA)               */
/* TCBUKYSP  -> SPQE chain for subpools 229 & 230 (auth. user keys)   */
/* TCBMSS    -> SPQE chain for other subpools (user)                  */
/*                                                                    */
/**********************************************************************/

EVAL &TCBADDR+18 L(4) PTR CLIST(S(TCBMSS))
IF &LASTCC=12 THEN DO
 NOTE 'PMAP: Error accessing TCBMSS at &TCBADDR+18' ASIS
 EXIT C(16) Q
END

EVAL &TCBADDR+F8 L(4) PTR CLIST(S(TCBSWA))
IF &LASTCC=12 THEN DO
 NOTE 'PMAP: Error accessing TCBSWA at &TCBADDR+F8' ASIS
 EXIT C(16) Q
END

EVAL &TCBADDR+10C L(4) PTR CLIST(S(TCBUKYSP))
IF &LASTCC=12 THEN DO
 NOTE 'PMAP: Error accessing TCBUKYSP at &TCBADDR+10C' ASIS
 EXIT C(16) Q
END

/******************************************************************/
/* Create table to contain all virtual storage info               */
/******************************************************************/

IF &LINEMODE = THEN +
 ISPEXEC TBCREATE PMAPTBL +
         KEYS() +
         NAMES(PMAPSEL +
               PMAPTYPE PMAPTCB PMAPSPID PMAPKEY PMAPSHR PMAPLOC +
               PMAPAREA PMAPAREE PMAPSIZE +
               PMAPARNA PMAPARNE PMAPSIZN +
              ) +
         NOWRITE REPLACE

/**********************************************************************/
/* For each SPQE queue, process all SPQE's                            */
/**********************************************************************/

SYSCALL PROCESS_SPQE USR &TCBMSS
SYSCALL PROCESS_SPQE AUK &TCBUKYSP
SYSCALL PROCESS_SPQE SWA &TCBSWA

IF &LINEMODE = THEN +
 %IPTBDISP PMAP ADDRESS(&TCBADDR) &XTRACE

EXIT C(0)

PROCESS_SPQE: PROC 2 PTYPE PADDR

 SET SPQEADDR = &STR(&PADDR)

 DO WHILE &SPQEADDR ^= 0
  EVAL &SPQEADDR..+11 LE(1) UNS DIALOG(S(SPQEID))
  IF &STR(&SUBPOOLS) ^= THEN DO
   SELECT &SPQEID
    WHEN (&SUBPOOLS)
    OTHERWISE GOTO SKIPSP
   END
  END
  INTEGER X'&SPQEADDR' PTR DIALOG(S(SPQEADDR))
  EVAL &SPQEADDR..+08 LE(4) PTR DIALOG(S(SPQESPQA))
  EVAL &SPQEADDR..+0C LE(4) PTR DIALOG(S(SPQETCB))
  EVAL &SPQEADDR..+12 LE(1) UNS CLIST(S(KEYTIMES16))
  SET SPQEKEY = &KEYTIMES16 / 16
  COMPARE ADDR(&SPQEADDR..+13) WITH(VALUE(X'80')) LE(1) MASK(X'80')
  IF &LASTCC = 0 THEN SET SPQESHR = YES
  ELSE SET SPQESHR = NO

/**********************************************************************/
/* Set table variables from SPQE info.                                */
/**********************************************************************/

  SET PMAPSEL  =
  SET PMAPTYPE = &STR(&PTYPE)
  SET PMAPTCB  = &STR(&SPQETCB)
  SET PMAPSPID = &STR(&SPQEID)
  SET PMAPKEY  = &STR(&SPQEKEY)
  SET PMAPSHR  = &STR(&SPQESHR)

/**********************************************************************/
/* Process info from SPQA and DQE queue for this SPQE.                */
/**********************************************************************/

/**********************************************************************/
/* Access information from SPQA.  We retrieve information from the    */
/* DFE's chained thereoff, and create a table of DQE's.               */
/*                                                                    */
/* There are 3 queues of DQE's.                                       */
/*                                                                    */
/* SPQA + 00  ==> first DQE for storage backed below 16M              */
/* SPQA + 04  ==> last  DQE for storage backed below 16M              */
/* SPQA + 08  ==> first DQE for storage backed anywhere               */
/* SPQA + 0C  ==> last  DQE for storage backed anywhere               */
/* SPQA + 10  ==> first DQE for storage backed above 16M (????)       */
/* SPQA + 14  ==> last  DQE for storage backed above 16M (????)       */
/*                                                                    */
/**********************************************************************/

/**********************************************************************/
/* For each DQE queue, process all DQE's                              */
/**********************************************************************/

  SYSCALL PROCESS_DQE BELOW &SPQESPQA 00
  SYSCALL PROCESS_DQE ANY   &SPQESPQA 08
  SYSCALL PROCESS_DQE ABOVE &SPQESPQA 10



/**********************************************************************/
/* Chain to next SPQE.                                                */
/**********************************************************************/

  SKIPSP:+
  EVAL &SPQEADDR..+00 LE(4) PTR CLIST(S(SPQEADDR))
  IF &LASTCC=12 THEN DO
   NOTE '==> Error: Next SPQE not available from &SPQEADDR' ASIS
   EXIT C(4)
  END

 END

END PROCESS_SPQE

PROCESS_DQE: PROC 3 DQETYPE SPQESPQA OFFSET

 SET LOCATIVE =
 SYSCALL ADDRESSIFY LOCATIVE &SPQESPQA..+&OFFSET

 EVAL &LOCATIVE..+0 LE(4) PTR CLIST(S(DQEADDR))
 EVAL &LOCATIVE..+4 LE(4) PTR CLIST(S(DQELADDR))

 DO UNTIL &STR(&DQEADDR) = &STR(&DQELADDR) +
     WHILE &STR(&DQEADDR) ^= &STR(&LOCATIVE)
  INTEGER X'&DQEADDR' PTR CLIST(S(DQEADDR))
  EVAL &DQEADDR..+00 LE(4) PTR    CLIST(S(DQENEXT))
  EVAL &DQEADDR..+04 LE(4) PTR    CLIST(S(DQEPREV))
  EVAL &DQEADDR..+08 LE(4) PTR    CLIST(S(DQEFFQE))
  EVAL &DQEADDR..+0C LE(4) PTR    CLIST(S(DQELFQE))
  EVAL &DQEADDR..+10 LE(4) SIGNED CLIST(S(DQEAREA))
  EVAL &DQEADDR..+14 LE(4) SIGNED CLIST(S(DQESIZE))

/**********************************************************************/
/* Set table variables from DQE info.                                 */
/**********************************************************************/

  SET PMAPLOC  = &STR(&DQETYPE)

/**********************************************************************/
/* For each DQE, process all FQE's                                    */
/**********************************************************************/

  SYSCALL PROCESS_FQE &DQEADDR &DQEAREA &DQESIZE &DQEFFQE &DQELFQE

/**********************************************************************/
/* Chain to next DQE.                                                 */
/**********************************************************************/

  SET DQEADDR = &STR(&DQENEXT)

 END

END PROCESS_DQE


PROCESS_FQE: PROC 5 DQEADDR DQEAREA DQESIZE DQEFFQE DQELFQE

/**********************************************************************/
/* If there are no FQE's, the entire area defined by this DQE is      */
/* allocated.  Add it to the table as a single entry (e.g. 4K block). */
/**********************************************************************/

 IF &STR(&DQEFFQE) = &STR(&DQEADDR) THEN DO
  SET PMAPARNA = &DQEAREA
  SET PMAPSIZN = &DQESIZE
  SYSCALL TBADD
 END

 ELSE DO
  SET ALLOCAREA = &DQEAREA
  SET ALLOCEND = &DQEAREA + &DQESIZE
  SET FQEADDR = &STR(&DQEFFQE)
  DO UNTIL &STR(&A)        = &STR(&DQELFQE) +
     WHILE &STR(&FQEADDR) ^= &STR(&DQEADDR)
   INTEGER X'&FQEADDR' PTR DIALOG(S(FQEADDR))
   EVAL &FQEADDR..+00 LE(4) SIGNED CLIST(S(FQEAREA))
   EVAL &FQEADDR..+04 LE(4) SIGNED CLIST(S(FQESIZE))
   EVAL &FQEADDR..+08 LE(4) PTR    CLIST(S(FQENEXT))

   IF &FQESIZE > 16777215 THEN DO
    WRITE DQEADDR = &DQEADDR
    WRITE FQEADDR = &FQEADDR
    EVAL &FQEADDR..+00 LE(4) PTR    CLIST(S(FQEAREAP))
    WRITE +0 FQEAREA = &FQEAREAP
    EVAL &FQEADDR..+04 LE(4) PTR    CLIST(S(FQESIZEP))
    WRITE +4 FQESIZE = &FQESIZEP
    WRITE +8 FQENEXT = &FQENEXT
   END

/**********************************************************************/
/* Since the FQE's map chunks of free storage, interpolate where the  */
/* allocated storage is and create table entries for the allocated    */
/* storage, not the free storage.                                     */
/**********************************************************************/

   SET PMAPSIZN = &FQEAREA - &ALLOCAREA
   IF &PMAPSIZN ^= 0 THEN DO
    SET PMAPARNA = &ALLOCAREA
    SYSCALL TBADD
   END

   SET ALLOCAREA = &FQEAREA + &FQESIZE

/**********************************************************************/
/* Chain to next FQE.                                                 */
/**********************************************************************/

   SET A = &STR(&FQEADDR)
   SET FQEADDR = &STR(&FQENEXT)
  END

/**********************************************************************/
/* Check last possible unfreed chunk.                                 */
/**********************************************************************/

  SET PMAPSIZN = &ALLOCEND - &ALLOCAREA
  IF &PMAPSIZN ^= 0 THEN DO
   SET PMAPARNA = &ALLOCAREA
   SYSCALL TBADD
  END

 END

END PROCESS_FQE

TBADD: PROC 0
 SET PMAPARNE = &PMAPARNA + &PMAPSIZN
 INTEGER &PMAPARNA PTR(8) CLIST(S(PMAPAREA))
 INTEGER &PMAPARNE PTR(8) CLIST(S(PMAPAREE))
 INTEGER &PMAPSIZN PTR    CLIST(S(PMAPSIZE))
 IF &LENGTH(&STR(&PMAPTCB)) = 8 && +
    &SUBSTR(1:2,&PMAPTCB) = &STR(00) THEN DO
  SET PMAPTCB = &SUBSTR(3:8,&PMAPTCB)
 END
 IF &LINEMODE ^= THEN +
  NOTE ' &PMAPTYPE   &PMAPTCB      &PMAPSPID    &PMAPKEY   +
        &PMAPSHR      &PMAPLOC   &PMAPAREA  &PMAPAREE   &PMAPSIZE +
       ' ASIS
 ELSE +
  ISPEXEC TBADD PMAPTBL
 RETURN
END

ADDRESSIFY: PROC 2 NEWADDRESS OLDADDRESS
 SYSREF NEWADDRESS
 TCBEXIT YITADDR &NRSTR(&OLDADDRESS) POSITION(+0)
 IF &LASTCC ^= 0 THEN DO
  NOTE 'Invalid address: &NRSTR(&OLDADDRESS)' ASIS
  EXIT C(16) Q
 END
 SET NEWADDRESS = &STR(&YITHEX)
 RETURN
END ADDRESSIFY

./ ADD NAME=IPVSPVT

PROC 1 TCBADDR XTRACE

/**********************************************************************/
/* This procedure analyzes private area virtual storage.              */
/**********************************************************************/

IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
SET TCBADDR = &STR(&TCBADDR..)

/**********************************************************************/
/* Access subpools by SPQE.  There are 3 pointers to SPQE's in TCB:   */
/*                                                                    */
/* TCBSWA    -> SPQE chain for subpools 236 & 237 (SWA)               */
/* TCBUKYSP  -> SPQE chain for subpools 229 & 230 (auth. user keys)   */
/* TCBMSS    -> SPQE chain for other subpools (user)                  */
/*                                                                    */
/**********************************************************************/

EVAL &TCBADDR+18 L(4) PTR CLIST(S(TCBMSS))
IF &LASTCC=12 THEN DO
 NOTE 'IPVSM: Error accessing TCBMSS at &TCBADDR+18' ASIS
 EXIT C(16) Q
END

EVAL &TCBADDR+F8 L(4) PTR CLIST(S(TCBSWA))
IF &LASTCC=12 THEN DO
 NOTE 'IPVSM: Error accessing TCBSWA at &TCBADDR+F8' ASIS
 EXIT C(16) Q
END

EVAL &TCBADDR+10C L(4) PTR CLIST(S(TCBUKYSP))
IF &LASTCC=12 THEN DO
 NOTE 'IPVSM: Error accessing TCBUKYSP at &TCBADDR+10C' ASIS
 EXIT C(16) Q
END

/******************************************************************/
/* Create table to contain subpool ID's for this TCB              */
/******************************************************************/

ISPEXEC TBCREATE SPQETBL +
        KEYS() +
        NAMES(SPQESEL SPQEQTYP SPQEADDR +
              SPQESPQA SPQETCB SPQEID SPQEKEY SPQESHR +
             ) +
        NOWRITE REPLACE

/**********************************************************************/
/* For each SPQE queue, process all SPQE's                            */
/**********************************************************************/

SYSCALL PROCESS_SPQE MSS &TCBMSS    &XTRACE
SYSCALL PROCESS_SPQE SWA &TCBSWA    &XTRACE
SYSCALL PROCESS_SPQE AUK &TCBUKYSP  &XTRACE

/******************************************************************/
/* Display the table of SPQE's                                   */
/******************************************************************/

%IPTBDISP SPQE ADDRESS(&TCBADDR)

EXIT


PROCESS_SPQE: PROC 2 SPQEQTYP SPQEADDR XTRACE

 DO WHILE &SPQEADDR ^= 0
  INTEGER X'&SPQEADDR' PTR DIALOG(S(SPQEADDR))
  SET A = &STR(&SPQEADDR)
  SET Q = &STR(&SPQEQTYP)
  ISPEXEC TBVCLEAR SPQETBL
  SET SPQEADDR = &STR(&A)
  SET SPQEQTYP = &STR(&Q)
  EVAL &SPQEADDR..+08 LE(4) PTR DIALOG(S(SPQESPQA))
  EVAL &SPQEADDR..+0C LE(4) PTR DIALOG(S(SPQETCB))
  EVAL &SPQEADDR..+11 LE(1) UNS DIALOG(S(SPQEID))
  EVAL &SPQEADDR..+12 LE(1) UNS CLIST(S(KEYTIMES16))
  SET SPQEKEY = &KEYTIMES16 / 16
  COMPARE ADDR(&SPQEADDR..+13) WITH(VALUE(X'80')) LE(1) MASK(X'80')
  IF &LASTCC = 0 THEN SET SPQESHR = YES
  ELSE SET SPQESHR = NO

/**********************************************************************/
/* Add SPQE info to the table.                                        */
/**********************************************************************/

  ISPEXEC TBADD SPQETBL

/**********************************************************************/
/* Chain to next SPQE.                                                */
/**********************************************************************/

  EVAL &SPQEADDR..+00 LE(4) PTR CLIST(S(SPQEADDR))
  IF &LASTCC=12 THEN DO
   NOTE '==> Error: Next SPQE not available from &SPQEADDR' ASIS
   EXIT C(4)
  END
 END
END
./ ADD NAME=IPVSSA
PROC 1 TCBADDR XTRACE
IF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST
CONTROL NOFLUSH NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
 WRITE *** You must be in IPCS to use this CLIST. ***
 EXIT C(16) Q
END
EVAL &TCBADDR+138?+14 PTR CLIST(S(VSSAPTR))
IF &LASTCC = 12 THEN GOTO FAIL
IF &VSSAPTR = 0 THEN GOTO FAIL
TCBEXIT IEAVSSA1 &TCBADDR
EXIT
FAIL: NOTE 'No vector stuff for TCB at &TCBADDR.' ASIS
EXIT
./ ADD NAME=IPVSSPT
PROC 0 THING(SPT) ADDRESS(&SPTADDR) EXTRA() XTRACE
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS

/**********************************************************************/
/* Get the variables from the current table row.                      */
/**********************************************************************/

ISPEXEC TBGET &THING.TBL

/**********************************************************************/
/* Create a table to hold the DQE entries.                            */
/**********************************************************************/

ISPEXEC TBCREATE DQETBL +
        KEYS() +
        NAMES(DQESEL DQETYPE DQEADDR +
              DQEFFQE DQELFQE DQEAREA DQESIZE +
             ) +
        NOWRITE REPLACE

/**********************************************************************/
/* Access information from SPQA or SPT.  We retrieve info from the    */
/* DFE's chained thereoff, and create a table of DQE's.               */
/*                                                                    */
/* There are 3 queues of DQE's.                                       */
/*                                                                    */
/* (In the following, "Thing" is SPSA (for private) or SPT (for CSA). */
/*                                                                    */
/* Thing + 00 ==> first DQE for storage backed below 16M              */
/* Thing + 04 ==> last  DQE for storage backed below 16M              */
/* Thing + 08 ==> first DQE for storage backed anywhere               */
/* Thing + 0C ==> last  DQE for storage backed anywhere               */
/* Thing + 10 ==> first DQE for storage backed above 16M (????)       */
/* Thing + 14 ==> last  DQE for storage backed above 16M (????)       */
/*                                                                    */
/**********************************************************************/

/**********************************************************************/
/* For each DQE queue, process all DQE's.                             */
/**********************************************************************/

SYSCALL PROCESS_DQE BELOW &ADDRESS 00
SYSCALL PROCESS_DQE ANY   &ADDRESS 08
SYSCALL PROCESS_DQE ABOVE &ADDRESS 10

/******************************************************************/
/* Display the table of DQE's                                     */
/******************************************************************/

%IPTBDISP DQE THING(&THING) ADDRESS(&ADDRESS) EXTRA('&EXTRA')

EXIT


PROCESS_DQE: PROC 3 DQETYPE P OFFSET

 TCBEXIT YITADDR &P..+&OFFSET+0 POS(+0)
 SET LOCATIVE = &STR(&YITHEX)
 EVAL &LOCATIVE..+0 LE(4) PTR CLIST(S(DQEADDR))
 EVAL &LOCATIVE..+4 LE(4) PTR CLIST(S(DQELADDR))

 DO UNTIL &STR(&DQEADDR) = &STR(&DQELADDR) +
     WHILE &STR(&DQEADDR) ^= &STR(&LOCATIVE)
  SET A = &STR(&DQEADDR)
  SET T = &STR(&DQETYPE)
  ISPEXEC TBVCLEAR DQETBL
  SET DQEADDR = &STR(&A)
  SET DQETYPE = &STR(&T)
  EVAL &DQEADDR..+00 LE(4) PTR DIALOG(S(DQENEXT))
  EVAL &DQEADDR..+04 LE(4) PTR DIALOG(S(DQEPREV))
  EVAL &DQEADDR..+08 LE(4) PTR DIALOG(S(DQEFFQE))
  EVAL &DQEADDR..+0C LE(4) PTR DIALOG(S(DQELFQE))
  EVAL &DQEADDR..+10 LE(4) PTR DIALOG(S(DQEAREA))
  EVAL &DQEADDR..+14 LE(4) HEX DIALOG(S(DQESIZE))

/**********************************************************************/
/* Add DQE info to the table.                                         */
/**********************************************************************/

  IF &DQEFFQE = &DQELFQE && &DQEFFQE = &DQEADDR THEN DO
   SET DQEFFQE =
   SET DQELFQE =
  END

  ISPEXEC TBADD DQETBL

/**********************************************************************/
/* Chain to next DQE.                                                 */
/**********************************************************************/

  SET DQEADDR = &STR(&DQENEXT)

 END

END PROCESS_DQE
./ ADD NAME=IPVSSPTO

/**********************************************************************/
/*                                                                    */
/* Old version of IPVSSPTT, tries to display ALL subpool data.  !!!   */
/*                                                                    */
/**********************************************************************/

PROC 1 TCBADDR XTRACE
NGLOBAL SPTTADDR
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
EVALSYM GDA
IF &LASTCC = 12 THEN DO
 NOTE 'The GDA symbol (global data area) is not defined.' ASIS
 EXIT C(12) Q
END
EVALDUMP CLIST(DSN(EVALDUMPDSN))
IF &STR(&EVALDUMPDSN) ^= ACTIVE THEN DO
 NOTE SPACE(1)
 NOTE 'Warning: Viewing active SPTT.  It''s not in the dump!' ASIS
 NOTE SPACE(1)
END
EVAL 10.?+230?+D4 LE(4) PTR CLIST(S(GDASPTT)) ACTIVE
IF &LASTCC = 12 | &GDASPTT = 0 THEN DO
 NOTE 'Error: No valid GDASPTT pointer.' ASIS
 EXIT C(12) Q
END

INTEGER X'&GDASPTT' UNS CLIST(S(NGDASPTT))

 NOTE SPACE(1)
 NOTE 'SPTT at &GDASPTT' ASIS
 NOTE SPACE(1)

DO &SPNO = 0 TO 255

 EVAL &GDASPTT..+4+&SPNO.N L(1) UNS CLIST(S(SPINDEX)) ACTIVE
 INTEGER &EVAL(&NGDASPTT+260+10*(&SPINDEX-1)) PTR CLIST(S(SPTTADDR))

 NOTE SPACE(1)
 NOTE 'Data for subpool &SPNO at &SPTTADDR (index is &SPINDEX)' ASIS
 NOTE SPACE(1)

 SYSCALL SHOW SPTT     00 HEX L(10) T('Subpool translation table entry')
 NOTE SPACE(1)

 SYSCALL SHOW SPTTTYPE 00 HEX L(1) T('Type of storage')
 SYSCALL SHOW SPTTOWN  01 HEX L(1) T('Storage ownership')
 SYSCALL SHOW SPTTCHAR 02 HEX L(1) T('Storage characteristics')
 SYSCALL SHOW SPTTFLGS 04 HEX L(1) T('Miscellaneous flags')
 SYSCALL SHOW SPTTKEY  05 UNS L(1) T('Specific key if one exists')
 SYSCALL SHOW SPTTSPID 07 UNS L(1) T('Internal subpool ID')

 END


EXIT

SHOW: PROC 2 NAME OFFSET TITLE() LENGTHVALUE(4) +
             POINTER PTR CHARACTER SIGNED UNSIGNED HEX

 CONTROL MSG
 INTEGER X'&SPTTADDR'   SIGNED CLIST(S(V1))
 INTEGER X'&OFFSET'     SIGNED CLIST(S(V2))
 INTEGER &EVAL(&V1+&V2) PTR(8) CLIST(S(V3))

 EVAL &V3          L(&LENGTHVALUE) CLIST(S(DATA)) ACTIVE +
                   &POINTER &PTR &CHARACTER &SIGNED &UNSIGNED &HEX
 SET EVALCC = &LASTCC
 IF &EVALCC ^= 0 THEN SET DATA = &STR(LASTCC=&EVALCC)

 NOTE '&SUBSTR(1:8,&V3         ) +
       &SUBSTR(1:8,&NAME       ) +
       &SUBSTR(1:16,&NRSTR(&DATA                ))  &NRSTR(&TITLE)' ASIS

END SHOW

./ ADD NAME=IPVSSPTT
PROC 1 TCBADDR SUBPOOL() GDAADDRESS() XTRACE
NGLOBAL SPTTADDR
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
IF &SUBPOOL ^= THEN DO
 SYSCALL DO_ONE &SUBPOOL GDASPTT(&GDAADDRESS)
 EXIT
END
EVALSYM GDA
IF &LASTCC = 12 THEN DO
 NOTE 'The GDA symbol (global data area) is not defined.' ASIS
 EXIT C(12) Q
END
EVALDUMP CLIST(DSN(EVALDUMPDSN))
IF &STR(&EVALDUMPDSN) ^= ACTIVE THEN DO
 SET WARNING = &STR(+
                  Warning: Viewing active SPTT.  It's not in the dump!)
END
ELSE SET WARNING =
EVAL 10.?+230?+D4 LE(4) PTR CLIST(S(GDASPTT)) ACTIVE
IF &LASTCC = 12 | &GDASPTT = 0 THEN DO
 NOTE 'Error: No valid GDASPTT pointer.' ASIS
 EXIT C(12) Q
END

DISPLAY:+
ISPEXEC DISPLAY PANEL(IPVSSPTT) /* sets SPNO */
IF &LASTCC ^= 0 THEN EXIT

ISPEXEC SELECT PGM(BLSGSCMD) MODE(FSCR) +
               PARM(%IPVSSPTT &TCBADDR SUBPOOL(&SPNO) GDA(&GDASPTT) +
                              &XTRACE)


GOTO DISPLAY

DO_ONE: PROC 1 SPNO GDASPTT()

 /* Stupid code to get around SYSREF lossage.
 SET SYSDVAL =
 READDVAL SPTT SPTTTYPE SPTTOWN SPTTCHAR SPTTFLGS SPTTKEY SPTTSPID BITS

 INTEGER X'&GDASPTT' UNS CLIST(S(NGDASPTT))

 EVAL &GDASPTT..+4+&SPNO.N L(1) UNS CLIST(S(SPINDEX)) ACTIVE
 INTEGER &EVAL(&NGDASPTT+260+10*(&SPINDEX-1)) PTR CLIST(S(SPTTADDR))

 NOTE SPACE(1)
 NOTE 'Data for subpool &SPNO at &SPTTADDR (index is &SPINDEX)' ASIS
 NOTE SPACE(1)

 SYSCALL SHOW SPTT     00 HEX L(10) T('Subpool translation table entry')
 NOTE SPACE(1)

 SYSCALL SHOW SPTTTYPE 00 HEX L(1) T('Type of storage')
 SYSCALL SHOW SPTTOWN  01 HEX L(1) T('Storage ownership')
 SYSCALL SHOW SPTTCHAR 02 HEX L(1) T('Storage characteristics')
 SYSCALL SHOW SPTTFLGS 04 HEX L(1) T('Miscellaneous flags')
 SYSCALL SHOW SPTTKEY  05 UNS L(1) T('Specific key if one exists')
 SYSCALL SHOW SPTTSPID 07 UNS L(1) T('Internal subpool ID')

 SYSCALL SETBITS BITS SPTTCHAR
 IF &SUBSTR(1,&BITS) = 1 THEN SET SPTTFIX  =&STR(Fixed, )
 ELSE                         SET SPTTFIX  =&STR(Pageable, )
 IF &SUBSTR(2,&BITS) = 1 THEN SET SPTTPROT =&STR(fetch protected, )
 ELSE                         SET SPTTPROT =&STR(non-fetch protected, )
 IF &SUBSTR(3,&BITS) = 1 THEN SET SPTTVABV =&STR(allocated above 16M, )
 ELSE                         SET SPTTVABV =
 IF &SUBSTR(4,&BITS) = 1 THEN SET SPTTVBLW =&STR(allocated below 16M, )
 ELSE                         SET SPTTVBLW =
 IF &SUBSTR(5,&BITS) = 1 THEN SET SPTTREAL =&STR(backed anywhere, )
 ELSE                         SET SPTTREAL =&STR(backed below 16M, )
 IF &SUBSTR(6,&BITS) = 1 THEN SET SPTTFBQE =&STR(allocate high to low, )
 ELSE                         SET SPTTFBQE =&STR(allocate low to high, )
 IF &SUBSTR(7,&BITS) = 0 THEN SET SPTTK    =&STR(no specific key
 ELSE DO
  IF &SUBSTR(8,&BITS) = 1 THEN SET SPTTK   =&STR(use TCB key
  ELSE                         SET SPTTK   =&STR(use PSW key
 END

 SYSCALL SETBITS BITS SPTTFLGS
 NOTE SPACE(1)
 IF &SUBSTR(1,&BITS)=1 THEN +
      SET SPTTDEF  = &STR(Subpool ID defined, )
 ELSE SET SPTTDEF  = &STR(Subpool ID undefined, )
 IF &SUBSTR(2,&BITS)=1 THEN +
      SET SPTTAUTH = &STR(authorization required, )
 ELSE SET SPTTAUTH = &STR(no authorization required, )
 IF &SUBSTR(3,&BITS)=1 THEN +
      SET SPTTEXTK = &STR(key can be externally specified, )
 ELSE SET SPTTEXTK = &STR(key cannot be externally specified, )
 IF &SUBSTR(4,&BITS)=1 THEN +
      SET SPTTSPFM = &STR(can be subpool freed, )
 ELSE SET SPTTSPFM = &STR(cannot be subpool freed, )
 IF &SUBSTR(5,&BITS)=1 THEN +
      SET SPTTGLSP = &STR(allowed on global entry, )
 ELSE SET SPTTGLSP = &STR(not allowed on global entry, )
 IF &SUBSTR(6,&BITS)=1 THEN +
      SET SPTTROPT = &STR(real option can be externally specified, )
 ELSE SET SPTTROPT = &STR(real option cannot be externally specified, )
 IF &SUBSTR(7,&BITS)=1 THEN +
      SET SPTTCONV = &STR(pages can be converted from another subpool, )
 ELSE SET SPTTCONV = &STR(+
                       pages cannot be converted from another subpool, )
 IF &SUBSTR(8,&BITS)=1 THEN +
    SET SPTTBACK = &STR(only first page is to be backed at GETMAIN time)
 ELSE SET SPTTBACK = &STR(all pages are to be backed at GETMAIN time)

 IF &SYSINDEX(undefined,&STR(&SPTTDEF)) ^= 0 THEN DO
  NOTE SPACE(1)
  NOTE 'This subpool (&SPNO) is undefined.' ASIS
  NOTE SPACE(1)
  RETURN
 END

 NOTE 'Storage characteristics:' SPACE(1) ASIS
 NOTE SPACE(1)
 NOTE '&SPTTFIX.&SPTTPROT.&SPTTV.&SPTTREAL' ASIS
 NOTE '&SPTTFBQE.&SPTTK' ASIS
 NOTE SPACE(1)
 NOTE '&SPTTDEF.&SPTTAUTH' ASIS
 NOTE '&SPTTEXTK.&SPTTSPFM' ASIS
 NOTE '&SPTTGLSP.&SPTTROPT' ASIS
 NOTE '&SPTTCONV' ASIS
 NOTE '&SPTTBACK' ASIS
 NOTE SPACE(1)

END


SHOW: PROC 2 VAR  OFFSET TITLE() LENGTHVALUE(4) +
             POINTER PTR CHARACTER SIGNED UNSIGNED HEX

 SET NAME = &STR(&VAR)
 SYSREF VAR
 INTEGER X'&SPTTADDR'   SIGNED CLIST(S(V1))
 INTEGER X'&OFFSET'     SIGNED CLIST(S(V2))
 INTEGER &EVAL(&V1+&V2) PTR(8) CLIST(S(V3))

 EVAL &V3          L(&LENGTHVALUE) CLIST(S(DATA)) ACTIVE +
                   &POINTER &PTR &CHARACTER &SIGNED &UNSIGNED &HEX
 SET EVALCC = &LASTCC
 IF &EVALCC ^= 0 THEN SET DATA = &STR(LASTCC=&EVALCC)
 ELSE SET VAR = &NRSTR(&DATA)
 SELECT &POINTER&PTR&CHARACTER&SIGNED&UNSIGNED&HEX
  WHEN (HEX)        SET DAT2 = &NRSTR(X"&DATA")
  WHEN (CHARACTER)  SET DAT2 = &NRSTR(C"&DATA")
  WHEN (SIGNED) DO
   SELECT &LENGTHVALUE
    WHEN (2)  SET DAT2 = &NRSTR(H"&DATA")
    WHEN (4)  SET DAT2 = &NRSTR(F"&DATA")
    OTHERWISE SET DAT2 = &NRSTR(&DATA)
   END
  END
  WHEN (UNSIGNED) DO
   SELECT &LENGTHVALUE
    WHEN (1)  SET DAT2 = &NRSTR(YL1(&DATA))
    WHEN (2)  SET DAT2 = &NRSTR(Y(&DATA))
    WHEN (3)  SET DAT2 = &NRSTR(AL3(&DATA))
    WHEN (4)  SET DAT2 = &NRSTR(A(&DATA))
    OTHERWISE SET DAT2 = &NRSTR(&DATA)
   END
  END
  OTHERWISE       SET DAT2 = &NRSTR(&DATA)
 END

 IF &LENGTH(&NRSTR(&DAT2)) > 16 THEN DO
  NOTE '&SUBSTR(1:8,&V3         ) +
        &SUBSTR(1:8,&NAME       ) +
        &NRSTR(&DAT2)' ASIS
  NOTE '                                    &NRSTR(&TITLE)' ASIS
 END
 ELSE DO
  NOTE '&SUBSTR(1:8,&V3         ) +
        &SUBSTR(1:8,&NAME       ) +
        &SUBSTR(1:16,&NRSTR(&DAT2                ))  &NRSTR(&TITLE)' +
        ASIS
 END

END SHOW


SETBITS: PROC 2 BITS FROMWHAT
 SYSREF BITS FROMWHAT
 %BINARY X'&FROMWHAT'
 SET R = &LASTCC
 SET L = &LENGTH(&STR(&R))
 SET BITS = &SUBSTR(&L+1:&L+8,00000000&R)
END
./ ADD NAME=IPVSSQA
PROC 1 TCBADDR XTRACE
/**********************************************************************/
/* This procedure analyzes global system queue area virtual storage.  */
/**********************************************************************/

NGLOBAL CVTGDA
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
EVAL CVT+230 LE(4) PTR CLIST(S(CVTGDA))
IF &LASTCC = 12 THEN DO
 NOTE 'Error, GDA pointer not available' ASIS
 EXIT C(12) Q
END

/******************************************************************/
/* Create table of DFE's for this GDA                             */
/******************************************************************/

ISPEXEC TBCREATE DFETBL +
        KEYS() +
        NAMES(DFESEL DFEADDR DFETYPE DFESPID +
              DFEANEXT DFEAPREV DFESNEXT DFESPREV DFEAREA DFESIZE +
             ) +
        NOWRITE REPLACE

/******************************************************************/
/* Extract pointers from the GDA                                  */
/******************************************************************/

/* --- Subpool 245 (SQA) non-extended queue anchors --- */

EVAL &CVTGDA..+004 L(4) PTR CLIST(S(GDASQAT5)) /* -> SQAT
EVAL &CVTGDA..+008 L(4) PTR CLIST(S(GDAAQAT5)) /* -> AQATINDX
EVAL &CVTGDA..+00C L(4) PTR CLIST(S(GDAADF45)) /* -> first DFE on addr q
EVAL &CVTGDA..+010 L(4) PTR CLIST(S(GDAADL45)) /* -> last  DFE on addr q
EVAL &CVTGDA..+014 L(4) PTR CLIST(S(GDASZF45)) /* -> first DFE on size q
EVAL &CVTGDA..+018 L(4) PTR CLIST(S(GDASZL45)) /* -> last  DFE on size q

/* --- Subpool 245 (SQA) extended queue anchors --- */

EVAL &CVTGDA..+01C L(4) PTR CLIST(S(GDAESQT5)) /* -> SQAT
EVAL &CVTGDA..+020 L(4) PTR CLIST(S(GDAEAQT5)) /* -> AQATINDX
EVAL &CVTGDA..+024 L(4) PTR CLIST(S(GDAEADF5)) /* -> first DFE on addr q
EVAL &CVTGDA..+028 L(4) PTR CLIST(S(GDAEADL5)) /* -> last  DFE on addr q
EVAL &CVTGDA..+02C L(4) PTR CLIST(S(GDAESDF5)) /* -> first DFE on size q
EVAL &CVTGDA..+030 L(4) PTR CLIST(S(GDAESDL5)) /* -> last  DFE on size q

/* --- Subpool 226 (SQA) non-extended queue anchors --- */

EVAL &CVTGDA..+034 L(4) PTR CLIST(S(GDASQAT6)) /* -> SQAT
EVAL &CVTGDA..+038 L(4) PTR CLIST(S(GDAAQAT6)) /* -> AQATINDX
EVAL &CVTGDA..+03C L(4) PTR CLIST(S(GDAADF26)) /* -> first DFE on addr q
EVAL &CVTGDA..+040 L(4) PTR CLIST(S(GDAADL26)) /* -> last  DFE on addr q
EVAL &CVTGDA..+044 L(4) PTR CLIST(S(GDASZF26)) /* -> first DFE on size q
EVAL &CVTGDA..+048 L(4) PTR CLIST(S(GDASZL26)) /* -> last  DFE on size q

/* --- Subpool 239 (SQA) non-extended queue anchors --- */

EVAL &CVTGDA..+0E4 L(4) PTR CLIST(S(GDASQAT9)) /* -> SQAT
EVAL &CVTGDA..+0E8 L(4) PTR CLIST(S(GDAAQAT9)) /* -> AQATINDX
EVAL &CVTGDA..+0EC L(4) PTR CLIST(S(GDAADF39)) /* -> first DFE on addr q
EVAL &CVTGDA..+0F0 L(4) PTR CLIST(S(GDAADL39)) /* -> last  DFE on addr q
EVAL &CVTGDA..+0F4 L(4) PTR CLIST(S(GDASZF39)) /* -> first DFE on size q
EVAL &CVTGDA..+0F8 L(4) PTR CLIST(S(GDASZL39)) /* -> last  DFE on size q

/* --- Subpool 239 (SQA) extended queue anchors --- */

EVAL &CVTGDA..+0FC L(4) PTR CLIST(S(GDAESQT9)) /* -> SQAT
EVAL &CVTGDA..+100 L(4) PTR CLIST(S(GDAEAQT9)) /* -> AQATINDX
EVAL &CVTGDA..+104 L(4) PTR CLIST(S(GDAEADF9)) /* -> first DFE on addr q
EVAL &CVTGDA..+108 L(4) PTR CLIST(S(GDAEADL9)) /* -> last  DFE on addr q
EVAL &CVTGDA..+10C L(4) PTR CLIST(S(GDAESZF9)) /* -> first DFE on size q
EVAL &CVTGDA..+110 L(4) PTR CLIST(S(GDAESZL9)) /* -> last  DFE on size q

/**********************************************************************/
/* Process all the DFE's                                              */
/**********************************************************************/

SYSCALL PROCESS_DFE &GDAADF45 &GDAADL45 245          &XTRACE
SYSCALL PROCESS_DFE &GDAEADF5 &GDAEADL5 245 EXTENDED &XTRACE
SYSCALL PROCESS_DFE &GDAADF26 &GDAADL26 226          &XTRACE
SYSCALL PROCESS_DFE &GDAADF39 &GDAADL39 239          &XTRACE
SYSCALL PROCESS_DFE &GDAEADF9 &GDAEADL9 239 EXTENDED &XTRACE

%IPTBDISP DFE THING(GDA) ADDR(&CVTGDA)

EXIT


PROCESS_DFE: PROC 3 FIRSTDFE LASTDFE SUBPOOL EXTENDED XTRACE
 SET DFEADDR = &STR(&FIRSTDFE)
 IF &STR(&DFEADDR) = 0 THEN RETURN
 DO UNTIL &STR(&A)        = &STR(&FIRSTDFE) +

  INTEGER X'&DFEADDR' PTR DIALOG(S(DFEADDR))
  SET A = &STR(&DFEADDR)
  ISPEXEC TBVCLEAR DFETBL
  SET DFEADDR = &STR(&A)
  EVAL &DFEADDR..+00 LE(24) HEX CLIST(S(STUFF))
  SET DFEANEXT = &SUBSTR(01:08,&STUFF)
  SET DFEAPREV = &SUBSTR(09:16,&STUFF)
  SET DFESNEXT = &SUBSTR(17:24,&STUFF)
  SET DFESPREV = &SUBSTR(25:32,&STUFF)
  SET DFEAREA  = &SUBSTR(33:40,&STUFF)
  SET DFESIZE  = &SUBSTR(41:48,&STUFF)

/**********************************************************************/
/* Add DFE info to the table.                                         */
/**********************************************************************/

  IF &STR(&DFEAREA&DFESIZE) = 0000000000000000 THEN SET DFETYPE = DUMMY
  ELSE SET DFETYPE =
  SET DFESPID = &SUBPOOL
  IF &EXTENDED = EXTENDED THEN SET DFETYPE = E&DFETYPE
  ISPEXEC TBADD DFETBL
/*WRITE +
        &DFESEL &DFEADDR &DFETYPE &DFESPID +
        &DFEANEXT &DFEAPREV &DFESNEXT &DFESPREV &DFEAREA &DFESIZE +

/**********************************************************************/
/* Chain to next DFE.                                                 */
/**********************************************************************/

  SET DFEADDR = &STR(&DFEANEXT)
  SET A       = &STR(&DFEADDR)
 END

END PROCESS_DFE

./ ADD NAME=LINKLIST
PROC 0 DEBUG XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
/***********************************************************************
/*                                                                     *
/* This CLIST displays the current link list libraries and volumes.    *
/*                                                                     *
/***********************************************************************
EVAL 10.%+8%+2D L(3) PTR CLIST(S(DEB))  /* DEB for SYS1.LINKLIB DCB */
IF &LASTCC = 12 THEN DO
 NOTE 'Error: DEB for SYS1.LINKLIB DCB not available' SPACE(1) ASIS
 EXIT C(12) Q
END
IF &DEBUG = DEBUG THEN WRITE DEB=&DEB
EVAL 10.%+4DC   L(4) PTR CLIST(S(LLT))  /* Link list table          */
IF &LASTCC = 12 THEN DO
 NOTE 'Error: LLT (CVT+4DC) pointer not available' SPACE(1) ASIS
 EXIT C(12) Q
END
IF &DEBUG = DEBUG THEN WRITE LLT=&LLT
EVAL &DEB..+4   L(1) UNS CLIST(S(CATS)) /* Bytes in AM sec = # concats
IF &LASTCC = 12 THEN DO
 NOTE 'Error: Unable to access concat count from DEB at &DEB' +
      SPACE(1) ASIS
 EXIT C(12) Q
END
IF &DEBUG = DEBUG THEN WRITE CATS=&CATS
SET CATS = &CATS + 1 /* Add a byte for zeroth extent */
IF &DEBUG = DEBUG THEN WRITE CATS=&CATS
EVAL &DEB..+10  L(1) HEX CLIST(S(EXTENTS)) /* Total number of extents
IF &LASTCC = 12 THEN DO
 NOTE 'Error: Unable to access # of extents from DEB at &DEB' +
      SPACE(1) ASIS
 EXIT C(12) Q
END
IF &DEBUG = DEBUG THEN WRITE EXTENTS=&EXTENTS
/* Get the concatenation extent pointers, following the extent entries
EVAL &DEB..+20+&EXTENTS.0 L(&CATS) HEX CLIST(S(CONCATS))
IF &LASTCC = 12 THEN DO
 NOTE 'Error: Unable to get concatenation extent pointers from +
              DEB AT &DEB for X''&EXTENTS'' extents' SPACE(1) ASIS
 EXIT C(12) Q
END
IF &DEBUG = DEBUG THEN WRITE CONCATS=&CONCATS
EVAL &LLT..+4 L(4) SIGNED CLIST(S(LINKNO))
IF &LASTCC = 12 THEN DO
 NOTE 'Error: Unable to get # of linklist libs from LLT at &LLT' +
              SPACE(1) ASIS
 EXIT C(12) Q
END
IF &DEBUG = DEBUG THEN WRITE LINKNO=&LINKNO
SET I = 1
SET O = 8
DO WHILE &I LE &LINKNO
 EVAL &LLT..+&O.N+0 L(1) HEX CLIST(S(LIBLEN))
 EVAL &LLT..+&O.N+1 L(X'&LIBLEN') CHAR CLIST(S(LINKDS&I))
 SET O = &O + 45
 SET I = &I + 1
END
SET I = 1
SET J = 1
SET CATBYTE =
DO WHILE &I LE &CATS
 IF &DEBUG = DEBUG THEN DO
  EVAL &DEB..+20+&CATBYTE.0 L(16) CLIST(S(JUNK))
  WRITE CATBYTE=&SUBSTR(1:2,&CATBYTE  )  &NRSTR(&JUNK)
 END
 EVAL &DEB..+21+&CATBYTE.0 L(3) PTR CLIST(S(UCB))
 EVAL &UCB..+1C L(6) CHAR CLIST(S(VOL))
 EVAL &UCB..+D  L(3) CHAR CLIST(S(DEV))
 SET LINKDS = &STR(&&LINKDS&I)
 NOTE '&LINKDS - &VOL (&DEV)'
 SET CATBYTE = &SUBSTR(&J:&J+1,&CONCATS)
 SET I = &I + 1
 SET J = &J + 2
END /* Loop for all extents */
./ ADD NAME=LISTASID
 PROC 0 ASID() ACTIVE XTRACE
/*********************************************************************/
/* REFER   IPO1.CMDPROC(LISTASID)                                    */
/* COMPID  SYSTEMS                                                   */
/* DOC     This CLIST executes under IPCS to display the jobnames    */
/*         for the active ASIDs in the dump being analyzed.          */
/*         Optionally, it checks only the specified ASID.            */
/* CHANGED by S. BACHER 11/10/82 - new keywords added for list       */
/*         by S. BACHER 11/07/84 - new keywords added for XA         */
/*         by S. BACHER 07/10/85 - list keywords removed, uses NOTE  */
/*                                                                   */
/*********************************************************************/
 NGLOBAL FIRST_ASID_NOT_ASSIGNED LAST_ASID_NOT_ASSIGNED
 /******************************************************************/
 /* Set up environment                                             */
 /******************************************************************/
 IF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST
 CONTROL NOCAPS
 IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
 END
 /******************************************************************/
 /* Initialization                                                 */
 /******************************************************************/
 SET &RCODE=0                       /* Set return code             */
 EQUATE ASVTADDR 4C.%+22C% PTR LE(4) &ACTIVE /* Address of ASVT    */
 EVAL ASVTADDR+204 LENGTH(4) &ACTIVE /* Contents of ASVTMAXU       */+
      UNS CLIST(S(ASVTMAXU))
 SET &MEMCTR=0                      /* Total memories              */
 SET &ACTCTR=0                      /* Active memories             */
 SET &TSOCTR=0                      /* TSO users                   */
 /******************************************************************/
 /* Process the ASID, if any, and insure that it is valid          */
 /******************************************************************/
 IF &ACTIVE = ACTIVE THEN DO
  IF &STR(&ASID) ^= THEN DO
   WRITE Error: ASID and ACTIVE are mutually exclusive keywords
   SET RCODE = 8
   GOTO EXIT
  END
  SET ASID = 1
  SET ENDASID = &ASVTMAXU
  GOTO GOTASID
 END
 IF &ASID ^= THEN DO
  INTEGER &ASID UNSIGNED CLIST(S(ASID))
  IF &LASTCC ^= 0 THEN DO
   WRITE ==> Error: An Invalid ASID (&ASID) was specified.
   SET RCODE = 12
   GOTO EXIT
  END
 END
 IF &ASID^=   AND                   /* ASID specified and          */+
   &ASID^=0 THEN                    /* ASID is non-zero            */+
   IF &ASID>&ASVTMAXU THEN          /* Insure valid ASID           */+
     DO
       WRITE ==> Error: ASID(&ASID) is greater than +
         max users (&ASVTMAXU)
       SET &RCODE=8                 /* Error return code           */
       GOTO EXIT
     END
   ELSE                             /* Have valid ASID             */+
     SET &ENDASID=&ASID             /* End of loop control         */
 ELSE                               /* Use all possible ASIDS      */+
   DO
     SET &ASID=1                    /* First ASID to check         */
     SET &ENDASID=&ASVTMAXU         /* Last ASID to check          */
   END
 /******************************************************************/
 /* Set up the header and page control                             */
 /******************************************************************/
 GOTASID:+
 SET Z=&STR(***    Display of ASIDs(&ASID:&ENDASID) and jobnames  -
                                                  )
 SET Z=&SUBSTR(1:64,&Z)&STR(***)
 NOTE '*************************************************************+
 ******' PAGE
 NOTE '&Z' ASIS
 NOTE '*************************************************************+
 ******'
 NOTE SPACE(1)
 SET FIRST_ASID_NOT_ASSIGNED =
 SET LAST_ASID_NOT_ASSIGNED =
 /******************************************************************/
 /* Loop through the specified or all ASIDs                        */
 /******************************************************************/
 DO WHILE &ASID^=&ENDASID+1         /* Check each ASID             */
   SET &MEMCTR=&MEMCTR+1            /* Count total memories        */
   IF &ACTIVE = ACTIVE THEN         /* ASID keyword                */+
    SET MEM = ACTIVE                /* ASID keyword                */
   ELSE                             /* ASID keyword                */+
    SET &MEM=ASID(&ASID)            /* ASID keyword                */
   SET &ASVTOFFS = &ASID*4          /* Offset into entries of ASVT */
   EVAL ASVTADDR+20C+&ASVTOFFS.N &ACTIVE PTR L(4) CLIST(S(ASVTENTRY))
   IF &LASTCC = 12 THEN DO
    NOTE 'Error: ASVT entry not available for ASID(&ASID)' ASIS
    GOTO EXITASID
   END
   SET ZASID = &SUBSTR(2:4,&EVAL(&ASID+1000))
   INTEGER &ASID PTR(4) CLIST(S(HEXASID)
   IF &SUBSTR(1:2,&ASVTENTRY)=80 THEN /* If memory is not assigned */+
     DO
       /* NOTE 'ASID&ZASID (X''&HEXASID'') not assigned' ASIS
       SET LAST_ASID_NOT_ASSIGNED = &STR(&ZASID (X''&HEXASID''))
       IF &STR(&FIRST_ASID_NOT_ASSIGNED) = &STR() THEN +
         SET FIRST_ASID_NOT_ASSIGNED = &STR(&LAST_ASID_NOT_ASSIGNED)
     END
   ELSE                             /* Memory is assigned          */+
     DO

       SYSCALL LIST_UNASSIGNED_ASIDS_SO_FAR

       SET &ACTCTR=&ACTCTR+1        /* Count active memories       */
       SET ASCBADDR = &SUBSTR(3:8,&ASVTENTRY) /* Address of ASCB   */
       EQ ASCB &ASCBADDR.. STRUCTURE(ASCB) &MEM /* Equate the ASCB */
       COMPARE ADDRESS(ASCB+3C)     /* Address of TSB, if any      */+
         LE(4) WITH(VALUE(X'00000000')) &ACTIVE
       IF &LASTCC=0 THEN            /* Must not be TSO user        */+
         SET &TSO=Job name          /* Indicate no TSO user        */
       ELSE                          /* Must be TSO user           */+
         DO
           SET &TSO=TSO user         /* Indicate TSO user          */
           SET &TSOCTR=&TSOCTR+1     /* Count TSO users            */
         END
       EVAL ASCB+B0 L(4) &MEM PTR CLIST(S(ASCBJBNS)) /* Jobnameptr */
       IF &ASCBJBNS=0 THEN DO       /* Check if valid pointer      */
         SET JOBNAME = &STR(not avail)
       END
       ELSE DO                       /* Have valid jobname         */
         EVAL &ASCBJBNS.. L(8) CHAR &MEM CLIST(S(JOBNAME))
         IF &LASTCC = 12 THEN SET JOBNAME = &STR(no access)
       END
       SET IJOBNAME =
       EVAL ASCB+AC L(4) &MEM PTR CLIST(S(ASCBJBNI))
       IF &ASCBJBNI=0 THEN DO       /* Check if valid pointer      */
       END
       ELSE DO                       /* Have valid jobname         */
         EVAL &ASCBJBNI.. L(8) CHAR &MEM CLIST(S(IJOBNAME))
         SET IJOBNAME = &STR(INIT:  &IJOBNAME)
       END
       EVAL ASCB+2B &MEM L(1) UNS CLIST(S(DP)) /* Dispatching prty */
       NOTE 'ASID&ZASID (X''&HEXASID'')  +
            &TSO:  &SUBSTR(1:9,&JOBNAME         )  +
            DP:  &DP  &IJOBNAME' +
            ASIS
     END
   EXITASID:+
   SET &ASID=&ASID+1                 /* STEP TO NEXT ASID          */
 END                                 /* END OF ASID CHECK LOOP     */

 SYSCALL LIST_UNASSIGNED_ASIDS_SO_FAR

 EXIT: NOTE 'Total ASIDs processed=&MEMCTR;  +
       Active=&ACTCTR;  TSO users=&TSOCTR' SPACE(1) ASIS
       NOTE SPACE(1)
       EXIT CODE(&RCODE)

LIST_UNASSIGNED_ASIDS_SO_FAR: PROC 0

 IF &STR(&LAST_ASID_NOT_ASSIGNED) ^= &STR() THEN DO
   SET SYSDVAL = &STR(&FIRST_ASID_NOT_ASSIGNED)
   READDVAL NASID1
   SET SYSDVAL = &STR(&LAST_ASID_NOT_ASSIGNED)
   READDVAL NASID2
   IF &NASID1 = &NASID2 THEN DO
     NOTE 'ASID&FIRST_ASID_NOT_ASSIGNED not assigned' ASIS
   END
   ELSE IF &NASID1 = &NASID2-1 THEN DO
     NOTE 'ASID&FIRST_ASID_NOT_ASSIGNED not assigned' ASIS
     NOTE 'ASID&LAST_ASID_NOT_ASSIGNED not assigned' ASIS
   END
   ELSE DO
     SET ANARANGE = &STR(&FIRST_ASID_NOT_ASSIGNED thru +
                         &LAST_ASID_NOT_ASSIGNED)
     NOTE '-----------------' ASIS
     NOTE 'ASID&ANARANGE not assigned' ASIS
     NOTE '-----------------' ASIS
   END
   SET FIRST_ASID_NOT_ASSIGNED =
   SET LAST_ASID_NOT_ASSIGNED =
 END

END /* LIST_UNASSIGNED_ASIDS_SO_FAR */

./ ADD NAME=LISTDSAB
PROC 0 TCB() ACTIVE BACKWARDS XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
/* Code to extract current TCB
IF &STR(&TCB) = THEN DO
 SET TCB = 0
 EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))
 IF &TCB = 0 THEN DO
  EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))
  IF &TCB = 0 THEN DO
   EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))
   IF &TCB = 0 THEN DO
    NOTE 'TCB unavailable' ASIS
    EXIT C(12) Q
   END
  END
 END
 SET TCB = &STR(&TCB..)
END
/* End code to extract current TCB
EVAL &TCB+B4 L(4) &ACTIVE CLIST(STORAGE(JSCB)
IF &LASTCC = 12 THEN DO
 NOTE 'Error: JSCB pointer in TCB at &TCB could not be accessed.' ASIS
 EXIT C(12) Q
END
IF &JSCB = 0 THEN DO
 NOTE 'TCB at &TCB has no JSCB.' ASIS
 EXIT C(12) Q
END
EVAL &JSCB..+15C L(4) &ACTIVE CLIST(STORAGE(JSCBACT))
IF &LASTCC = 12 THEN DO
 NOTE 'Error: JSCBACT ptr in JSCB at &JSCB cannot be accessed.' ASIS
 EXIT C(12) Q
END
IF &JSCBACT ^= 0 THEN SET JSCB = &JSCBACT
EVAL &JSCB..+140 L(4) &ACTIVE CLIST(STORAGE(QDB))
IF &LASTCC = 12 THEN DO
 NOTE 'Error: QDB pointer in JSCB at &JSCB cannot be accessed.' ASIS
 EXIT C(12) Q
END
IF &QDB = 0 THEN DO
 NOTE 'JSCB at &JSCB has no QDB.' ASIS
 EXIT C(12) Q
END
IF &BACKWARDS ^= THEN +
 EVAL &QDB..+10 L(4) &ACTIVE CLIST(STORAGE(DSAB))
ELSE +
 EVAL &QDB..+0C L(4) &ACTIVE CLIST(STORAGE(DSAB))
IF &LASTCC = 12 THEN DO
 NOTE 'Error: DSAB pointer in QDB at &QDB cannot be accessed.' ASIS
 EXIT C(12) Q
END
IF &DSAB = 0 THEN DO
 NOTE 'QDB at &QDB has no DSAB.' ASIS
 EXIT C(12) Q
END
ERROR
NOTE SPACE(1)
NOTE 'DSAB ADDR--SIOT ADDR--DDNAME---VOL---DEV--JFCB ADDR--DSNAME' ASIS
NOTE SPACE(1)
DO UNTIL &DSAB = 0
 EVAL &DSAB..+40         L(4)  PTR  &ACTIVE CLIST(STORAGE(SIOT))
 IF &SIOT = 0 THEN DO
  EVAL &DSAB..+15        L(3)  PTR  &ACTIVE CLIST(STORAGE(SIOT))
  IF &SIOT = 0 THEN DO
   NOTE 'Error: No SIOT for DSAB at &DSAB..' ASIS
   EXIT C(12) Q
  END
  INTEGER X'&SIOT' UNS CLIST(S(SIOTN))
  INTEGER &EVAL(&SIOTN+16) PTR CLIST(S(SIOT))
 END
 EVAL &SIOT..+04         L(8)  CHAR &ACTIVE CLIST(STORAGE(DDNAME))
 EVAL &SIOT..+20         L(3)  UNSI &ACTIVE CLIST(STORAGE(JFCBPTRN))
 INTEGER &EVAL(&JFCBPTRN+16)   PTR          CLIST(STORAGE(JFCBPTR))
 EVAL &JFCBPTR..+0       L(44) CHAR &ACTIVE CLIST(STORAGE(DSNAME))
 EVAL &JFCBPTR..+2C      L(8)  CHAR &ACTIVE CLIST(STORAGE(MEMBER))
 EVAL &JFCBPTR..+76      L(6)  CHAR &ACTIVE CLIST(STORAGE(VOLSER))
 EVAL &SIOT..+40         L(1)  UNS  &ACTIVE CLIST(STORAGE(SIOUCNVT)
 SET UNIT = &STR(   )
 IF &SIOUCNVT = 0 THEN DO
  EVAL &SIOT..+41        L(3)  PTR  &ACTIVE CLIST(STORAGE(UCBPTR))
  IF &UCBPTR ^= 0 THEN DO
   EVAL &UCBPTR..+D      L(3)  CHAR &ACTIVE CLIST(STORAGE(UNIT))
  END
 END
 SET SYSDVAL = &NRSTR(&DSNAME &MEMBER)
 READDVAL DSNAME MEMBER
 IF &NRSTR(&MEMBER) ^= THEN SET DSNAME = &NRSTR(&DSNAME(&MEMBER))
 INTEGER X'&DSAB'    PTR LENGTH(8) CLIST(S(DSAB8))
 INTEGER X'&SIOT'    PTR LENGTH(8) CLIST(S(SIOT8))
 INTEGER X'&JFCBPTR' PTR LENGTH(6) CLIST(S(JFCB8))
 NOTE '&NRSTR(&DSAB8  &SIOT8  &DDNAME &VOLSER &UNIT  &JFCB8 &DSNAME)' +
      ASIS
 IF &BACKWARDS ^= THEN +
  EVAL &DSAB..+8 L(4) &ACTIVE CLIST(S(DSAB))
 ELSE +
  EVAL &DSAB..+4 L(4) &ACTIVE CLIST(S(DSAB))
END
EXIT
./ ADD NAME=LISTREGS
PROC 0 ASID() TCB() ACTIVE XTRACE
/*********************************************************************/
/*                                                                   */
/* Function: This CLIST executes under IPCS to display the registers */
/*           for all TCBs and RBs in a memory contained in the dump  */
/*           being analyzed.  It also displays the module name, if   */
/*           available, for all PRBs and the interrupt code for all  */
/*           RBs.  Optionally, it lists the above data for a specific*/
/*           ASID.                                                   */
/* CHANGED:  By S. BACHER 11/10/82 - New keywords added for LIST     */
/*           By S. BACHER 11/07/84 - XA "ACTIVE" support             */
/*           By S. BACHER 10/10/85 - Support for map by TCB          */
/*                                                                   */
/* SYNTAX:   %LISTREGS  |ASID(#) / ACTIVE| |TCB(tcbaddr)| |XTRACE|   */
/*                                                                   */
/*              ASID   - ASID to list registers from                 */
/*              ACTIVE - List registers from active storage          */
/*              TCB(tcbaddr) - List this TCB only; default=all TCB's */
/*              XTRACE - List control statements of the CLIST        */
/*                                                                   */
/*********************************************************************/
/******************************************************************/
/* Initialization                                                 */
/******************************************************************/
IF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
SET &RCODE=0                       /* Set return code             */
/******************************************************************/
/* Process the "ACTIVE" keyword                                   */
/******************************************************************/
IF &ACTIVE = ACTIVE THEN DO        /* Active specified            */
  IF &STR(&ASID) ^= THEN DO        /* If so, ASID must be omitted */
    WRITE ==> Error: ASID and ACTIVE are mutually exclusive keywords
    SET &RCODE=8                   /* Error return code           */
    GOTO EXIT
  END
  SET &MEM=ACTIVE                  /* Set subcommand keyword      */
  GOTO GOTASID                     /* Bypass ASID processing      */
END
/******************************************************************/
/* Process the ASID                                               */
/******************************************************************/
IF &ASID =   |                     /* No ASID specified or        */+
  &ASID=0 THEN                     /* specified ASID=0            */+
  DO
   EVALDEF CLIST(QUAL(DEFQUAL))    /* Get SETDEF qualification    */
   IF &SUBSTR(1:4,&DEFQUAL    ) = ASID THEN DO
    SET ASID = &SUBSTR(6:&LENGTH(&STR(&DEFQUAL))-1,&DEFQUAL)
    INTEGER &ASID UNS CLIST(S(ASID))
   END                             /* If ASID qualified, use it   */
   ELSE DO                         /* Otherwise...                */
    EVAL 2. HEADER LENGTH(2) UNS   /* Current ASID, if any        */+
            CLIST(S(ASID))         /* Save the value              */
   END
   IF &ASID=0 THEN DO              /* If absolute dump            */
    SET &ASID=1                    /* default to 1, else          */
   END                             /* use current virtual value   */
  END
ELSE                               /* Use specified value         */
SET &MEM=ASID(&ASID)               /* Set subcommand keyword      */
/******************************************************************/
/* Locate the ASVT and insure that the ASID is valid              */
/******************************************************************/
EQUATE ASVTADDR 4C.%+22C% PTR LE(4)/* Address of ASVT             */
EVAL ASVTADDR+204 LENGTH(4) UNS    /* Contents of ASVTMAXU        */+
     CLIST(S(ASVTMAXU))            /* Save the value              */
IF &ASID>&ASVTMAXU THEN            /* Insure valid ASID           */+
  DO
    WRITE ==> Error: &MEM is greater than max users (&ASVTMAXU)
    SET &RCODE=8                   /* Error return code           */
    GOTO EXIT
  END
ELSE                               /* Have valid ASID             */
/******************************************************************/
/* Insure that this memory is assigned                            */
/******************************************************************/
SET &ASVTOFFS=&ASID*4              /* Offset into entries of ASVT */
COMPARE ADDR(ASVTADDR+20C+&ASVTOFFS.N) /* Insure memory assigned  */+
  LENGTH(1) WITH(VALUE(X'80'))
IF &LASTCC=0 THEN                  /* Not assigned                */+
  DO
    WRITE ==> Error: &MEM is not assigned
    SET &RCODE=8                   /* Set return code             */
    GOTO EXIT
  END
ELSE                               /* Memory is assigned          */
/******************************************************************/
/* Set up the header and page control                             */
/******************************************************************/
GOTASID:+
NOTE '*************************************************************+
******' PAGE
IF &STR(&TCB) ^= THEN +
 NOTE '***    Display of all RB registers for &MEM TCB &TCB     ***' +
      ASIS
ELSE +
 NOTE '***    Display of all TCB and RB registers for &MEM  -
       ***' ASIS
NOTE '*************************************************************+
******'
/******************************************************************/
/* Locate the ASCB, ASXB, and 1st TCB for this memory             */
/******************************************************************/
SET &TCBCTR=1                      /* Count of TCBs               */
IF &STR(&TCB) ^= THEN DO
 EQ TCBADDR &TCB PTR &MEM LENGTH(4)
 EVALSYM TCBADDR CLIST(ADDR(TCBADDR))
 SET TCBADDR = &SUBSTR(3:8,&TCBADDR)
 GOTO PROCTCB
END
IF &ACTIVE = ACTIVE THEN           /* Get active ASCB address     */+
 EQ ASCBADDR 224.% ACTIVE          /* from current storage, or    */
ELSE                               /* get ASCB address for ASID   */+
 EQ ASCBADDR ASVTADDR+20C+&ASVTOFFS.N% &MEM  /* ASCB address      */
EVAL ASCBADDR+6C% L(4) &MEM        /* ASXB address                */
IF &LASTCC=12 THEN                 /* Must not be available       */+
  DO
    NOTE '==> Error: ASXB not available for &MEM' ASIS
    SET &RCODE=4                   /* Set return code             */
    GOTO EXIT
  END
ELSE                               /* ASXB storage is available   */
EQ ASXBADDR ASCBADDR+6C% PTR &MEM  /* Address of ASXB             */+
  LENGTH(4)
EVAL ASXBADDR+4% LENGTH(4) &MEM    /* 1st TCB address             */
IF &LASTCC=12 THEN                 /* Must not be available       */+
  DO
    NOTE '==> Error: TCB&TCBCTR not available for &MEM' ASIS
    SET &RCODE=4                   /* Set return code             */
    GOTO EXIT
  END
ELSE                               /* TCB storage is available    */
EVAL ASXBADDR+5  LENGTH(3) &MEM    /* Save the TCB address in a   */+
     CLIST(S(TCBADDR))             /*   symbolic variable         */
EQ TCBADDR ASXBADDR+4% PTR &MEM    /* TCB address                 */+
  LENGTH(4)
/******************************************************************/
/* Process all TCBs for this address space                        */
/******************************************************************/
PROCTCB:+
DO WHILE &TCBADDR^=0               /* Loop for all TCBs           */
  EQ TCB&TCBCTR TCBADDR STRUCTURE(TCB)
  NOTE '*** TCB&TCBCTR    --Display of general registers--' SPACE(2) ASI
  EVAL TCBADDR+30 L(64) HEX &MEM CLIST(S(REGISTERS))
  %SHOWREGS &REGISTERS
  NOTE SPACE(1)
  /****************************************************************/
  /* Find the 1st RB address for this TCB                         */
  /****************************************************************/
  SET &RBERR=0                     /* No RBs missing for this TCB */
  SET &RBCTR=1                     /* Initialize RB counter       */
  EVAL TCBADDR+1  L(3) &MEM        /* Save RB address in          */+
       CLIST(S(RBADDR))            /*   symbolic variable         */
  IF &LASTCC=12 THEN               /* If RB address not available */+
    DO
      NOTE '==> Error: RB&RBCTR not available for &MEM'
      SET &RCODE=4                 /* Set return code             */
      SET &RBERR=1                 /* Indicate break in RB chain  */
    END
  ELSE                             /* 1st RB is available         */
  EQ RBADDR TCBADDR+0% PTR &MEM L(4) /* RB address                */
  /****************************************************************/
  /* Process all RBs for this TCB                                 */
  /****************************************************************/
  DO WHILE &RBADDR^=&TCBADDR AND    /* Until last RB found  and   */+
    &RBERR=0                        /* RB chain not broken        */
    SET CDENAME = &STR(*None*)
    EVAL RBADDR-2 LEN(2) &MEM       /* Obtain contents of RBINTCOD*/+
         UNS CLIST(S(RBINTCOD))     /*   and save the value       */
    IF &LASTCC = 12 THEN DO
     NOTE 'Error: RBINTCOD for RB at &RBADDR not available' ASIS
     GOTO SKIPRB
    END
    COMPARE ADDRESS(RBADDR+A) LENGTH(1) &MEM /* Test for PRB      */+
      WITH(VALUE(X'00')) MASK(X'E0')
    IF &LASTCC=0 THEN +
      DO
        SET &RBTYPE=PRB
        COMPARE ADDR(RBADDR+C) LEN(4) &MEM /* Test for CDE address*/+
          WITH(VALUE(X'00000000')) MASK(X'00FFFFFF')
        IF &LASTCC=0 THEN
        ELSE +
          DO
            EVAL RBADDR+C%+8 LENGTH(8) CHAR &MEM CLIST(S(CDENAME))
            IF &LASTCC = 12 THEN SET CDENAME = &STR(*Unavailable*)
          END
      END
    ELSE +
      DO
        COMPARE ADDRESS(RBADDR+A) LE(1) &MEM /* Test for SVRB     */+
          WITH(VALUE(X'C0')) MASK(X'E0')
        IF &LASTCC=0 THEN +
          SET &RBTYPE=SVRB
        ELSE +
          DO
            COMPARE ADDRESS(RBADDR+A) LE(1) &MEM /* Test for TIRB */+
              WITH(VALUE(X'60')) MASK(X'E0')
            IF &LASTCC=0 THEN +
              SET &RBTYPE=TIRB
            ELSE +
              DO
                COMPARE ADDRESS(RBADDR+A) LE(1) &MEM /* IRB test  */+
                  WITH(VALUE(X'40')) MASK(X'E0')
                IF &LASTCC=0 THEN +
                  SET &RBTYPE=IRB
                ELSE +
                  DO
                    COMPARE ADDRESS(RBADDR+A) LE(1) &MEM /* SIRB   */+
                      WITH(VALUE(X'80')) MASK(X'E0')
                    IF &LASTCC=0 THEN +
                      SET &RBTYPE=SIRB
                    ELSE +
                      DO
                        NOTE '==> Error: RBFTP not recognizable'
                        SET &RCODE=4   /* Set return code          */
                        SET &RBTYPE=RB
                      END
                  END
              END
          END
      END
    INTEGER &RBINTCOD PTR(2) CLIST(S(RBINTHEX))
    EVAL RBADDR+10 L(4) CLIST(S(RBOPSW1))
    EVAL RBADDR+14 L(4) CLIST(S(RBOPSW2))
    SET RBSHORT = &STR(RB&RBCTR(&RBTYPE))
    SET RBHEADER = &STR(RB&RBCTR(&RBTYPE) +
                        IC(&RBINTCOD,X''&RBINTHEX'') +
                        PSW(&RBOPSW1 &RBOPSW2)
    IF &RBTYPE=RB THEN +
      NOTE '&RBSHORT  --No module name or non-recognizable RB--' SP AS
    IF &RBTYPE=PRB THEN +
     NOTE '&RBSHORT  Module name: &CDENAME' ASIS
/*  ELSE DO
     NOTE '*** &RBHEADER --General registers--' SP(1) ASIS
     EVAL RBADDR+20 L(64) HEX &MEM CLIST(S(REGISTERS))
     %SHOWREGS &REGISTERS
/*  END
    SET &RBCTR=&RBCTR+1            /* Plus 1 to RB counter        */

    COMPARE ADDR(RBADDR+B) LE(1) +
         WITH(VALUE(X'80')) MASK(X'80') /* Does NEXTRB point to TCB?
    IF &LASTCC = 0 THEN DO
     SET RBADDR = &STR(000000)
     SET RBERR = 2                 /* RB chain ended
    END
    ELSE DO
     EVAL RBADDR+1D LE(3) PTR CLIST(S(RBADDR))
     IF &LASTCC=12 THEN            /* If RB address not available */+
       DO
         NOTE '==> Error: RB&RBCTR not available for &MEM'
         SET &RCODE=4              /* Set return code             */
         SET &RBERR=1              /* RB chain now broken         */
       END                         /* Set return code             */
     ELSE
     EQ RBADDR RBADDR+1C% PTR &MEM /* Next RB address            */+
        LENGTH(4)
    END

SKIPRB:+
  END                              /* End of RB loop              */
  IF &STR(&TCB) ^= THEN GOTO EXIT  /* If only 1 TCB wanted, quit  */
  SET &TCBCTR=&TCBCTR+1            /* Plus 1 to TCB counter       */
  EVAL TCBADDR+75 L(3) &MEM        /* Save next TCB address in    */+
       CLIST(S(TCBADDR))           /*   symbolic variable         */
  IF &LASTCC=12 THEN               /* If TCB address not available*/+
    DO
      NOTE '==> Error: TCB&TCBCTR not available for &MEM'
      SET &RCODE=4
      GOTO EXIT
    END
  ELSE
  EQ TCBADDR TCBADDR+74% PTR &MEM  /* Next TCB address            */+
    LENGTH(4)
END                                /* End of TCB loop             */
/******************************************************************/
/* Cleanup and exit here                                          */
/******************************************************************/
EXIT: NOTE SPACE(1)
EXIT CODE(&RCODE)
./ ADD NAME=LISTSIOT
PROC 0 TCB() ACTIVE XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
/* Code to extract current TCB
IF &STR(&TCB) = THEN DO
 SET TCB = 0
 EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))
 IF &TCB = 0 THEN DO
  EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))
  IF &TCB = 0 THEN DO
   EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))
   IF &TCB = 0 THEN DO
    NOTE 'TCB unavailable' ASIS
    EXIT C(12) Q
   END
  END
 END
END
IF &SYSINDEX(.,&TCB) = 0 THEN SET TCB = &STR(&TCB..)
/* End code to extract current TCB
EVAL &TCB+B4 L(4) &ACTIVE CLIST(STORAGE(JSCB)
IF &LASTCC = 12 THEN DO
 NOTE 'Error: JSCB pointer in TCB at &TCB could not be accessed.' ASIS
 EXIT C(12) Q
END
IF &JSCB = 0 THEN DO
 NOTE 'TCB at &TCB has no JSCB.' ASIS
 EXIT C(12) Q
END
EVAL &JSCB..+148 L(4) &ACTIVE CLIST(STORAGE(SCT))
IF &LASTCC = 12 THEN DO
 NOTE 'Error: SCT pointer in JSCB at &JSCB cannot be accessed.' ASIS
 EXIT C(12) Q
END
IF &SCT = 0 THEN DO
 NOTE 'JSCB at &JSCB has no SCT.' ASIS
 EXIT C(12) Q
END
EVAL &SCT..+10+C L(3) PTR &ACTIVE CLIST(STORAGE(SIOT))
IF &LASTCC = 12 THEN DO
 NOTE 'Error: SIOT pointer in SCT at &SCT cannot be accessed.' ASIS
 EXIT C(12) Q
END
IF &SIOT = 0 THEN DO
 NOTE 'SCT at &SCT has no SIOT.' ASIS
 EXIT C(12) Q
END
ERROR DO
 WRITE LASTCC = &LASTCC
 WRITE SUBCOMMAND = &STR(&SYSPCMD)
 RETURN
END
NOTE SPACE(1)
NOTE 'SIOT ADDR--DDNAME---VOL---DEV--JFCB ADDR--DSNAME' ASIS
NOTE SPACE(1)
INTEGER X'&SIOT' UNS CLIST(S(SIOTN))
INTEGER &EVAL(&SIOTN+16) PTR CLIST(S(SIOT))
DO UNTIL &SIOT = 0
 EVAL &SIOT..+04         L(8)  CHAR &ACTIVE CLIST(STORAGE(DDNAME))
 EVAL &SIOT..+20         L(3)  UNSI &ACTIVE CLIST(STORAGE(JFCBPTRN))
 INTEGER &EVAL(&JFCBPTRN+16)   PTR          CLIST(STORAGE(JFCBPTR))
 EVAL &JFCBPTR..+0       L(44) CHAR &ACTIVE CLIST(STORAGE(DSNAME))
 EVAL &JFCBPTR..+2C      L(8)  CHAR &ACTIVE CLIST(STORAGE(MEMBER))
 EVAL &JFCBPTR..+76      L(6)  CHAR &ACTIVE CLIST(STORAGE(VOLSER))
 EVAL &SIOT..+40         L(1)  UNS  &ACTIVE CLIST(STORAGE(SIOUCNVT)
 SET UNIT = &STR(   )
 IF &SIOUCNVT = 0 THEN DO
  EVAL &SIOT..+41        L(3)  PTR  &ACTIVE CLIST(STORAGE(UCBPTR))
  IF &UCBPTR ^= 0 THEN DO
   EVAL &UCBPTR..+D      L(3)  CHAR &ACTIVE CLIST(STORAGE(UNIT))
  END
 END
 SET SYSDVAL = &NRSTR(&DSNAME &MEMBER)
 READDVAL DSNAME MEMBER
 IF &NRSTR(&MEMBER) ^= THEN SET DSNAME = &NRSTR(&DSNAME(&MEMBER))
 INTEGER X'&SIOT'    PTR LENGTH(8) CLIST(S(SIOT8))
 INTEGER X'&JFCBPTR' PTR LENGTH(6) CLIST(S(JFCB8))
 NOTE '&NRSTR(&SIOT8  &DDNAME &VOLSER &UNIT  &JFCB8 &DSNAME)' ASIS
 EVAL &SIOT..+98 L(4) CLIST(S(SIOT))
END
EXIT
./ ADD NAME=LISTTIOT
PROC 0 TCB() ACTIVE XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
/* Code to extract current TCB
IF &STR(&TCB) = THEN DO
 SET TCB = 0
 EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))
 IF &TCB = 0 THEN DO
  EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))
  IF &TCB = 0 THEN DO
   EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))
   IF &TCB = 0 THEN DO
    NOTE 'TCB unavailable' ASIS
    EXIT C(12) Q
   END
  END
 END
END
IF &SYSINDEX(.,&TCB) = 0 THEN SET TCB = &STR(&TCB..)
/* End code to extract current TCB
EVAL &TCB+D L(3) &ACTIVE CLIST(STORAGE(TIOTPTR))
IF &LASTCC = 12 THEN DO
 NOTE 'Error: TIOT pointer in TCB at &TCB could not be accessed.' ASIS
 EXIT C(12) Q
END
IF &TIOTPTR = 0 THEN DO
 NOTE 'TCB at &TCB has no TIOT.' ASIS
 EXIT C(12) Q
END
EVAL &TIOTPTR.. L(24) CHAR CLIST(S(TIOTDATA))
IF &LASTCC = 12 THEN DO
 NOTE 'Error: TIOT data at &TIOTPTR could not be accessed.' ASIS
 EXIT C(12) Q
END
SET JOBNAME  = &SUBSTR( 1: 8,&NRSTR(&TIOTDATA))
SET STEPNAME = &SUBSTR( 9:16,&NRSTR(&TIOTDATA))
SET PROCSTEP = &SUBSTR(17:24,&NRSTR(&TIOTDATA))
INTEGER X'&TIOTPTR' UNSIGNED CLIST(STORAGE(TIOTPTRN))
SET TIOTENTRYPTRN = &TIOTPTRN+24
NOTE SPACE(1)
NOTE '*** TIOT at &TIOTPTR - Jobname=&JOBNAME +
     Stepname=&STEPNAME Procstep=&PROCSTEP ***' ASIS
NOTE SPACE(1)
CONTINUE:+
INTEGER &TIOTENTRYPTRN POINTER CLIST(STORAGE(TIOTENTRYPTR))
EVAL &TIOTENTRYPTR.. L(20) HEX &ACTIVE CLIST(STORAGE(TIOTENTRY))
SET TIOTLENGTH = &SUBSTR(1:2,&TIOTENTRY)
INTEGER X'&TIOTLENGTH' UNSIGNED CLIST(STORAGE(TIOTLENGTH))
IF &TIOTLENGTH = 0 THEN GOTO END
SET TIOESSTA = &SUBSTR(3,&TIOTENTRY)
IF &TIOESSTA >= 0 AND &TIOESSTA <= 7 THEN DO
 EVAL &TIOTENTRYPTR..+4  L(8)  CHAR &ACTIVE CLIST(STORAGE(DDNAME))
 EVAL &TIOTENTRYPTR..+11 L(3)  PTR  &ACTIVE CLIST(STORAGE(UCBPTR))
 EVAL &TIOTENTRYPTR..+C  L(3)  UNSI &ACTIVE CLIST(STORAGE(JFCBPTRN))
 INTEGER &EVAL(&JFCBPTRN+16)   PTR          CLIST(STORAGE(JFCBPTR))
 EVAL &JFCBPTR..+0       L(44) CHAR &ACTIVE CLIST(STORAGE(DSNAME))
 EVAL &JFCBPTR..+2C      L(8)  CHAR &ACTIVE CLIST(STORAGE(MEMBER))
 EVAL &JFCBPTR..+76      L(6)  CHAR &ACTIVE CLIST(STORAGE(VOLSER))
 EVAL &UCBPTR..+D        L(3)  CHAR &ACTIVE CLIST(STORAGE(UNIT))
 SET SYSDVAL = &NRSTR(&DSNAME &MEMBER)
 READDVAL DSNAME MEMBER
 IF &NRSTR(&MEMBER) ^= THEN SET DSNAME = &NRSTR(&DSNAME(&MEMBER))
 NOTE '&NRSTR(&DDNAME &VOLSER &UNIT &DSNAME)' ASIS
 IF &LASTCC ^= 0 THEN GOTO END
END
SET TIOTENTRYPTRN = &TIOTENTRYPTRN + &TIOTLENGTH
GOTO CONTINUE
END:+
EXIT
./ ADD NAME=MAP
PROC 0 XTRACE TCBADDRESS(0.) LIBRARY(SYSPGMR.CMD.LOAD)
/***********************************************************************
/*                                                                     *
/* Author: S. BACHER                                                   *
/*                                                                     *
/***********************************************************************
IF &XTRACE=XTRACE THEN CONTROL CONLIST SYMLIST LIST MSG
IF &STR(&SYSPCMD) = IPCS THEN DO
 /* VERBEXIT XIPMAP
 TCBEXIT XITMAP &TCBADDRESS
END
ELSE DO
 XCMD /XIPMAP/ LIB('&LIBRARY') NOF
END
./ ADD NAME=NOTEPAD
PROC 0 +
       XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
EVALSYM IPCSNOTEPADCOUNT CLIST(DEC LEN(COUNT))
IF &COUNT = THEN DO
 NOTE '*** Note pad empty ***' ASIS
END
ELSE DO
 SET N = 0
 DO WHILE &N LE &COUNT
  EVALSYM IPCSNOTEPAD&N CLIST(ENQUOTE REMARK(NOTE))
  NOTE &NRSTR(&NOTE) ASIS
  SET N = &N+1
 END
END
./ ADD NAME=NOTES
PROC 0 XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
SET N = 0
EVALSYM IPCSNOTEPADCOUNT CLIST(DEC LEN(N))
IF &N = THEN SET N = 0
SET N = &N+1
EQ IPCSNOTEPAD&N 0. REMARK(+
'--------- &SYSUID - &SYSDATE - &SYSSTIME ----------'+
)
WRITE No more than 80 chars per line, please.  Hit ENTER when finished.
LOOP:+
WRITENR >
READ
IF &LENGTH(&NRSTR(&SYSDVAL)) = 0 THEN GOTO FINISH
IF &LENGTH(&NRSTR(&SYSDVAL)) > 80 THEN DO
 WRITE Input too long; reenter.
 GOTO LOOP
END
SET N = &N+1
SET I = 0
SET L = &LENGTH(&NRSTR(&SYSDVAL))
SET MSG =
DO WHILE &I LT &L
 SET I = &I+1
 SET C = &SUBSTR(&I,&NRSTR(&SYSDVAL))
 IF &NRSTR(&C) = ' THEN SET MSG = &NRSTR(&MSG)''
 ELSE SET MSG = &NRSTR(&MSG&C)
END
EQ IPCSNOTEPAD&N 0. REMARK('&NRSTR(&MSG)')
GOTO LOOP
FINISH:+
EQ IPCSNOTEPADCOUNT 0. LENGTH(&N)
END
./ ADD NAME=PIEMAP
PROC 0 TCB() FORCE ACTIVE DUMP XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
/* Code to extract current TCB
IF &STR(&TCB) = THEN DO
 SET TCB = 0
 EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))
 IF &TCB = 0 THEN DO
  EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))
  IF &TCB = 0 THEN DO
   EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))
   IF &TCB = 0 THEN DO
    NOTE 'TCB unavailable' ASIS
    EXIT C(12) Q
   END
  END
 END
END
IF &SYSINDEX(.,&TCB) = 0 THEN SET TCB = &STR(&TCB..)
/* End code to extract current TCB

SET TCBJSTCB = 00000000
SYSCALL ISET TCBJSTCB &TCB+7C L(4) PTR &ACTIVE
SET TCBOTC =
SYSCALL ISET TCBOTC &TCBJSTCB..+84 L(4) PTR &ACTIVE
IF &TCBOTC = 0 THEN DO
 NOTE 'PIE is not active in this environment.' ASIS
 EXIT C(4)
END
SET PIETCB = &STR(&TCBOTC..)
SET TCBUSER = 00000000
SYSCALL ISET TCBUSER &PIETCB+A8 L(4) PTR &ACTIVE
SET SCVT = &STR(&TCBUSER..)
IF &STR(&TCBUSER) = &STR(00000000) THEN DO
 NOTE 'TCB at &PIETCB has no TCBUSER (i.e. PIE SCVT) field.' ASIS
 NOTE 'Try another TCB, maybe.' ASIS
 EXIT C(4)
END
SET SCVT_EYECATCHER = &STR(something other than C'SCVT')
SYSCALL ISET SCVT_EYECATCHER &SCVT+0 L(4) CHAR &ACTIVE
NOTE '---- PIE SCVT at &SCVT ----' ASIS SPACE(1)
NOTE SPACE(1)
IF &STR(&SCVT_EYECATCHER) ^= SCVT THEN DO
 NOTE +
 'Warning:  SCVT eyecatcher not SCVT, but &NRSTR(&SCVT_EYECATCHER)' +
      ASIS
 NOTE SPACE(1)
END
SET SWKEY =
SYSCALL ISET SWKEY  &SCVT+A2 L(4) CHAR &ACTIVE
SET SWCHAR =
SYSCALL ISET SWCHAR &SCVT+A7 L(1) CHAR &ACTIVE
SET JMKEY =
SYSCALL ISET JMKEY  &SCVT+310 L(4) CHAR &ACTIVE

NOTE '    Switch Key .......... &NRSTR(&SWKEY)'     ASIS
NOTE '    Switch Character .... "&NRSTR(&SWCHAR)"'  ASIS
NOTE '    Jump Key ............ &NRSTR(&JMKEY)'     ASIS

/**********************************************************************/
/*                                                                    */
/* Chain through the STCB's.                                          */
/*                                                                    */
/**********************************************************************/

SET SCVT_STCB_POINTER =
IF &FORCE = FORCE THEN SET FIRST_STCB = N
ELSE SET FIRST_STCB = Y
SYSCALL ISET SCVT_STCB_POINTER &SCVT+4 L(4) PTR &ACTIVE
DO WHILE &SCVT_STCB_POINTER ^= 0
 SET STCB = &STR(&SCVT_STCB_POINTER..)
 SET STCB_EYECATCHER = &STR(something other than C'STCB')
 SYSCALL ISET STCB_EYECATCHER &STCB+0 L(4) CHAR &ACTIVE
 IF &STR(&STCB_EYECATCHER) ^= STCB THEN DO
  NOTE +
  'Warning:  STCB eyecatcher not STCB, but &NRSTR(&STCB_EYECATCHER)' +
       ASIS
  NOTE SPACE(1)
 END
 NOTE SPACE(1)

 SET TCB = 000000
 SYSCALL ISET TCB &STCB+D L(3) PTR &ACTIVE
 SYSCALL DO_TCB_STUFF &TCB &ACTIVE &DUMP
 IF &LASTCC = 0 THEN SET STATUS = active
 ELSE SET STATUS = pending

 SET SESSION_ID =
 SYSCALL ISET SESSION_ID &STCB+84 L(1) CHAR &ACTIVE
 SET SESSION_ID_HEX =
 SYSCALL ISET SESSION_ID_HEX &STCB+84 L(1) HEX &ACTIVE
 IF &FIRST_STCB = Y THEN DO
  SET FIRST_STCB = N
  NOTE 'Warning:  First STCB in chain not shown, probably invalid.' ASIS
 END
 ELSE DO
  NOTE '---- PIE STCB at &STCB ---- +
        Session number &SESSION_ID (X''&SESSION_ID_HEX'') is &STATUS' +
       ASIS
  NOTE SPACE(1)

  SET PTCB =
  SYSCALL ISET PTCB &STCB+C L(4) PTR &ACTIVE NOCHECK

  SET PECT =
  SYSCALL ISET PECT &STCB+10 L(4) PTR &ACTIVE NOCHECK

  IF &STR(&PECT) ^= &STR(00000000) THEN DO
   SET PCMD =
   SYSCALL ISET PCMD &PECT.+C L(8) CHAR &ACTIVE NOCHECK
  END
  ELSE SET PCMD = &STR(********)

  SET NOTE =
  SYSCALL ISET NOTE &STCB+A2 L(100) CHAR &ACTIVE NOCHECK

  NOTE 'TCB...&NRSTR(&PTCB)   ECT...&NRSTR(&PECT)   +
       Command: &NRSTR(&PCMD)' ASIS
  NOTE 'Note:    &NRSTR(&NOTE)' ASIS SPACE(1)

 END

 IF &DUMP = DUMP THEN DO
  %DUMPCB STCB &STCB X'330'
 END

 /* get next STCB...
 SYSCALL ISET SCVT_STCB_POINTER &STCB+4 L(4) PTR &ACTIVE

END

/**********************************************************************/
/*                                                                    */
/* Chain through daughters of the PIE TCB.  These should all be       */
/* job step TCB's for the TMP.  This is probably not necessary to     */
/* do, because they won't tell us anything the STCB's won't tell us.  */
/*                                                                    */
/**********************************************************************/
/*
/*  SET TCB =
/*  SYSCALL ISET TCB &PIETCB+89 L(3) PTR &ACTIVE
/*  DO WHILE &TCB ^= 0
/*   SYSCALL DO_TCB_STUFF &TCB &ACTIVE &DUMP
/*   /* get next (sister) TCB ...
/*   SYSCALL ISET TCB &TCB..+81 L(3) PTR &ACTIVE
/*  END

NOTE SPACE(1)
EXIT

ISET: PROC 2 CLISTVAR FIELD ACTIVE NOCHECK +
             LENGTHVALUE(4) PTR POINTER SIGNED UNSIGNED CHARACTER HEX
 SET TITLE = &STR(&CLISTVAR) /* before SYSREFfing
 SYSREF CLISTVAR
 SET PREVIOUS_VALUE = &NRSTR(&CLISTVAR)
 IF &SYSINDEX(.,&FIELD) = 9 THEN DO
  SYSCALL FIXUP FIELD
 END
 EVAL &FIELD L(&LENGTHVALUE) &PTR &POINTER &SIGNED &UNSIGNED +
                             &CHARACTER &HEX &ACTIVE +
      CLIST(S(CLISTVAR))
 IF &LASTCC ^= 0 THEN DO
  NOTE 'Error: &NRSTR(&TITLE) at &NRSTR(&FIELD) not accessible.' ASIS
  EXIT C(12) Q
 END
 IF &NOCHECK = THEN DO
  IF &NRSTR(&CLISTVAR) = &NRSTR(&PREVIOUS_VALUE) THEN DO
   NOTE +
 'Error: &NRSTR(&TITLE) at &NRSTR(&FIELD) is &NRSTR(&PREVIOUS_VALUE).' +
        ASIS
   EXIT C(12) Q
  END
 END
 RETURN
END

FIXUP: PROC 1 AFIELD
 SYSREF AFIELD
 SET I = &SYSINDEX(&SUBSTR(1,&AFIELD),89ABCDEF)
 IF &I ^= 0 THEN DO
  SET AFIELD = +
      &SUBSTR(&I,01234567)&SUBSTR(2:&LENGTH(&STR(&AFIELD)),&AFIELD)
 END
END

DO_TCB_STUFF: PROC 1 TCB ACTIVE DUMP
 SET RB = 000000
 SYSCALL ISET RB &TCB..+1 L(3) PTR &ACTIVE
 SET HERE = &STR(TCB &TCB and RB &RB)
 SET CDE =
 SYSCALL ISET CDE &RB..+D L(3) PTR &ACTIVE
 IF &CDE = 0 THEN DO
  IF &DUMP ^= THEN DO
   NOTE 'CDE for &HERE does not exist.  Inactive PIE session.' ASIS
  END
  RETURN CODE(4)
 END
 ELSE DO
  SET CDENAME =
  SYSCALL ISET CDENAME &CDE..+8 L(8) CHAR &ACTIVE
  IF &DUMP ^= THEN DO
   NOTE 'CDE for &HERE is &NRSTR(&CDENAME).' ASIS
  END
  RETURN CODE(0)
 END
END
./ ADD NAME=QUOTE
/* The following function enquotes a string. */
quote:
parse arg string
ix = 1
do forever
 ix = pos("'",string,ix)
 if ix = 0 then return "'"string"'"
 string = insert("'",string,ix)
 ix=ix+2
end
./ ADD NAME=REGS
PROC 0 RBADDR() TCBADDR() XTRACE
/***********************************************************************
/*                                                                     *
/* Author: S. BACHER                                                   *
/*                                                                     *
/***********************************************************************
IF &XTRACE=XTRACE THEN CONTROL CONLIST SYMLIST LIST MSG
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
IF &STR(&RBADDR&TCBADDR) = THEN DO
 EVALSYM REGS CLIST(S(DUMMY))
 IF &LASTCC ^= 0 THEN DO
  NOTE +
  'REGS not defined - issue REGS RB(rbaddress) or TCB(tcbaddress).' +
       ASIS
  EXIT C(0)
 END
 EVALSYM RB CLIST(ADDRESS(RBADDR))
 EVALSYM TCB CLIST(ADDRESS(TCBADDR))
 IF &RBADDR ^= && &TCBADDR ^= THEN DO
  NOTE 'Both RB and TCB defined, using RB.' ASIS
  SET TCBADDR =
 END
 SET REGNO = 0
 SET I = 1
 DO WHILE &REGNO < 16
  EVAL R&REGNO LE(4) CLIST(S(REG&REGNO))
  SET REGNO = &REGNO+1
 END
 IF &STR(&RBADDR) ^= THEN +
 NOTE 'Registers for RB at &RBADDR..' ASIS
 ELSE +
 NOTE 'Registers for TCB at &TCBADDR..' ASIS
END
ELSE IF &STR(&TCBADDR) ^= THEN DO
 SET L = &LENGTH(&STR(&TCBADDR))
 IF &SUBSTR(&L,&TCBADDR) = . THEN SET TCBADDR = &SUBSTR(1:&L-1,&TCBADDR)
 EQ TCB &TCBADDR.. STRUCTURE(TCB)
 SET TCBREGS = &STR(XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+
                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+
                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+
                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+
                    )
 INTEGER X'&TCBADDR' UNSIGNED CLIST(S(DECIMALTCBADDR))
 SET DECREGADDR = &DECIMALTCBADDR+48
 INTEGER &DECREGADDR PTR CLIST(S(TCBREGADDR))
 EVAL &TCBREGADDR.. LE(64) HEX CLIST(S(TCBREGS))
 EQ REGS &TCBREGADDR.. LE(64)
 SET REGNO = 0
 SET I = 1
 DO WHILE &REGNO < 16
  SET REG&REGNO = &SUBSTR(&I:&I+7,&TCBREGS)
  INTEGER &DECREGADDR PTR CLIST(S(REGADDR))
  EQ R&REGNO &REGADDR.. LE(4)
  STACK &REGADDR..? REMARK('Register &REGNO (TCB=&TCBADDR..)')
  SET I = &I+8
  SET REGNO = &REGNO+1
  SET DECREGADDR = &DECREGADDR+4
 END
 NOTE 'Registers for TCB at &TCBADDR..' ASIS
END
ELSE DO
 SET L = &LENGTH(&STR(&RBADDR))
 IF &SUBSTR(&L,&RBADDR) = . THEN SET RBADDR = &SUBSTR(1:&L-1,&RBADDR)
 EQ RB &RBADDR.. STRUCTURE(RB)
 SET RBREGS = &STR(XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+
                   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+
                   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+
                   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+
                   )
 INTEGER X'&RBADDR' UNSIGNED CLIST(S(DECIMALRBADDR))
 SET DECREGADDR = &DECIMALRBADDR+32
 INTEGER &DECREGADDR PTR CLIST(S(RBREGADDR))
 EVAL &RBREGADDR.. LE(64) HEX CLIST(S(RBREGS))
 EQ REGS &RBREGADDR.. LE(64)
 SET REGNO = 0
 SET I = 1
 DO WHILE &REGNO < 16
  SET REG&REGNO = &SUBSTR(&I:&I+7,&RBREGS)
  INTEGER &DECREGADDR PTR CLIST(S(REGADDR))
  EQ R&REGNO &REGADDR.. LE(4)
  STACK &REGADDR..? REMARK('Register &REGNO (RB=&RBADDR..)')
  SET I = &I+8
  SET REGNO = &REGNO+1
  SET DECREGADDR = &DECREGADDR+4
 END
 NOTE 'Registers for RB at &RBADDR..' ASIS
END
NOTE SPACE(1)
NOTE &STR(' R0 = &REG0  R1 = &REG1  R2 = &REG2  R3 = &REG3')
NOTE &STR(' R4 = &REG4  R5 = &REG5  R6 = &REG6  R7 = &REG7')
NOTE &STR(' R8 = &REG8  R9 = &REG9  R10= &REG10  R11= &REG11')
NOTE &STR(' R12= &REG12  R13= &REG13  R14= &REG14  R15= &REG15')
NOTE SPACE(1)
EXIT
./ ADD NAME=REXXCB
PROC 0 ECT(ECT) TCB(21C.?) XTRACE
NGLOBAL ENVBLOCK_P ECTEXT_P PARMBLOCK_P WORKBLOCKEXTENSION_P +
        MODNAMET_P SUBCOMTB_P PACKTB_P EXECBLK_P INSTBLK_P EVALBLOCK_P
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOFLUSH NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
 WRITE *** You must be in IPCS to use this CLIST. ***
 EXIT C(16) Q
END

NOTE SPACE(1)

IF &XTRACE = THEN CONTROL NOMSG
DROPSYM (ENVBLOCK ECTEXT PARMBLOCK WORKBLOCKEXTENSION +
         MODNAMET SUBCOMTB PACKTB EXECBLK INSTBLK EVALBLOCK) NOSUMMARY
CONTROL MSG

SYSCALL BLOCK ENVBLOCK            &ECT.+30                L(288)
SYSCALL BLOCK ECTEXT              &ECT.+34                L(256)
IF &ENVBLOCK_P = Y THEN DO
 SYSCALL BLOCK PARMBLOCK           ENVBLOCK+10             L(64)
 SYSCALL BLOCK WORKBLOCKEXTENSION  ENVBLOCK+18             L(32)
 IF &PARMBLOCK_P = Y THEN DO
  SYSCALL BLOCK MODNAMET            PARMBLOCK+10            L(112)
  SYSCALL BLOCK SUBCOMTB            PARMBLOCK+14            L(36)
  SYSCALL BLOCK PACKTB              PARMBLOCK+18            L(48)
 END
 IF &WORKBLOCKEXTENSION_P = Y THEN DO
  SYSCALL BLOCK EXECBLK             WORKBLOCKEXTENSION+00   L(48)
  SYSCALL BLOCK INSTBLK             WORKBLOCKEXTENSION+0C   L(128)
  SYSCALL BLOCK EVALBLOCK           WORKBLOCKEXTENSION+14   L(256)
 END
END

LISTSYM (ENVBLOCK ECTEXT PARMBLOCK WORKBLOCKEXTENSION +
         MODNAMET SUBCOMTB PACKTB EXECBLK INSTBLK EVALBLOCK)

NOTE SPACE(1)

SYSCALL LIST ENVBLOCK
SYSCALL LIST ECTEXT
SYSCALL LIST PARMBLOCK
SYSCALL LIST WORKBLOCKEXTENSION
SYSCALL LIST MODNAMET
SYSCALL LIST SUBCOMTB
SYSCALL LIST PACKTB
SYSCALL LIST EXECBLK
SYSCALL LIST INSTBLK
SYSCALL LIST EVALBLOCK
NOTE SPACE(1)
NOTE 'End of REXX control block listing.' ASIS
NOTE SPACE(1)

BLOCK: PROC 2 BLOCKNAME BLOCKADDRESS LENGTHVALUE(256)
EVAL &BLOCKADDRESS L(4) HEX CLIST(S(BLOCKTEST))
IF &STR(&BLOCKTEST) = &STR(00000000) THEN DO
 NOTE 'There is no &BLOCKNAME (the pointer at &BLOCKADDRESS is zero).' +
      ASIS
 SET &&BLOCKNAME._P = N
END
ELSE DO
 EQ &BLOCKNAME &BLOCKADDRESS.? L(&LENGTHVALUE)
 SET &&BLOCKNAME._P = Y
END
RETURN
END BLOCK

LIST: PROC 1 LBLOCK
IF &SYSNSUB(2,&&&LBLOCK._P) = Y THEN DO
 NOTE SPACE(1)
 L &LBLOCK MODULE DISPLAY(NOREQUEST)
END
RETURN
END LIST
./ ADD NAME=RTM

/**********************************************************************/
/*                                                                    */
/* Updated for ESA.  RTM2WA now above the line.                       */
/*                                                                    */
/**********************************************************************/

PROC 0 TCB() RTWA() ACTIVE XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
IF &NRSTR(&RTWA) ^= THEN DO
 SET RTWAPTR = &NRSTR(&RTWA)
 SET X = &SYSINDEX(.,&NRSTR(&RTWAPTR))
 IF &X = 0 THEN SET RTWAPTR = &RTWAPTR
 ELSE SET RTWAPTR = &SUBSTR(1:&X,&NRSTR(&RTWAPTR))
 GOTO PROCESS
END
/* Code to extract current TCB
IF &STR(&TCB) = THEN DO
 SET TCB = 0
 EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))
 IF &TCB = 0 THEN DO
  EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))
  IF &TCB = 0 THEN DO
   EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))
   IF &TCB = 0 THEN DO
    NOTE 'TCB unavailable' ASIS
    EXIT C(12) Q
   END
  END
 END
 SET TCB = &STR(&TCB..)
END
/* End code to extract current TCB
EVAL &TCB+E0 L(4) &ACTIVE CLIST(STORAGE(RTWAPTR))
IF &LASTCC = 12 THEN DO
 NOTE 'Error: RTWA pointer in TCB at &TCB could not be accessed.' ASIS
 EXIT C(12) Q
END
IF &RTWAPTR = 0 THEN DO
 NOTE 'TCB at &TCB has no RTM.' ASIS
 EXIT C(12) Q
END
PROCESS:+
EQ RTM2WA &RTWAPTR.. L(1308)
NOTE SPACE(1)
NOTE 'RTM2WA at &RTWAPTR..' ASIS
NOTE SPACE(1)
CONTROL NOFLUSH
SET SUBCMD =
ERROR DO
 SET CC = &LASTCC
 IF &SUBCMD = EVALSYM THEN RETURN
 ERROR OFF
 IF &CC = 12 THEN DO
  NOTE 'Error accessing RTM2WA storage for RTWA at &RTWAPTR..' ASIS
  WRITE *** Severe error - LASTCC = &CC
  EXIT C(12) Q
 END
END
EVAL RTM2WA+0 L(4) CHAR CLIST(S(TEMP))
IF &STR(&TEMP) NE RTM2 THEN DO
 NOTE 'Error: RTM work area not equal to C''RTM2'', but ''&TEMP''' ASIS
END
EVAL RTM2WA+10 L(4) HEX CLIST(S(RTCB))
EVAL RTM2WA+14 L(4) HEX CLIST(S(RSVRB))
NOTE 'TCB for this RTWA is at &RTCB., SVRB is at &RSVRB..'  ASIS
NOTE SPACE(1)
EVAL RTM2WA+1C L(4) HEX CLIST(S(TEMP))
NOTE 'Completion code..........&TEMP'   ASIS
EVAL RTM2WA+7C L(8) HEX CLIST(S(TEMP))
NOTE 'PSW.............&SUBSTR(1:8,&TEMP) &SUBSTR(9:16,&TEMP)' ASIS
NOTE SPACE(1)
SET NSI = &SUBSTR(9:16,&TEMP)
%WHERE &NSI.. STACK ID('ABEND LOCATION (RTWA=&RTWAPTR)')
NOTE SPACE(1)
EVAL RTM2WA+3C L(64) HEX CLIST(S(TEMP))
NOTE 'Registers at time of abend....'   ASIS
SET CC = 0
SET SUBCMD = EVALSYM
EVALSYM RTMREGSAT&RTWAPTR
SET SUBCMD =
IF &CC ^= 0 THEN DO
 %SHOWREGS &TEMP STACK(RTM2WA+3C) ID(RTWA=&RTWAPTR)
 EQ RTMREGSAT&RTWAPTR &RTWAPTR..
END
ELSE DO
 %SHOWREGS &TEMP /* Don't stack - already done */
END
EVAL RTM2WA+8C L(8) CHAR CLIST(S(TEMP))
NOTE 'Abending program name:  &TEMP' ASIS
EVAL RTM2WA+94 L(4) PTR  CLIST(S(TEMP))
NOTE 'Entry point of above:   &TEMP' ASIS
NOTE SPACE(1)
SET I = 0
SET A = &SUBSTR(1,&NSI)
DO WHILE &I LT 8
 SET I = &I + 1
 IF &A = &SUBSTR(&I,89ABCDEF) THEN DO
  SET NSI = &SUBSTR(&I,01234567)&SUBSTR(2:8,&NSI)
  GOTO DOIT
 END
END
DOIT:+
ERROR OFF
%DUMPCB INSTRUCTIONS_PRECEDING_PSW_ADDRESS &NSI..-20 32 OFFSET(-32) +
        TITLE('Instructions preceding PSW address')
%DUMPCB INSTRUCTIONS_FOLLOWING_PSW_ADDRESS &NSI..    32 +
        TITLE('Instructions following PSW address')
EXIT
./ ADD NAME=RUNSAVE
PROC 0 FIRSTADDR(&TCBADDR.+70%) TCBADDR(21C.%)
/***********************************************************************
/*                                                                     *
/* AUTHOR: S. BACHER                                                   *
/*                                                                     *
/* THIS CLIST DEFINES ALL SAVE AREAS IN THE CURRENT SAVE AREA CHAIN    *
/* STARTING FROM THE TCB'S SAVE AREA FIELD.                            *
/*                                                                     *
/* (SAVEAREA001, SAVEAREA002, ETC.)                                    *
/*                                                                     *
/* THIS IS THE ORIGINAL "SAVEAREA" CLIST; THE NEW "SAVEAREA" CLIST     *
/* IS AN IPCS VERB EXIT INTERFACE WHICH GIVES MORE INFORMATION.        *
/*                                                                     *
/***********************************************************************
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** YOU MUST BE IN IPCS TO USE THIS CLIST. ***
  EXIT C(16) Q
END
RUNCHAIN ADDR(&FIRSTADDR) LINK(8) NAME(SAVEAREA) LENGTH(72)
./ ADD NAME=S
/* REXX */
if sysvar("syspcmd") \= "IPCS" then do
 say "*** You must be in IPCS to use this exec. ***"
 exit 16
end
address TSO
arg dumpdataset argjunk
new = abbrev("NEW",argjunk,1)
do while dumpdataset = "?" | dumpdataset = ""
 "%X SYSDSCAN | %GREP -vi ' IS EMPTY'"
 call xwritenr "Enter dump data set number (or name) ==>"
 parse external dumpdataset
end
if datatype(dumpdataset,"W") then
 dump = "'SYS1.DUMP" || right(dumpdataset,2,"0") || "'"
else
 dump = dumpdataset
if new then queue "DROPDUMP DATASET("dump")"
x = listdsi(dump)
if x > 0 then do
 say dump" not available.  Reason:"
 say sysmsglvl2
 exit
end
if syslrecl \= 4160 then do
 say "Can't use "dump", LRECL not 4160."
 exit
end
if \abbrev(sysrecfm,"F") then do
 say "Can't use "dump", RECFM not fixed."
 exit
end
queue "SETDEF DSN("dump") LEN(32) FLAG(ERROR) TERMINAL NOPRINT NOCONFIR"
queue "%HEADER"
./ ADD NAME=SA
PROC 0 TCB() ADDRESS() XTRACE
/***********************************************************************
/*                                                                     *
/* Author: S. BACHER                                                   *
/*                                                                     *
/* This CLIST displays all save areas in the current save area chain   *
/* starting from the specified value.                                  *
/*                                                                     *
/***********************************************************************
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
 /* Code to extract current TCB
IF &STR(&TCB&ADDRESS) = THEN DO
 SET TCB = 0
 EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))
 IF &TCB = 0 THEN DO
  EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))
  IF &TCB = 0 THEN DO
   EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))
   IF mTCB = 0 THEN DO
    NOTE 'TCB unavailable' ASIS
    EXIT C(12) Q
   END
  END
 END
 SET TCB = &STR(&TCB..)
END
IF &STR(&ADDRESS) = THEN DO
 EVAL &TCB+70 PTR CLIST(S(ADDRESS))
 IF &ADDRESS = 0 THEN DO
  NOTE 'TCB at &TCB has no save area pointer.' ASIS
  EXIT Q
 END
END
/*
/* Code suppressed...
/*
/* Now that we have the save area address, follow the chain upwards
/* until we get to the highest one.
/*
/*   SET PREVADDR =
/*   CHAIN:+
/*   IF &STR(&PREVADDR) ^= THEN DO
/*    EVAL &ADDRESS+8 PTR CLIST(S(LSA))
/*    IF &STR(&PREVADDR) ^= &STR(&LSA) THEN DO
/*     NOTE 'Stopping due to invalid back chain' ASIS
/*     WRITE ADDRESS=&ADDRESS, LSA=&LSA, PREVADDR=&PREVADDR
/*     NOTE SPACE(1)
/*     GOTO GOTIT
/*    END
/*   END
/*   EVAL &ADDRESS+4 PTR CLIST(S(HSA))
/*   IF &STR(&HSA) = 0 THEN GOTO GOTIT
/*   SET PREVADDR = &STR(&ADDRESS)
/*   SET ADDRESS = &STR(&HSA)
/*   GOTO CHAIN
GOTIT:+
TCBX YITSAV &ADDRESS
./ ADD NAME=SAVEAREA
PROC 0 TCB() XTRACE
/***********************************************************************
/*                                                                     *
/* Author: S. BACHER                                                   *
/*                                                                     *
/* This CLIST displays all save areas in the current save area chain   *
/* starting from the TCB's save area field.                            *
/*                                                                     *
/***********************************************************************
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) = IPCS THEN DO
 /* Code to extract current TCB
 IF &STR(&TCB) = THEN DO
  SET TCB = 0
  EVAL 21D. L(3) &ACTIVE HEX CLIST(S(TCB))
  IF &TCB = 0 THEN DO
   EVAL 219. L(3) &ACTIVE HEX CLIST(S(TCB))
   IF &TCB = 0 THEN DO
    EVAL 224.?+6C?+5 L(3) &ACTIVE HEX CLIST(S(TCB))
    IF &TCB = 0 THEN DO
     NOTE 'TCB unavailable' ASIS
     EXIT C(12) Q
    END
   END
  END
 END
 /* End code to extract current TCB
 IF &SYSINDEX(.,&STR(&TCB)) = 0 THEN SET TCB = &STR(&TCB..)
 TCBX XITSAV &TCB
 SET CC = &LASTCC
 IF &CC ^= 0 THEN DO
  WRITE XITSAV TCB exit error code &CC..
 END
END
ELSE DO
 IF &NRSTR(&TCB) ^= && &NRSTR(&TCB) ^= &STR(*) THEN +
  WRITE Warning: TCB operand ignored in active mode.
 XCMD XITSAV
END
./ ADD NAME=SETACF
PROC 0 ACCVTP() ACTIVE XTRACE
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END

/* Get ASID from ASVT */
/*  EVAL 224.%+24 L(2) UNS &ACTIVE CLIST(S(ASIDFROMASVT))
/*  IF &LASTCC = 12 THEN DO
/*   NOTE 'Error: Unable to access ASID from ASVT.' SPACE(1) ASIS
/*   EXIT C(12) Q
/*  END
/* SET ASIDINDEX = &ASIDFROMASVT*32 /* Convert to index to ACFASVT */

%GETASID &XTRACE
SET ASID = &LASTCC
INTEGER &ASID PTR(4) CLIST(S(ASIDX))
INTEGER &ASID UNS    CLIST(S(ASIDN))
SET ASIDINDEX = &ASIDN*32 /* Convert to index to ACFASVT */

IF &STR(&ACCVTP) ^= THEN DO
 IF &SUBSTR(&LENGTH(&STR(&ACCVTP)),&ACCVTP) = . THEN +
  SET ACCVTP = &SUBSTR(1:&LENGTH(&STR(&ACCVTP))-1,&ACCVTP)
 GOTO GOTACCVT
END

EVAL 10.%+128%+19 L(3) PTR &ACTIVE   /* Look for ACCVT via subsys   */+
                  CLIST(S(JESCTP))
IF &LASTCC = 12 THEN DO
 NOTE 'Error: Unable to access JESCT via CVT.' SPACE(1) ASIS
 EXIT C(12) Q
END
LOOP:+
EVAL &JESCTP..+8 L(4) CHAR &ACTIVE   /* Extract subsystem ID        */+
                 CLIST(S(SUBSYSID))
IF &LASTCC = 12 THEN DO
 NOTE 'Error: Unable to access subsystem ID from JESCT at &JESCTP..' +
      SPACE(1) ASIS
 EXIT C(12) Q
END
IF &NRSTR(&SUBSYSID) = ACF2 THEN     /* Loop until ACF2 subsystem   */+
 GOTO GOTACF2
EVAL &JESCTP..+5 L(3) PTR &ACTIVE    /* Chain thru subsys entries   */+
                 CLIST(S(JESCTP))
IF &LASTCC = 12 THEN DO
 NOTE 'Error: Unable to access next JESCT from JESCT at &JESCTP..' +
      SPACE(1) ASIS
 EXIT C(12) Q
END
IF &JESCTP = 0 THEN DO
 NOTE 'The ACF2 subsystem is not active.' ASIS
 EXIT C(4)
END
GOTO LOOP                            /* When found, set ACCVT addr  */
GOTACF2:+
EVAL       &JESCTP..+15       L(3)     PTR &ACTIVE CLIST(S(ACCVTP)  )
IF &LASTCC = 12 THEN DO
 NOTE 'Error: ACCVT unavailable.' ASIS
 GOTO EXIT
END
IF &ACCVT = 0 THEN DO
 NOTE 'There is no ACCVT.' ASIS
 GOTO EXIT
END

GOTACCVT:SET DUMMY = NOTHING

EQ ACCVT   &ACCVTP..          L(512)       &ACTIVE
EVAL       &ACCVTP..+65       L(3)     UNS &ACTIVE CLIST(S(ACFASVTN))
IF &LASTCC = 12 THEN DO
 NOTE 'Error: ACFASVT unavailable.' ASIS
 GOTO EXIT
END
IF &ACFASVTP = 0 THEN DO
 NOTE 'There is no ACFASVT.' ASIS
 GOTO EXIT
END
INTEGER    &EVAL(&ACFASVTN+&ASIDINDEX) PTR         CLIST(S(ACFASVTP))
EQ ACFASVT &ACFASVTP..        L(32)        &ACTIVE
EVAL       ACFASVT+1D         L(3)     PTR &ACTIVE CLIST(S(ACUCBP)  )
IF &LASTCC = 12 THEN DO
 NOTE 'Error: ACUCB unavailable.' ASIS
 GOTO EXIT
END
IF &ACUCBP = 0 THEN DO
 NOTE 'There is no ACUCB.' ASIS
 GOTO EXIT
END
EQ ACUCB   &ACUCBP..          L(192)       &ACTIVE
EVAL       ACUCB+1D           L(3)     PTR &ACTIVE CLIST(S(LIDRECP) )
IF &LASTCC = 12 THEN DO
 NOTE 'Error: LIDREC unavailable.' ASIS
 GOTO EXIT
END
IF &LIDRECP = 0 THEN DO
 NOTE 'There is no LIDREC.' ASIS
 GOTO EXIT
END
EQ LIDREC  &LIDRECP..         L(192)       &ACTIVE
EXIT:+
LISTSYM    (ACCVT ACFASVT ACUCB LIDREC)    &ACTIVE
IF &ACTIVE = THEN DO
 STACK    ACCVT   REM('ACCVT'  )
 STACK    ACFASVT REM('ACFASVT')
 STACK    ACUCB   REM('ACUCB'  )
 STACK    LIDREC  REM('LIDREC' )
END
./ ADD NAME=SHOWREGS
PROC 1 REGS STACK() ID() OTHERSTUFF() EQUATEPREFIX() XTRACE
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
SET I = 1
SET REGOFF = 0
DO &REGNO = 0 TO 15
 SET REGISTER_CONTENTS = &SUBSTR(&I:&I+7,&REGS)
 SET REG&REGNO = &STR(&REGISTER_CONTENTS)
 SELECT &SUBSTR(1,&REGISTER_CONTENTS)
  WHEN (8) SET REGISTER_CONTENTS=&STR(0&SUBSTR(2:8,&REGISTER_CONTENTS))
  WHEN (9) SET REGISTER_CONTENTS=&STR(1&SUBSTR(2:8,&REGISTER_CONTENTS))
  WHEN (A) SET REGISTER_CONTENTS=&STR(2&SUBSTR(2:8,&REGISTER_CONTENTS))
  WHEN (B) SET REGISTER_CONTENTS=&STR(3&SUBSTR(2:8,&REGISTER_CONTENTS))
  WHEN (C) SET REGISTER_CONTENTS=&STR(4&SUBSTR(2:8,&REGISTER_CONTENTS))
  WHEN (D) SET REGISTER_CONTENTS=&STR(5&SUBSTR(2:8,&REGISTER_CONTENTS))
  WHEN (E) SET REGISTER_CONTENTS=&STR(6&SUBSTR(2:8,&REGISTER_CONTENTS))
  WHEN (F) SET REGISTER_CONTENTS=&STR(7&SUBSTR(2:8,&REGISTER_CONTENTS))
 END
 IF &STR(&EQUATEPREFIX) ^= &STR() THEN DO
  EQ &EQUATEPREFIX&REGNO &REGISTER_CONTENTS..
 END
 IF &STR(&STACK) ^= THEN DO
/*STACK &STACK+&REGOFF.N? &OTHERSTUFF REMARK('Register &REGNO (&ID)')
  STACK &REGISTER_CONTENTS.. &OTHERSTUFF +
       REMARK('&SUBSTR(1:20,(&ID)                    ) Register &REGNO')
 END
 SET I = &I+8
 SET REGOFF = &REGOFF+4
END
NOTE SPACE(1)
NOTE &STR(' R0 = &REG0  R1 = &REG1  R2 = &REG2  R3 = &REG3')
NOTE &STR(' R4 = &REG4  R5 = &REG5  R6 = &REG6  R7 = &REG7')
NOTE &STR(' R8 = &REG8  R9 = &REG9  R10= &REG10  R11= &REG11')
NOTE &STR(' R12= &REG12  R13= &REG13  R14= &REG14  R15= &REG15')
NOTE SPACE(1)
./ ADD NAME=SSN
PROC 0 ACTIVE XTRACE
IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
EVAL 224.%+24 L(2) &ACTIVE           /* Get ASID from ASVT          */
SET ASIDINDEX = &LASTCC*32           /* Convert to index to ACFASVT */
EVAL 10.%+128%+19 L(3) PTR &ACTIVE   /* Get a subsystem entry       */+
                  CLIST(S(SUBSYSP))
SET SUBSYSP = &STR(00&SUBSYSP)
LOOP:+
EVAL &SUBSYSP..+8 L(4) CHAR &ACTIVE  /* Extract subsystem ID        */+
                 CLIST(S(SUBSYSID))
NOTE 'Subsystem: &NRSTR(&SUBSYSID)' ASIS
%DUMPCB SUBSYSTEM &SUBSYSP.. 36
EVAL &SUBSYSP..+4 L(4) PTR &ACTIVE   /* Chain thru subsys entries   */+
                 CLIST(S(SUBSYSP))
IF &SUBSYSP = 0 THEN DO
 NOTE ''
 NOTE 'End of subsystem table.' ASIS
 EXIT
END
GOTO LOOP
./ ADD NAME=SUM
PROC 0 XTRACE
IF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
 WRITE *** You must be in IPCS to use this CLIST. ***
 EXIT C(16) Q
END
/******************************************************************/
/* Get the current ASID                                           */
/******************************************************************/
%GETASID
SET ASID = &LASTCC
NOTE SPACE(1)
NOTE '*** SUM - User summary of TCB''s and RB''s for ASID &ASID ***' ASI
NOTE SPACE(1)
/******************************************************************/
/* Locate the ASCB, ASXB, and 1st TCB for this memory             */
/******************************************************************/
EVALDEF CLIST(DATASET(DEFDS))
IF &STR(&DEFDS) = ACTIVE THEN +
 EVAL 224.                           PTR CLIST(S(ASCBADDR))
ELSE +
 EVAL 10.%+22C%+20C+&EVAL(4*&ASID)N  PTR CLIST(S(ASCBADDR))
EVAL &ASCBADDR..+6C                  PTR CLIST(S(ASXBADDR))
IF &LASTCC=12 THEN DO
 NOTE '==> Error: ASXB not available for ASID(&ASID)' ASIS
 EXIT C(4)
END
SET TCBCTR=1
EVAL &ASXBADDR..+5 LE(3) PTR CLIST(S(TCBADDR))
IF &LASTCC=12 THEN DO
 L &ASXBADDR..+5 LE(3) PTR
 NOTE '==> Error: TCB&TCBCTR not available for ASID(&ASID)' ASIS
 EXIT C(4)
END
/******************************************************************/
/* Process all TCBs for this address space                        */
/******************************************************************/
DO WHILE &TCBADDR^=0
 EQ TCB&TCBCTR &TCBADDR.. STRUCTURE(TCB)
 /* STACK &TCBADDR.. REM('TCB&TCBCTR AT &TCBADDR')
 INTEGER X'&TCBADDR'         SIGNED CLIST(S(TCBADDRN))
 EVAL &TCBADDR..+48 LE(64) HEX CLIST(S(TCBREGS))
 EQ TCB&TCBCTR.REGS &TCBADDR..+48 LE(4) ENTRIES(0:15) HEX
 EVAL &TCBADDR..+10 LE(4) HEX CLIST(S(TCBCOMP))
 EVAL &TCBADDR..+70 LE(4) PTR CLIST(S(TCBSAVE))
 NOTE '*** TCB&TCBCTR at &TCBADDR - Compcode = &TCBCOMP - +
      Savearea = &TCBSAVE' ASIS
 NOTE SPACE(1)
 SET REGNO = 0
 SET I = 1
 DO WHILE &REGNO < 16
  SET REG&REGNO = &SUBSTR(&I:&I+7,&TCBREGS)
  SET I = &I+8
  SET REGNO = &REGNO+1
 END
 NOTE &STR('R0 = &REG0  R1 = &REG1  R2 = &REG2  R3 = &REG3')
 NOTE &STR('R4 = &REG4  R5 = &REG5  R6 = &REG6  R7 = &REG7')
 NOTE &STR('R8 = &REG8  R9 = &REG9  R10= &REG10  R11= &REG11')
 NOTE &STR('R12= &REG12  R13= &REG13  R14= &REG14  R15= &REG15')
 NOTE SPACE(1)
 /****************************************************************/
 /* Find the 1st RB address for this TCB                         */
 /****************************************************************/
 SET RCODE=0
 SET RBERR=0
 SET RBCTR=1
 EVAL &TCBADDR..+1 LE(3) PTR CLIST(S(RBADDR))
 IF &LASTCC=12 THEN DO
  NOTE ' ==> Error: RB&RBCTR not available for ASID(&ASID)' ASIS
  SET &RCODE=4
  SET &RBERR=1
 END
 EQ TCB&TCBCTR.RB&RBCTR &RBADDR.. STRUCTURE(RB)
 /* STACK &RBADDR.. REM('TCB&TCBCTR.RB&RBCTR AT &RBADDR')
 /****************************************************************/
 /* Process all RBs for this TCB                                 */
 /****************************************************************/
 DO WHILE &RBADDR^=&TCBADDR
  SET MODNAME =
  SET RBINTCOD = &STR((not available))
  EVAL &RBADDR..-2 LE(2) HEX CLIST(S(RBINTCOD))
  COMPARE ADDRESS(&RBADDR..+A) LE(1) +
          WITH(VALUE(X'00')) MASK(X'E0')
  IF &LASTCC=0 THEN DO
   SET &RBTYPE=PRB
   EVAL &RBADDR..+D LE(3) PTR CLIST(S(CDEADDR))
   IF &CDEADDR = 000000 THEN SET MODNAME = &STR(*UNKNOWN*)
   ELSE EVAL &CDEADDR..+8 LE(8) CHAR CLIST(S(MODNAME))
  END
  ELSE DO
   COMPARE ADDRESS(&RBADDR..+A) LE(1) +
           WITH(VALUE(X'C0')) MASK(X'E0')
   IF &LASTCC=0 THEN DO
    SET &RBTYPE=SVRB
   END
   ELSE DO
    COMPARE ADDRESS(&RBADDR..+A) LE(1) +
            WITH(VALUE(X'60')) MASK(X'E0')
    IF &LASTCC=0 THEN DO
     SET &RBTYPE=TIRB
    END
    ELSE DO
     COMPARE ADDRESS(&RBADDR..+A) LE(1) +
             WITH(VALUE(X'40')) MASK(X'E0')
     IF &LASTCC=0 THEN DO
      SET &RBTYPE=IRB
     END
     ELSE DO
      COMPARE ADDRESS(&RBADDR..+A) LE(1) +
              WITH(VALUE(X'80')) MASK(X'E0')
      IF &LASTCC=0 THEN DO
       SET &RBTYPE=SIRB
      END
      ELSE DO
       EVAL &RBADDR..+A LE(1) HEX CLIST(S(RBFTP))
       IF &LASTCC=12 THEN SET RBFTP = &STR((not accessible))
       NOTE ' ==> Error: RBFTP &RBFTP for RB&RBCTR not recognizable' ASI
       SET &RCODE=4
       SET &RBTYPE=RB
      END
     END
    END
   END
  END
  IF &STR(&MODNAME) = THEN SET MODDISP = &STR(NO CDE)
  ELSE SET MODDISP = &STR(CDE &MODNAME)
  NOTE ' *** &RBTYPE TCB&TCBCTR.RB&RBCTR. at &RBADDR - Int &RBINTCOD - +
       &MODDISP' ASIS
  SET RBOPSW = &STR((XXXXXX)(XXXXXX))
  EVAL &RBADDR..+10 LE(8) HEX CLIST(S(RBOPSW))
  NOTE ' *** PSW is &SUBSTR(1:8,&RBOPSW) &SUBSTR(9:16,&RBOPSW)' ASIS
  NOTE SPACE(1)
  SET RBREGS = &STR(XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+
                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+
                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+
                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+
                    )
  EVAL &RBADDR..+20 LE(64) HEX CLIST(S(RBREGS))
  EQ TCB&TCBCTR.RB&RBCTR.REGS &RBADDR..+20 LE(4) ENTRIES(0:15) HEX
  SET REGNO = 0
  SET I = 1
  DO WHILE &REGNO < 16
   SET REG&REGNO = &SUBSTR(&I:&I+7,&RBREGS)
   SET I = &I+8
   SET REGNO = &REGNO+1
  END
  NOTE &STR(' R0 = &REG0  R1 = &REG1  R2 = &REG2  R3 = &REG3')
  NOTE &STR(' R4 = &REG4  R5 = &REG5  R6 = &REG6  R7 = &REG7')
  NOTE &STR(' R8 = &REG8  R9 = &REG9  R10= &REG10  R11= &REG11')
  NOTE &STR(' R12= &REG12  R13= &REG13  R14= &REG14  R15= &REG15')
  NOTE SPACE(1)
  SET &RBCTR=&RBCTR+1
  EVAL &RBADDR..+1D LE(3) PTR CLIST(S(RBADDR))
  IF &LASTCC=12 THEN DO
   NOTE '==> Error: TCB&TCBCTR.RB&RBCTR not available for ASID(&ASID)' +
        ASIS
   SET RCODE=4
   SET RBERR=1
  END
 END
 /* End of RB loop */
 SET &TCBCTR=&TCBCTR+1
 EVAL &TCBADDR..+75 LE(3) PTR CLIST(S(TCBADDR))
 IF &LASTCC=12 THEN DO
  NOTE '==> Error: TCB&TCBCTR not available for ASID(&ASID)' ASIS
  EXIT C(4)
 END
END
EXIT
./ ADD NAME=SVCTABLE
PROC 0 SVC() +
       XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END

/**********************************************************************/
/*                                                                    */
/* CVTABEND -> SCVT -> SVCTABLE                                       */
/*                                                                    */
/**********************************************************************/

EQ SCVT 10.%+C8? L(184)
EQ SVCTABLE SCVT+84? L(8) ENTRIES(256)
IF &STR(&SVC) ^= THEN DO
 INTEGER &SVC UNSIGNED CLIST(S(SVCNO))
 IF &LASTCC ^= 0 THEN DO
  WRITE Invalid SVC number, &SVC
  EXIT
 END
 EVAL SVCTABLE+&EVAL(8*&SVCNO)N L(8) HEX CLIST(S(SVCENTRY))
 IF &LASTCC ^= 0 THEN DO
  WRITE Unable to access storage at SVCTABLE+&EVAL(8*&SVCNO)
  EXIT
 END
 NOTE 'SVC entry for SVC &SVCNO' ASIS
 NOTE SPACE(1)
 NOTE '&SUBSTR(1:8,&SVCENTRY) &SUBSTR(9:16,&SVCENTRY)' ASIS
END
ELSE DO
 LISTSYM (SCVT SVCTABLE)
END
./ ADD NAME=SVC99RB
PROC 1 SVC99RBPTR XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END

NOTE 'DYNALLOC info: +
      MVS/XA SPL: System Macros and Facilities, Vol. 1 - p. 1-235' +
     SPACE(1) ASIS

/*
/* Stupid code to get around SYSREF lossage.
/*
SET SYSDVAL =
READDVAL SVC99RBADDRESS SVC99RB TEXTUNITSPTR TEXTUNITS TEXTUNITPTR

SYSCALL ISET SVC99RBADDRESS  &SVC99RBPTR                   PTR DUMPCB
SYSCALL ISET SVC99RB         &SVC99RBADDRESS..    L( 20)       DUMPCB
SYSCALL ISET TEXTUNITSPTR    &SVC99RBADDRESS..+8           PTR

IF &SUBSTR( 1: 2,&SVC99RB) +
   &SUBSTR( 5: 8,&SVC99RB) +
   &SUBSTR(25:32,&SVC99RB) +
   &SUBSTR(33:40,&SVC99RB)+
   ^= &STR(14 0000 00000000 00000000) THEN DO
 NOTE 'Warning: unusual values in SVC99 request block!' ASIS
END

INTEGER X'&SUBSTR(3:4,&SVC99RB)' UNS CLIST(S(VERBCODE))
SELECT &VERBCODE
 WHEN (1)  SET VERB = &STR(S99VRBAL - DSNAME allocation
 WHEN (2)  SET VERB = &STR(S99VRBUN - deallocation
 WHEN (3)  SET VERB = &STR(S99VRBCC - concatenation
 WHEN (4)  SET VERB = &STR(S99VRBDC - deconcatenation
 WHEN (5)  SET VERB = &STR(S99VRBRI - remove in-use attribute
 WHEN (6)  SET VERB = &STR(S99VRBDN - DDNAME allocation
 WHEN (7)  SET VERB = &STR(S99VRBIN - information retrieval
 OTHERWISE SET VERB = &STR(Unknown verb code &VERBCODE)
END
NOTE 'Verb code: &VERBCODE (&VERB)' ASIS

DO I = 1 TO 2147483647 +
   UNTIL &OUT = Y
 SYSCALL ISET TEXTUNITPTR &TEXTUNITSPTR..+&EVAL(4*(&I-1))N  PTR
 SET TEXTUNITPTR&I = &NRSTR(&TEXTUNITPTR)
 SET TUCOUNT = &I
 SELECT &SUBSTR(1,&TEXTUNITPTR)
  WHEN (8|9|A|B|C|D|E|F) SET OUT = Y
 END
END

SYSCALL ISET TEXTUNITS &TEXTUNITSPTR.. L(&EVAL(&TUCOUNT*4)) DUMPCB

DO I = 1 TO &TUCOUNT
 SET TEXTUNITPTR = &STR(&SYSNSUB(2,&&TEXTUNITPTR&I))
 IF &TEXTUNITPTR ^= 0 THEN DO
  SET TEXTUNITPTR = &STR(&TEXTUNITPTR..)
  SYSCALL FIXUP TEXTUNITPTR
  SYSCALL DUMP_TEXT_UNIT &TEXTUNITPTR &VERBCODE
 END
END

NOTE '*** End of SVC 99 text units. ***' SPACE(1) ASIS

EXIT

DUMP_TEXT_UNIT: PROC 2 TUADDRESS VERBCODE

 EVAL &TUADDRESS+0 HEX L(2) CLIST(S(TUCODE))
 IF &LASTCC ^= 0 THEN GOTO ERROR
 EVAL &TUADDRESS+2 UNS L(2) CLIST(S(TUCOUNT))
 IF &LASTCC ^= 0 THEN GOTO ERROR
 SET I = 4
 DO WHILE &TUCOUNT > 0
  EVAL &TUADDRESS+&I.N+0 UNS L(2) CLIST(S(TULENGTH))
  IF &LASTCC ^= 0 THEN GOTO ERROR
  SET I = &I+&TULENGTH+2
  SET TUCOUNT = &TUCOUNT-1
 END

 SYSCALL DESCRIBE_TEXT_UNIT &VERBCODE &TUADDRESS &TUCODE &TUCOUNT
 %DUMPCB TEXT_UNIT &TUADDRESS &EVAL(&I) NOTITLE

 RETURN CODE(0)

 ERROR:+
 NOTE 'Error accessing text unit data at &TUADDRESS..' ASIS SPACE(1)
 RETURN CODE(12)

END

ISET: PROC 2 CLISTVAR FIELD DUMPCB +
             LENGTHVALUE(4) PTR POINTER SIGNED UNSIGNED
 SET TITLE = &STR(&CLISTVAR) /* before SYSREFfing
 SYSREF CLISTVAR
 SET CLISTVAR = &STR(<<<no_value>>>)
 IF &SYSINDEX(.,&FIELD) ^= 0 THEN DO
  SYSCALL FIXUP FIELD
 END
 EVAL &FIELD L(&LENGTHVALUE) &PTR &POINTER &SIGNED &UNSIGNED +
      CLIST(S(CLISTVAR))
 IF &LASTCC ^= 0 THEN DO
  NOTE 'Error: &NRSTR(&TITLE) at &NRSTR(&FIELD) not accessible.' ASIS
  EXIT C(12) Q
 END
 IF &DUMPCB = DUMPCB THEN %DUMPCB &TITLE &FIELD &LENGTHVALUE
 RETURN
END

FIXUP: PROC 1 AFIELD
 SYSREF AFIELD
 SET I = &SYSINDEX(.,&AFIELD)
 IF &I = 9 THEN DO
  SET I = &SYSINDEX(&SUBSTR(1,&AFIELD),89ABCDEF)
  IF &I ^= 0 THEN DO
   SET AFIELD = +
       &SUBSTR(&I,01234567)&SUBSTR(2:&LENGTH(&STR(&AFIELD)),&AFIELD)
  END
 END
END

DESCRIBE_TEXT_UNIT: PROC 4 VERBCODE TUADDRESS TUCODE TUCOUNT

 SET TUSTUFF=&STR(Unknown text unit key &TUCODE)
 SELECT &VERBCODE
  WHEN (1) DO
   SELECT &TUCODE
    WHEN (0001) SET TUSTUFF=&STR(DALDDNAM - DD name
    WHEN (0002) SET TUSTUFF=&STR(DALDSNAM - data set name
    WHEN (0003) SET TUSTUFF=&STR(DALMEMBR - member or GDG number
    WHEN (0004) SET TUSTUFF=&STR(DALSTATS - data set status
    WHEN (0005) SET TUSTUFF=&STR(DALNDISP - normal disposition
    WHEN (0006) SET TUSTUFF=&STR(DALCDISP - conditional disposition
    WHEN (0007) SET TUSTUFF=&STR(DALTRK   - space allocation in tracks
    WHEN (0008) SET TUSTUFF=&STR(+
    DALCYL   - space allocation in cylinders
    WHEN (0009) SET TUSTUFF=&STR(DALBLKLN - average data block length
    WHEN (000A) SET TUSTUFF=&STR(DALPRIME - primary space quantity
    WHEN (000B) SET TUSTUFF=&STR(DALSECND - secondary space quantity
    WHEN (000C) SET TUSTUFF=&STR(DALDIR   - number of directory blocks
    WHEN (000D) SET TUSTUFF=&STR(DALRLSE  - release unused space
    WHEN (000E) SET TUSTUFF=&STR(+
    DALSPFRM - specific allocated space format
    WHEN (000F) SET TUSTUFF=&STR(+
    DALROUND - allocation in whole cylinders
    WHEN (0010) SET TUSTUFF=&STR(DALVLSER - volume serial numbers
    WHEN (0011) SET TUSTUFF=&STR(DALPRIVT - private volume use attribute
    WHEN (0012) SET TUSTUFF=&STR(DALVLSEQ - volume sequence number
    WHEN (0013) SET TUSTUFF=&STR(DALVLCNT - volume count
    WHEN (0014) SET TUSTUFF=&STR(DALVLRDS - volume reference to data set
    WHEN (0015) SET TUSTUFF=&STR(DALUNIT  - unit specification
    WHEN (0016) SET TUSTUFF=&STR(DALUNCNT - unit count
    WHEN (0017) SET TUSTUFF=&STR(DALPARAL - parallel mounting
    WHEN (0018) SET TUSTUFF=&STR(DALSYSOU - SYSOUT data set class
    WHEN (0019) SET TUSTUFF=&STR(DALSPGNM - SYSOUT program name
    WHEN (001A) SET TUSTUFF=&STR(DALSFMNO - SYSOUT form number
    WHEN (001B) SET TUSTUFF=&STR(DALOUTLM - SYSOUT OUTLIM
    WHEN (001C) SET TUSTUFF=&STR(DALCLOSE - free data set at close
    WHEN (001D) SET TUSTUFF=&STR(DALCOPYS - SYSOUT copies count
    WHEN (001E) SET TUSTUFF=&STR(DALLABEL - type of volume label
    WHEN (001F) SET TUSTUFF=&STR(DALDSSEQ - relative position for tape
    WHEN (0020) SET TUSTUFF=&STR(DALPASPR - password protection
    WHEN (0021) SET TUSTUFF=&STR(DALINOUT - input only or output only
    WHEN (0022) SET TUSTUFF=&STR(DALEXPDT - expiration date
    WHEN (0023) SET TUSTUFF=&STR(DALRETPD - retention period
    WHEN (0024) SET TUSTUFF=&STR(DALDUMMY - dummy data set
    WHEN (0025) SET TUSTUFF=&STR(DALFCBIM - FCB image
    WHEN (0026) SET TUSTUFF=&STR(DALFCBAV - FCB verify
    WHEN (0027) SET TUSTUFF=&STR(DALQNAME - TPROCESS macro, TCAM proc.
    WHEN (0028) SET TUSTUFF=&STR(DALTERM  - time sharing terminal
    WHEN (0029) SET TUSTUFF=&STR(DALUCS   - universal character set
    WHEN (002A) SET TUSTUFF=&STR(DALUFOLD - UCS fold mode
    WHEN (002B) SET TUSTUFF=&STR(DALUVRFY - UCS verify
    WHEN (002C) SET TUSTUFF=&STR(DALDCBDS - DCB from data set label
    WHEN (002D) SET TUSTUFF=&STR(DALDCBDD - DCB from allocated DD name
    WHEN (0058) SET TUSTUFF=&STR(DALSUSER - SYSOUT remote work station
    WHEN (0059) SET TUSTUFF=&STR(DALSHOLD - SYSOUT hold queue
    WHEN (005E) SET TUSTUFF=&STR(DALMSVGP - MSS virtual volume group
    WHEN (005F) SET TUSTUFF=&STR(DALSSNM  - subsystem data set
    WHEN (0060) SET TUSTUFF=&STR(DALSSPRM - subsystem-defined parameters
    WHEN (0061) SET TUSTUFF=&STR(DALPROT  - RACF protection
    WHEN (0063) SET TUSTUFF=&STR(DALUSRID - SYSOUT route to userid
    WHEN (0064) SET TUSTUFF=&STR(DALBURST - 3800 burster/trimmer/stacker
    WHEN (0065) SET TUSTUFF=&STR(+
    DALCHARS - 3800 character arrangement table
    WHEN (0066) SET TUSTUFF=&STR(DALCOPYG - 3800 copy groups
    WHEN (0067) SET TUSTUFF=&STR(DALFFORM - 3800 forms overlay
    WHEN (0068) SET TUSTUFF=&STR(+
    DALFCNT  - 3800 forms overlay # of copies
    WHEN (0069) SET TUSTUFF=&STR(+
    DALMMOD  - 3800 copy modification module
    WHEN (006A) SET TUSTUFF=&STR(DALMTRC  - copymod table reference char
    WHEN (006C) SET TUSTUFF=&STR(DALDEFER - defer volume mounting
    WHEN (8002) SET TUSTUFF=&STR(+
    DALOUTPT - refer to OUTPUT JCL statement
    WHEN (002E) SET TUSTUFF=&STR(DALBFALN - buffer alignment
    WHEN (002F) SET TUSTUFF=&STR(DALBFTEK - buffering technique
    WHEN (0030) SET TUSTUFF=&STR(DALBLKSZ - blocksize
    WHEN (0031) SET TUSTUFF=&STR(DALBUFIN - receiving buffer count
    WHEN (0032) SET TUSTUFF=&STR(DALBUFL  - buffer length
    WHEN (0033) SET TUSTUFF=&STR(DALBUFMX - buffer count per line
    WHEN (0034) SET TUSTUFF=&STR(DALBUFNO - buffer count per DCB
    WHEN (0035) SET TUSTUFF=&STR(DALBUFOF - buffer offset
    WHEN (0036) SET TUSTUFF=&STR(DALBUFOU - sending buffer count
    WHEN (0037) SET TUSTUFF=&STR(DALBUFRQ - buffer count per GET macro
    WHEN (0038) SET TUSTUFF=&STR(DALBUFSZ - line group buffer size
    WHEN (0039) SET TUSTUFF=&STR(DALCODE  - paper tape code
    WHEN (003A) SET TUSTUFF=&STR(+
    DALCPRI  - relative sending and receiving priority
    WHEN (003B) SET TUSTUFF=&STR(DALDEN   - magnetic tape density
    WHEN (003C) SET TUSTUFF=&STR(DALDSORG - data set organization
    WHEN (003D) SET TUSTUFF=&STR(DALEROPT - I/O error options
    WHEN (003E) SET TUSTUFF=&STR(DALGNCP  - GAM-I/O count per WAIT macro
    WHEN (003F) SET TUSTUFF=&STR(+
    DALINTVL - line polling interval per group
    WHEN (0040) SET TUSTUFF=&STR(DALKYLEN - key length
    WHEN (0041) SET TUSTUFF=&STR(DALLIMCT - search limit
    WHEN (0042) SET TUSTUFF=&STR(DALLRECL - logical record length
    WHEN (0043) SET TUSTUFF=&STR(DALMODE  - card punch reader mode
    WHEN (0044) SET TUSTUFF=&STR(DALNCP   - number of channel programs
    WHEN (0045) SET TUSTUFF=&STR(DALOPTCD - option code
    WHEN (0046) SET TUSTUFF=&STR(DALPCIR  - receiving PCI relationship
    WHEN (0047) SET TUSTUFF=&STR(DALPCIS  - sending PCI relationship
    WHEN (0048) SET TUSTUFF=&STR(DALPRTSP - printer line spacing
    WHEN (0049) SET TUSTUFF=&STR(DALRECFM - record format
    WHEN (004A) SET TUSTUFF=&STR(+
    DALRSRVF - first buffer's reserve byte count
    WHEN (004B) SET TUSTUFF=&STR(+
    DALRSRVS - secondary buffer's reserve byte count
    WHEN (004C) SET TUSTUFF=&STR(DALSOWA  - TCAM input work area size
    WHEN (004D) SET TUSTUFF=&STR(DALSTACK - card punch stacker bin
    WHEN (004E) SET TUSTUFF=&STR(DALTHRSH - message queue threshold
    WHEN (004F) SET TUSTUFF=&STR(+
    DALTRTCH - 7-track tape recording technique
    WHEN (0051) SET TUSTUFF=&STR(DALIPLTX - TCAM NCP name
    WHEN (0054) SET TUSTUFF=&STR(DALDIAGN - OPEN/CLOSE/EOV trace option
    WHEN (005A) SET TUSTUFF=&STR(DALFUNC  - card punch/reader type
    WHEN (005B) SET TUSTUFF=&STR(DALFRID  - input to 3886 char. reader
    WHEN (0050) SET TUSTUFF=&STR(+
    DALPASSW - password for protected data set
    WHEN (0052) SET TUSTUFF=&STR(DALPERMA - permanently allocated
    WHEN (0053) SET TUSTUFF=&STR(DALCNVRT - convertible
    WHEN (0055) SET TUSTUFF=&STR(DALRTDDN - return ddname
    WHEN (0056) SET TUSTUFF=&STR(DALRTDSN - return data set name
    WHEN (0057) SET TUSTUFF=&STR(DALRTORG - return DSORG
    WHEN (005C) SET TUSTUFF=&STR(DALSSREQ - subsystem data set
    WHEN (005D) SET TUSTUFF=&STR(DALRTVOL - return volume serial
    WHEN (0062) SET TUSTUFF=&STR(DALSSATT - subsystem SYSIN data set
   END
  END
  WHEN (2) DO
   SELECT &TUCODE
    WHEN (0001) SET TUSTUFF=&STR(DUNDDNAM - DD name
    WHEN (0002) SET TUSTUFF=&STR(DUNDSNAM - data set name
    WHEN (0003) SET TUSTUFF=&STR(DUNMEMBR - PDS member
    WHEN (0005) SET TUSTUFF=&STR(DUNOVDSP - overriding disposition
    WHEN (0007) SET TUSTUFF=&STR(+
    DUNUNALC - free even if permanently allocated
    WHEN (0008) SET TUSTUFF=&STR(+
    DUNREMOV - remove in-use attribute even if perm
    WHEN (000A) SET TUSTUFF=&STR(DUNOVSNH - NOHOLD overrides for SYSOUT
    WHEN (0018) SET TUSTUFF=&STR(DUNOVCLS - overriding SYSOUT class
    WHEN (0058) SET TUSTUFF=&STR(+
    DUNOVSUS - overriding remote workstation
    WHEN (0059) SET TUSTUFF=&STR(DUNOVSHQ - HOLD overrides for SYSOUT
   END
  END
  WHEN (3) DO
   SELECT &TUCODE
    WHEN (0001) SET TUSTUFF=&STR(DCCDDNAM - DD name to be concatenated
    WHEN (0004) SET TUSTUFF=&STR(DCCPERMC - permanently concatenated
   END
  END
  WHEN (4) DO
   SELECT &TUCODE
    WHEN (0001) SET TUSTUFF=&STR(DCDDDNAM - DD name to be deconcatenated
   END
  END
  WHEN (5) DO
   SELECT &TUCODE
    WHEN (0001) SET TUSTUFF=&STR(DRITCBAD - specify TCB address
    WHEN (0002) SET TUSTUFF=&STR(DRICURNT - current and higher tasks
   END
  END
  WHEN (6) DO
   SELECT &TUCODE
    WHEN (0001) SET TUSTUFF=&STR(DDNDDNAM - DD name
    WHEN (0002) SET TUSTUFF=&STR(DDNRTDUM - return dummy indication
   END
  END
  WHEN (7) DO
   SELECT &TUCODE
    WHEN (0001) SET TUSTUFF=&STR(DINDDNAM - DD name
    WHEN (0002) SET TUSTUFF=&STR(DINDSNAM - data set name
    WHEN (0004) SET TUSTUFF=&STR(DINRTDDN - return DD name
    WHEN (0005) SET TUSTUFF=&STR(DINRTDSN - return data set name
    WHEN (0006) SET TUSTUFF=&STR(DINRTMEM - return PDS member name
    WHEN (0007) SET TUSTUFF=&STR(DINRTSTA - return data set status
    WHEN (0008) SET TUSTUFF=&STR(DINRTNDP - return normal disposition
    WHEN (0009) SET TUSTUFF=&STR(DINRTCDP - return cond. disposition
    WHEN (000A) SET TUSTUFF=&STR(DINRTORG - return DSORG
    WHEN (000B) SET TUSTUFF=&STR(+
    DINRTLIM - return # of resources to free
    WHEN (000C) SET TUSTUFF=&STR(+
    DINRTATT - return special attribute indications
    WHEN (000D) SET TUSTUFF=&STR(+
    DINRTLST - return last relative entry indication
    WHEN (000E) SET TUSTUFF=&STR(DINRTTYP - return type (terminal/dummy)
    WHEN (000F) SET TUSTUFF=&STR(DINRELNO - relative request number
   END
  END
 END
 NOTE 'Text unit at &TUADDRESS - &NRSTR(&TUSTUFF)' SPACE(1) ASIS
END

./ ADD NAME=TESTEVAL
PROC 0 +
       XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
SET EVALDEFCONFIRM          =  &STR(*** not set by IPCS ***)
SET EVALDEFDISPLAY          =  &STR(*** not set by IPCS ***)
SET EVALDEFDATASET          =  &STR(*** not set by IPCS ***)
SET EVALDEFFLAG             =  &STR(*** not set by IPCS ***)
SET EVALDEFLENGTH           =  &STR(*** not set by IPCS ***)
SET EVALDEFPRINT            =  &STR(*** not set by IPCS ***)
SET EVALDEFPROBLEM          =  &STR(*** not set by IPCS ***)
SET EVALDEFQUALIFICATION    =  &STR(*** not set by IPCS ***)
SET EVALDEFTERMINAL         =  &STR(*** not set by IPCS ***)
SET EVALDEFTEST             =  &STR(*** not set by IPCS ***)
SET EVALDEFVERIFY           =  &STR(*** not set by IPCS ***)
SET EVALDUMPBLOCKS          =  &STR(*** not set by IPCS ***)
SET EVALDUMPBYTES           =  &STR(*** not set by IPCS ***)
SET EVALDUMPDATASET         =  &STR(*** not set by IPCS ***)
SET EVALDUMPQUALIFICATION   =  &STR(*** not set by IPCS ***)
SET EVALMAPADDRESS          =  &STR(*** not set by IPCS ***)
SET EVALMAPANALYSIS         =  &STR(*** not set by IPCS ***)
SET EVALMAPDATATYPE         =  &STR(*** not set by IPCS ***)
SET EVALMAPDIMENSION        =  &STR(*** not set by IPCS ***)
SET EVALMAPENTRY            =  &STR(*** not set by IPCS ***)
SET EVALMAPFLAG             =  &STR(*** not set by IPCS ***)
SET EVALMAPLENGTH           =  &STR(*** not set by IPCS ***)
SET EVALMAPPOSITION         =  &STR(*** not set by IPCS ***)
SET EVALMAPQUALIFICATION    =  &STR(*** not set by IPCS ***)
SET EVALSYMADDRESS          =  &STR(*** not set by IPCS ***)
SET EVALSYMDATATYPE         =  &STR(*** not set by IPCS ***)
SET EVALSYMDIMENSION        =  &STR(*** not set by IPCS ***)
SET EVALSYMDROP             =  &STR(*** not set by IPCS ***)
SET EVALSYMENTRY            =  &STR(*** not set by IPCS ***)
SET EVALSYMLENGTH           =  &STR(*** not set by IPCS ***)
SET EVALSYMPOSITION         =  &STR(*** not set by IPCS ***)
SET EVALSYMQUALIFICATION    =  &STR(*** not set by IPCS ***)
SET EVALSYMREMARK           =  &STR(*** not set by IPCS ***)
SET EVALSYMSYMBOL           =  &STR(*** not set by IPCS ***)
SET EVALUATEPROTECTION      =  &STR(*** not set by IPCS ***)
SET EVALUATESTORAGE         =  &STR(*** not set by IPCS ***)
CONTROL NOFLUSH
ERROR DO
 SET CC = &LASTCC
 RETURN
END
WRITE
WRITE This clist demonstrates the use of the IPCS subcommands
WRITE that place data into CLISTs or ISPF dialog variables.
WRITE
WRITE First, we will demonstrate how "EVALDEF" works.
WRITE
SYSCALL ASKDORH EVALDEFTYPE
WRITE
SET CC = 0
EVALDEF CLIST(&EVALDEFTYPE +
              CONFIRM      (EVALDEFCONFIRM      ) +
              DISPLAY      (EVALDEFDISPLAY      ) +
              DATASET      (EVALDEFDATASET      ) +
              FLAG         (EVALDEFFLAG         ) +
              LENGTH       (EVALDEFLENGTH       ) +
              PRINT        (EVALDEFPRINT        ) +
              PROBLEM      (EVALDEFPROBLEM      ) +
              QUALIFICATION(EVALDEFQUALIFICATION) +
              TERMINAL     (EVALDEFTERMINAL     ) +
              TEST         (EVALDEFTEST         ) +
              VERIFY       (EVALDEFVERIFY       ) +
             )
IF &CC ^= 0 THEN WRITE EVALDEF returned code &CC
WRITE CONFIRM       = "&NRSTR(&EVALDEFCONFIRM)"
WRITE DISPLAY       = "&NRSTR(&EVALDEFDISPLAY)"
WRITE DATASET       = "&NRSTR(&EVALDEFDATASET)"
WRITE FLAG          = "&NRSTR(&EVALDEFFLAG)"
WRITE LENGTH        = "&NRSTR(&EVALDEFLENGTH)"
WRITE PRINT         = "&NRSTR(&EVALDEFPRINT)"
WRITE PROBLEM       = "&NRSTR(&EVALDEFPROBLEM)"
WRITE QUALIFICATION = "&NRSTR(&EVALDEFQUALIFICATION)"
WRITE TERMINAL      = "&NRSTR(&EVALDEFTERMINAL)"
WRITE TEST          = "&NRSTR(&EVALDEFTEST)"
WRITE VERIFY        = "&NRSTR(&EVALDEFVERIFY)"
WRITE
WRITE Next, we will demonstrate how "EVALDUMP" works.
WRITE
IF &NRSTR(&EVALDEFDATASET) = NODSNAME THEN DO
 WRITE We cannot demonstrate EVALDUMP because there is no current +
       dump data set.
END
ELSE DO
 SYSCALL ASKDORH EVALDUMPTYPE
 WRITE
 SET CC = 0
 EVALDUMP &EVALDEFDATASET +
          CLIST(&EVALDUMPTYPE +
                BLOCKS       (EVALDUMPBLOCKS       ) +
                BYTES        (EVALDUMPBYTES        ) +
                DATASET      (EVALDUMPDATASET      ) +
                QUALIFICATION(EVALDUMPQUALIFICATION) +
               )
 IF &CC ^= 0 THEN WRITE EVALDUMP returned code &CC
 WRITE BLOCKS        = "&NRSTR(&EVALDUMPBLOCKS)"
 WRITE BYTES         = "&NRSTR(&EVALDUMPBYTES)"
 WRITE DATASET       = "&NRSTR(&EVALDUMPDATASET)"
 WRITE QUALIFICATION = "&NRSTR(&EVALDUMPQUALIFICATION)"
END
WRITE
WRITE Next, we will demonstrate how "EVALMAP" works.
WRITE
SYSCALL ASKDORH EVALMAPTYPE
WRITE
SET CC = 0
EVALMAP 0. +
        CLIST(&EVALMAPTYPE +
              ADDRESS      (EVALMAPADDRESS      ) +
              ANALYSIS     (EVALMAPANALYSIS     ) +
              DATATYPE     (EVALMAPDATATYPE     ) +
              DIMENSION    (EVALMAPDIMENSION    ) +
              ENTRY        (EVALMAPENTRY        ) +
              FLAG         (EVALMAPFLAG         ) +
              LENGTH       (EVALMAPLENGTH       ) +
              POSITION     (EVALMAPPOSITION     ) +
              QUALIFICATION(EVALMAPQUALIFICATION) +
             )
IF &CC ^= 0 THEN WRITE EVALMAP returned code &CC
WRITE ADDRESS       = "&NRSTR(&EVALMAPADDRESS)"
WRITE ANALYSIS      = "&NRSTR(&EVALMAPANALYSIS)"
WRITE DATATYPE      = "&NRSTR(&EVALMAPDATATYPE)"
WRITE DIMENSION     = "&NRSTR(&EVALMAPDIMENSION)"
WRITE ENTRY         = "&NRSTR(&EVALMAPENTRY)"
WRITE FLAG          = "&NRSTR(&EVALMAPFLAG)"
WRITE LENGTH        = "&NRSTR(&EVALMAPLENGTH)"
WRITE POSITION      = "&NRSTR(&EVALMAPPOSITION)"
WRITE QUALIFICATION = "&NRSTR(&EVALMAPQUALIFICATION)"
WRITE
WRITE Next, we will demonstrate how "EVALSYM" works.
WRITE
SYSCALL ASKDORH EVALSYMTYPE
WRITE
ASKBOL:+
WRITENR Enter symbol name or ? ===>
CONTROL CAPS
READ EVALSYMBOL
CONTROL NOCAPS
IF &NRSTR(&EVALSYMBOL) = THEN GOTO ASKBOL
IF &NRSTR(&EVALSYMBOL) = ? THEN DO
 WRITE A list of symbols follows:
 WRITE
 LISTSYM
 GOTO ASKBOL
END
WRITE
SET CC = 0
EVALSYM &EVALSYMBOL +
        CLIST(&EVALSYMTYPE UNQUOTE +
              ADDRESS      (EVALSYMADDRESS      ) +
              DATATYPE     (EVALSYMDATATYPE     ) +
              DIMENSION    (EVALSYMDIMENSION    ) +
              DROP         (EVALSYMDROP         ) +
              ENTRY        (EVALSYMENTRY        ) +
              LENGTH       (EVALSYMLENGTH       ) +
              POSITION     (EVALSYMPOSITION     ) +
              QUALIFICATION(EVALSYMQUALIFICATION) +
              REMARK       (EVALSYMREMARK       ) +
              SYMBOL       (EVALSYMSYMBOL       ) +
             )
IF &CC ^= 0 THEN WRITE EVALSYM returned code &CC
WRITE ADDRESS       = "&NRSTR(&EVALSYMADDRESS)"
WRITE DATATYPE      = "&NRSTR(&EVALSYMDATATYPE)"
WRITE DIMENSION     = "&NRSTR(&EVALSYMDIMENSION)"
WRITE DROP          = "&NRSTR(&EVALSYMDROP)"
WRITE ENTRY         = "&NRSTR(&EVALSYMENTRY)"
WRITE LENGTH        = "&NRSTR(&EVALSYMLENGTH)"
WRITE POSITION      = "&NRSTR(&EVALSYMPOSITION)"
WRITE QUALIFICATION = "&NRSTR(&EVALSYMQUALIFICATION)"
WRITE REMARK        = "&NRSTR(&EVALSYMREMARK)"
WRITE SYMBOL        = "&NRSTR(&EVALSYMSYMBOL)"
WRITE
WRITE Next, we will demonstrate how "EVALUATE" works.
WRITE
WRITE
SET CC = 0
LISTSYM X
WRITE
EVALUATE X +
        CLIST(UNQUOTE +
              PROTECTION   (EVALUATEPROTECTION  ) +
              STORAGE      (EVALUATESTORAGE     ) +
             )
IF &CC ^= 0 THEN WRITE EVALUATE returned code &CC
WRITE PROTECTION    = "&NRSTR(&EVALUATEPROTECTION)"
WRITE STORAGE       = "&NRSTR(&EVALUATESTORAGE)"
WRITE
WRITE
WRITE TESTEVAL ended.
WRITE

ASKDORH: PROC 1 VAR
 SYSREF VAR
 DO UNTIL &OK = Y
  SET OK = Y
  WRITENR Enter "D(ecimal)" or "H(exadecimal)" ===>
  READ DH
  SELECT &SYSCAPS(&SUBSTR(1,&NRSTR(&DH )))
   WHEN (D)     SET VAR = DECIMAL
   WHEN (H | X) SET VAR = HEXADECIMAL
   OTHERWISE SET OK = N
  END
 END
END ASKDORH
./ ADD NAME=TSOCB
PROC 0 REXX TCB(21C.?) SHOW XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOFLUSH NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
 WRITE *** You must be in IPCS to use this CLIST. ***
 EXIT C(16) Q
END
SET ECT_P = N
IF &SHOW = SHOW THEN DO
 LISTSYM (ECT PSCB UPT RLGB)
 LISTSYM (LWA TSVT)
 EXIT
END
SET SYSDVAL =
READDVAL TSVT LWA PSCB
EVALDEF CLIST(DATASET(DSORACT))
IF &STR(&DSORACT) = ACTIVE THEN DO
 EQ CVT 10.%
END
EQ TSVT CVT+9C?
IF &LASTCC=12 THEN DO
 NOTE 'The TSVT is not available +
      (possibly because the CVT is not available).' ASIS
 NOTE SPACE(1)
END
ELSE SET TSVT = TSVT
EQ LWA 224.?+6C?+14? L(128)
IF &LASTCC=12 THEN DO
 NOTE 'The LWA is not available +
      (possibly because the ASCB or ASXB is not available).' ASIS
 NOTE SPACE(1)
END
ELSE SET LWA = LWA
EVAL &TCB+B4?+15C?+108 L(4) PTR CLIST(S(PSCBADDRESS))
/*AL &TCB+B4?+108 L(4) PTR CLIST(S(PSCBADDRESS))
IF &LASTCC=12 THEN DO
 NOTE 'The PSCB is not available +
      (possibly because the TCB or JSCB is not available).' ASIS
 NOTE SPACE(1)
END
ELSE IF &PSCBADDRESS = 0 THEN DO
 NOTE 'No PSCB - there is no TSO environment.' ASIS
 NOTE SPACE(1)
END
ELSE DO
 SET PSCB = PSCB
 EQ PSCB &PSCBADDRESS.. L(64)
 EQ UPT  PSCB+34? L(24)
 EQ RLGB PSCB+30? L(260)
 IF &LWA = LWA THEN DO
  EVAL LWA+20 L(4) CLIST(S(LWAECTPTR))
  EVAL RLGB+100 L(4) CLIST(S(RLGBECTPTR))
  IF &LWAECTPTR ^= &RLGBECTPTR THEN DO
   NOTE 'Warning: ECT addresses in LWA and RLGB do not match.' ASIS
   IF &LWAECTPTR = 00000000 && &RLGBECTPTR ^= 00000000 THEN DO
    NOTE 'Using ECT pointer from RLGB (&RLGBECTPTR), +
          not LWA (&LWAECTPTR).' ASIS
    EQ ECT  RLGB+100? L(64)
    SET ECT_P = Y
   END
   ELSE +
   IF &LWAECTPTR ^= 00000000 && &RLGBECTPTR = 00000000 THEN DO
    NOTE 'Using ECT pointer from LWA (&LWAECTPTR), +
         not RLGB (&RLGBECTPTR).' ASIS
    EQ ECT  LWA+20? L(64)
    SET ECT_P = Y
   END
   ELSE DO
    NOTE 'Using ECT pointer from LWA (&LWAECTPTR), +
         not RLGB (&RLGBECTPTR).' ASIS
    EQ ECT  LWA+20? L(64)
    SET ECT_P = Y
   END
  END
  ELSE DO
   EQ ECT  RLGB+100? L(64)
   SET ECT_P = Y
  END
 END
 LISTSYM (ECT PSCB UPT RLGB)
 STACK    ECT  REM('ECT'  )
 STACK    PSCB REM('PSCB' )
 STACK    UPT  REM('UPT'  )
 STACK    RLGB REM('RLGB' )
END
LISTSYM (LWA TSVT)
STACK    LWA  REM('LWA'  )
STACK    TSVT REM('TSVT' )

IF &ECT_P = Y THEN +
 SYSCALL GETREXX &REXX &XTRACE
EXIT

GETREXX: PROC 0 REXX XTRACE
EVAL ECT+30 L(4) HEX CLIST(S(ENVBLOCK))
EVAL ECT+34 L(4) HEX CLIST(S(ECTEXT))
IF &STR(&ENVBLOCK&ECTEXT) = &STR(0000000000000000) THEN DO
 NOTE SPACE(1)
 NOTE 'REXX is not active in this environment.' ASIS
 NOTE SPACE(1)
 RETURN
END
IF &REXX = REXX THEN DO
 %REXXCB ECT(ECT) &XTRACE
END
ELSE DO
 NOTE SPACE(1)
 NOTE 'For REXX control blocks, execute the REXXCB clist,' ASIS
 NOTE '    or execute TSOCB with the REXX operand.       ' ASIS
 NOTE SPACE(1)
END
RETURN
END GETREXX
./ ADD NAME=TSODATA
PROC 0 +
       ALL CURRENT ERROR TCBERROR ANOMALY +
       ASIDLIST() +
       JOBNAME() +
       JOBLIST() +
       ECT() +
       LWA STACK +
       SYMBOLS() +
       XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END

  FROB: PROC 1 IT
  SET NAME_OF_IT = &STR(&IT)
  SYSREF IT
  IF &STR(&IT) ^= THEN SET IT = &NAME_OF_IT(&IT)
  ELSE SET IT =
  RETURN
  END /* FROB */

  UNDOT: PROC 1 IT
  SET NAME_OF_IT = &STR(&IT)
  SYSREF IT
  SET L = &LENGTH(&NRSTR(&IT))
  IF &L < 2 THEN RETURN
  IF &SUBSTR(&L,&NRSTR(&IT)) = . THEN +
   SET IT = &SUBSTR(1:&L-1,&NRSTR(&IT))
  RETURN
  END /* UNDOT */

SYSCALL UNDOT ECT
SYSCALL UNDOT SYMBOLS

SYSCALL FROB ASIDLIST
SYSCALL FROB JOBNAME
SYSCALL FROB JOBLIST
SYSCALL FROB ECT
SYSCALL FROB SYMBOLS

CONTROL LIST

VERBEXIT TSODATA +
         '&ALL &CURRENT &ERROR &TCBERROR &ANOMALY +
          &ASIDLIST &JOBNAME &JOBLIST &ECT &LWA &STACK &SYMBOLS'

./ ADD NAME=VSM
PROC 0 DUMP NODUMP XTRACE
IF &XTRACE ^= THEN CONTROL LIST CONLIST SYMLIST
CONTROL NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
  WRITE *** You must be in IPCS to use this CLIST. ***
  EXIT C(16) Q
END
EVAL 224. PTR CLIST(S(ASCB)
IF &LASTCC ^= 0 THEN DO
 NOTE 'Error accessing ASCB at 224.%' ASIS
 EXIT C(12) Q
END
EVAL &ASCB..+30 PTR CLIST(S(ASCBLDA))
IF &LASTCC ^= 0 THEN DO
 NOTE 'Error accessing ASCBLDA at &ASCB..+30' ASIS
 EXIT C(12) Q
END
EQ LDA &ASCBLDA.. L(264)

IF &DUMP&NODUMP = DUMP THEN %DUMPCB LDA &ASCBLDA.. 264

/**********************************************************************/
/*                                                                    */
/* Format the LDA (VSM local data area).  This contains control info  */
/* about address-space-related virtual storage and VSM control block  */
/* pointers.                                                          */
/*                                                                    */
/**********************************************************************/

CONTROL NOFLUSH
ERROR DO
 ERROR OFF
 NOTE 'Error accessing LDA storage at &ASCBLDA.. somewhere' ASIS
 EXIT C(12) Q
END
EVAL &ASCBLDA..+04 PTR CLIST(S(LDASQAT))  /* Address of the LSQA SQAT */
EQ SQAT &LDASQAT.. L(12)
IF &DUMP&NODUMP = DUMP THEN %DUMPCB SQAT &LDASQAT.. 12

/**********************************************************************/
/*                                                                    */
/* Format the SQAT (size queue anchor table).                         */
/*                                                                    */
/**********************************************************************/

EVAL SQAT+4 SIG CLIST(S(SQATCNT)) /* Number of entries in the table */
EVAL SQAT+8 SIG CLIST(S(SQATMAXS)) /* Maximum size in the table */
NOTE '&EVAL(&SQATCNT) entries in SQAT (max size &EVAL(&SQATMAXS))' ASIS


/**********************************************************************/
/*                                                                    */
/* Format each SQAT entry.                                            */
/*                                                                    */
/**********************************************************************/

SET I = 0
DO WHILE &I LT &SQATCNT
 NOTE         'Entry &EVAL(&I+1) of SQAT' ASIS
 SET BS = &STR(                )
 SET OFFSET = 12+(8*&I)
 EVAL SQAT+&OFFSET.N SIG CLIST(S(SQATSZ)) /* Lower bound of free space
 NOTE '&BS.Lower bound of free space size:  &SQATSZ' ASIS
 EVAL SQAT+&EVAL(&OFFSET+4)N PTR CLIST(S(SQATDFE))
  /* Address of the first DFE on the size queue GE size of lower bound
 NOTE '&BS.DFE address:  &SQATDFE' ASIS
 SET I = &I + 1
END
EVAL &ASCBLDA..+08 PTR CLIST(S(LDAAQAT))  /* Address of the LSQA AQAT */
EQ AQAT &LDAAQAT.. L(722)
IF &DUMP&NODUMP = DUMP THEN %DUMPCB AQAT &LDAAQAT.. 722

/**********************************************************************/
/*                                                                    */
/* Format the AQAT (address queue anchor table).                      */
/*                                                                    */
/**********************************************************************/

./ ADD NAME=VSSA
PROC 0 TCB() XTRACE
IF &XTRACE=XTRACE THEN CONTROL SYMLIST CONLIST LIST
CONTROL NOFLUSH NOCAPS
IF &STR(&SYSPCMD) ^= IPCS THEN DO
 WRITE *** You must be in IPCS to use this CLIST. ***
 EXIT C(16) Q
END
IF &STR(&TCB) = THEN DO
 SET TCB = 0
 EVAL 21D. L(3) HEX CLIST(S(TCB))
 IF &TCB = 0 THEN DO
  EVAL 219. L(3) HEX CLIST(S(TCB))
  IF &TCB = 0 THEN DO
   EVAL 224.?+6C?+5 L(3) HEX CLIST(S(TCB))
   IF &TCB = 0 THEN DO
    NOTE 'TCB unavailable' ASIS
    EXIT C(12) Q
   END
  END
 END
END
ELSE DO
 TCBEXIT YITADDR &NRSTR(&TCB) POSITION(+0)
 IF &LASTCC ^= 0 THEN DO
  NOTE 'Invalid TCB address: &NRSTR(&TCB)' ASIS
  EXIT C(12) Q
 END
 SET TCB = &STR(&YITHEX)
END
EVAL &TCB..+138?+14 PTR CLIST(S(VSSAPTR))
IF &LASTCC = 12 THEN GOTO FAIL
IF &VSSAPTR = 0 THEN GOTO FAIL
TCBEXIT IEAVSSA1 &TCB
EXIT
FAIL: NOTE 'No vector stuff for TCB at &TCB..' ASIS
EXIT
./ ADD NAME=WHERE
PROC 1 ADDRESS STACK ID(WHERE) ASID() XTRACE
/***********************************************************************
/*                                                                     *
/* Author: S. Bacher                                                   *
/*                                                                     *
/* This CLIST displays the module and relative location within module  *
/* of an address.  The address is the single positional parameter and  *
/* must consist of a single hexadecimal value (optionally terminated   *
/* with a period).                                                     *
/*                                                                     *
/* The following control blocks are searched for the address:          *
/*                                                                     *
/*   Job pack area for the job step TCB of the current ASID (CDE's)    *
/*   Pageable link pack area (LPDE's)                                  *
/*   Modified link pack area (CDE's)                                   *
/*   Nucleus map (NUCMAP)                                              *
/*                                                                     *
/***********************************************************************
IF &XTRACE=XTRACE THEN CONTROL CONLIST SYMLIST LIST MSG
IF &STR(&SYSPCMD) = IPCS THEN DO
 SET L = &LENGTH(&STR(&ADDRESS))
 IF (&L = 9 && &SUBSTR(&L,&ADDRESS) = .) | +
    (&L = 8 && &SUBSTR(1,&ADDRESS) > 7) THEN DO
  SET I = 0
  SET A = &SUBSTR(1,&ADDRESS)
  DO WHILE &I LT 8
   SET I = &I + 1
   IF &A = &SUBSTR(&I,89ABCDEF) THEN DO
    SET ADDRESS = &SUBSTR(&I,01234567)&SUBSTR(2:&L,&ADDRESS)
    GOTO DOIT
   END
  END
 END
 DOIT:+
 IF &STACK NE THEN STACK &ADDRESS. REMARK('&ID')
 IF &STR(&ASID) ^= THEN SET XASID = &STR(ASID(&ASID))
 ELSE SET XASID =
 TCBEXIT XITWHR &ADDRESS POS(0) &XASID
END
ELSE DO
 XCMD "XIPWHR &ADDRESS" LIB('SYSPGMR.CMD.LOAD') NOF
END
./ ENDUP
?!
//PANEL    EXEC MDLOAD,BS='6160',TRK1='5',TRK2='1',TO='PANEL'
//SYSIN    DD   DATA,DLM='?!'
./ ADD NAME=DQETBL
)Attr
   ^ type(input ) intens(high) caps(on ) just(asis )
   ! type(output) intens(low ) caps(off) just(asis )
   @ type(output) intens(high) caps(off) just(right)
)Body  Expand(\\)
%-\-\- IPCS - DQE Table for &THING at &ADDRESS &EXTRA              -\-\-
%Subcommand ===>_ZCMD                              \ \%Scroll ===>_AMT +

%Primary command: +Any IPCS subcommand.
%Line commands:   %S+(select FQE's)

%  Type    DQE addr   First FQE  Last FQE   Area     Size
+
)Model
^Z+!Z     !Z         !Z         !Z         !Z       !Z
)Init
 .ZVARS='(DQESEL DQETYPE DQEADDR DQEFFQE DQELFQE DQEAREA DQESIZE)'
 &amt = CSR
 &ZTDMARK = '........................................+
             .......................................'
)Reinit
)Proc
 &TBLCMD = &Z
 VER(&DQESEL,LIST,S,X)
 IF (&DQESEL = S)
  &TBLCMD = '%IPVSFQE'
 IF (&DQESEL = X)
  &TBLCMD = '%IPVSFQE XTRACE'
)End
./ ADD NAME=FQETBL
)Attr
   ^ type(input ) intens(high) caps(on ) just(asis )
   ! type(output) intens(low ) caps(off) just(asis )
   @ type(output) intens(high) caps(off) just(right)
)Body  Expand(\\)
%-\-\- IPCS - FQE Table for DQE at &ADDRESS -\-\-
%Subcommand ===>_ZCMD                              \ \%Scroll ===>_AMT +

%Primary command: +Any IPCS subcommand.
%Line commands:   %L+(list) %D+(dump)

%          FQE addr     From     To        Size
+
)Model
^Z+       !Z           !Z       !Z        !Z
)Init
 .ZVARS='(FQESEL FQEADDR FQEAREA EFQEAREA FQESIZE)'
 &amt = CSR
 &ZTDMARK = '........................................+
             .......................................'
)Reinit
)Proc
 &TBLCMD = &Z
 VER(&FQESEL,LIST,L,D)
 IF (&FQESEL = L)
  &TBLCMD = 'LIST &FQEAREA. L(X''&FQESIZE'')'
 IF (&FQESEL = D)
  &TBLCMD = '%DUMPCB AREA &FQEAREA. X''&FQESIZE'''
)End
./ ADD NAME=SPQETBL
)Attr
   ^ type(input ) intens(high) caps(on ) just(asis )
   ! type(output) intens(low ) caps(off) just(asis )
   @ type(output) intens(high) caps(off) just(right)
)Body  Expand(\\)
%-\-\- IPCS - SPQE Table for TCB at &ADDRESS -\-\-
%Subcommand ===>_ZCMD                              \ \%Scroll ===>_AMT +

%Primary command: +Any IPCS subcommand.
%Line commands:   %S+(select DQE's)

%  Qtype   SPQE addr  SPQA addr  Owning TCB Subpool  Key  Shared
+
)Model
^Z+!Z     !Z         !Z         !Z         @Z  +   @Z  +  !Z
)Init
 .ZVARS='(SPQESEL SPQEQTYP SPQEADDR SPQESPQA SPQETCB SPQEID SPQEKEY SPQESHR)'
 &amt = CSR
 &ZTDMARK = '........................................+
             .......................................'
)Reinit
)Proc
 &TBLCMD = &Z
 VER(&SPQESEL,LIST,S,X)
 IF (&SPQESEL = S,X)
  &TBLCMD = '%IPVSDQE THING(SPQE) POINTER(SPQESPQA) ADDRESS(SPQEADDR) +
                      EXTRA(''SPQA SPQESPQA'')'
  IF (&SPQESEL = X)
   &TBLCMD = '&TBLCMD XTRACE'
)End
./ ADD NAME=SPTTBL
)Attr
   ^ type(input ) intens(high) caps(on ) just(asis )
   ! type(output) intens(low ) caps(off) just(asis )
   @ type(output) intens(high) caps(off) just(right)
)Body  Expand(\\)
%-\-\- IPCS - SPT Table for GDA at &ADDRESS -\-\-
%Subcommand ===>_ZCMD                              \ \%Scroll ===>_AMT +

%Primary command: +Any IPCS subcommand.
%Line commands:   %S+(select DQE's)

%  SPT addr  Subpool  Key    BELOW-DQE's      ANYWHERE-DQE's      ABOVE-DQE's
+
)Model
^Z+!Z          @Z  @Z   +!Z       !Z       !Z       !Z       !Z       !Z
)Init
 .ZVARS = '(SPTSEL SPTADDR SPTSP SPTPK +
            SPTFBDQE SPTLBDQE SPTFADQE SPTLADQE SPTFEDQE SPTLEDQE)'
 &amt = CSR
 &ZTDMARK = '........................................+
             .......................................'
)Reinit
)Proc
 &TBLCMD = &Z
 VER(&SPTSEL,LIST,S,X)
 IF (&SPTSEL = S,X)
  &TBLCMD = '%IPVSDQE THING(SPT) POINTER(SPTADDR) +
                      ADDRESS(SPTADDR) EXTRA('''')'
  IF (&SPTSEL = X)
   &TBLCMD = '%IPVSDQE XTRACE'
)End
./ ADD NAME=IPCASID
)ATTR
       \   TYPE(OUTPUT) CAPS(OFF) INTENS(HIGH) JUST(RIGHT)
)BODY
%--------------------  IPCS - Choose an ASID  ----------------------------------
%COMMAND ===>_ZCMD
+
  Type an%S+next to one of the address spaces displayed, or
  enter an ASID number (ddd or X'xxx') in the field provided.

%      ASID NUMBER         ASCB     JOBNAME   DESCRIPTION

_Z\DEFASID%(X'&DEFASIDX') +&DEFASCB%&DEFJOBN +Assigned by IPCS (SETDEF)
_Z\CURASID%(X'&CURASIDX') +&CURASCB%&CURJOBN +From current ASCB
_Z\HDRASID%(X'&HDRASIDX') +&HDRASCB%&HDRJOBN +From dump header

%Other ASID if desired ===>_OTHASID+


)INIT
 .ZVARS = '(DEFSEL CURSEL HDRSEL)'
 .CURSOR = ZCMD
 &OTHASID = &Z
 &DEFSEL = &Z
 &CURSEL = &Z
 &HDRSEL = &Z
 IF (&IPASID = &DEFASID) &DEFSEL = S
 IF (&IPASID = &CURASID) &CURSEL = S
 IF (&IPASID = &HDRASID) &HDRSEL = S
 IF (&DEFASID = '***')   &DEFSEL = '-'
 IF (&CURASID = '***')   &CURSEL = '-'
 IF (&HDRASID = '***')   &HDRSEL = '-'
 &TEMP = '&DEFSEL.&CURSEL.&HDRSEL'
 IF (&TEMP = SSS,SS-,S-S,S--)
  &IPASID  = &DEFASID
  &IPASIDX = &DEFASIDX
  &IPASCB  = &DEFASCB
  &IPJOBN  = &DEFJOBN
  VPUT (IPASID IPASIDX IPASCB IPJOBN) SHARED
  .RESP = ENTER
 IF (&TEMP = -SS,-S-)
  &IPASID  = &CURASID
  &IPASIDX = &CURASIDX
  &IPASCB  = &CURASCB
  &IPJOBN  = &CURJOBN
  VPUT (IPASID IPASIDX IPASCB IPJOBN) SHARED
  .RESP = ENTER
 IF (&TEMP = --S)
  &IPASID  = &HDRASID
  &IPASIDX = &HDRASIDX
  &IPASCB  = &HDRASCB
  &IPJOBN  = &HDRJOBN
  VPUT (IPASID IPASIDX IPASCB IPJOBN) SHARED
  .RESP = ENTER
)PROC
 IF (&ZCMD ^= &Z) .MSG = ISPZ001
 IF (&OTHASID ^= &Z)
  &IPASID  = &Z
  &IPASIDX = &Z
  &IPASCB  = &Z
  &IPJOBN  = &Z
 ELSE
  VER (&DEFSEL,LIST,S,'-')
  VER (&CURSEL,LIST,S,'-')
  VER (&HDRSEL,LIST,S,'-')
  IF (&DEFSEL ^= S)
   IF (&CURSEL ^= S)
    IF (&HDRSEL ^= S)
     .CURSOR = DEFSEL
     .MSG = IPZ007
  IF (&DEFSEL = S)
   IF (&CURSEL = S)
    IF (&DEFASID ^= &CURASID)
     .CURSOR = DEFSEL
     .MSG = IPZ006
   IF (&HDRSEL = S)
    IF (&DEFASID ^= &HDRASID)
     .CURSOR = DEFSEL
     .MSG = IPZ006
   &IPASID  = &DEFASID
   &IPASIDX = &DEFASIDX
   &IPASCB  = &DEFASCB
   &IPJOBN  = &DEFJOBN
  IF (&CURSEL = S)
   IF (&HDRSEL = S)
    IF (&CURASID ^= &HDRASID)
     .CURSOR = CURSEL
     .MSG = IPZ006
   &IPASID  = &CURASID
   &IPASIDX = &CURASIDX
   &IPASCB  = &CURASCB
   &IPJOBN  = &CURJOBN
  IF (&HDRSEL = S)
   &IPASID  = &HDRASID
   &IPASIDX = &HDRASIDX
   &IPASCB  = &HDRASCB
   &IPJOBN  = &HDRJOBN
  VPUT (IPASID IPASIDX IPASCB IPJOBN) SHARED
)END
./ ADD NAME=IPCMD
%------------------  IPCS - Command Entry --------------------------------------
%IPCS COMMAND ===>_ICMD
%
+Dumptitle:%&IPTIT1
+          %&IPTIT2
%
%---------------------IPCS Commands+and Abbreviations%--------------------------
+
+
%ASMCHECK,+ASMK       |%LIST,    +L                                            +
%COMCHECK,+COMK       |%LISTDUMP,+LDMP                                         +
%COMPARE, +COMP       |%LISTMAP, +LMAP                                         +
%DROPMAP, +DROPM      |%LISTSYM, +LSYM                                         +
%DROPSYM, +DROPS      |%SCAN     +                                             +
%ENQCHECK,+ENQK       |%SETDEF,  +SETD                                         +
%EQUATE,  +EQ         |%STACK    +                                             +
%FIND,    +F          |%STATUS,  +ST                                           +
%FINDMOD, +FMOD       |%TCBEXIT, +TCBX                                         +
%FINDUCB, +FINDU      |%TSO      +                                             +
%IOSCHECK,+IOSK       |%VERBEXIT,+VERBX                                        +
)INIT
  .HELP = IPHNONE
  .CURSOR = ICMD
)PROC
  &SEL = 'PGM(BLSGSCMD) PARM(&ICMD)'
  VER (&ICMD,NONBLANK)
  &FIRST6 = TRUNC(&ICMD,6)
  &FIRST5 = TRUNC(&ICMD,5)
  &REST5 = .TRAIL
  IF (&FIRST5 = HELP)
   IF (&FIRST6 ^= HELP)
    &ICMD = 'HELP,&REST5'
)END

  Source:

  "MVS/XA2.1.2 Installation and User's Guide"
  IBM International Systems Centers
  GG24-1596-1
  (c) Copyright International Business Machines Corporation 1983, 1984

  Page 157

./ ADD NAME=IPCONF
%------------------  IPCS CONFIRMATION -----------------------------------------
%COMMAND ===>_ZCMD
+
+ Dataset:%&IPDSN
+
+ Dumptitle:%&IPTIT1
+           %&IPTIT2
+
+
+ INSTRUCTION:
+
+
+   Press%ENTER+to confirm request to%&IPACT..
+
+   Press%END to cancel request.
+
)PROC
  IF (&ZCMD ^= ' ') .MSG = ISPZ001
)END

  Source:

  "MVS/XA2.1.2 Installation and User's Guide"
  IBM International Systems Centers
  GG24-1596-1
  (c) Copyright International Business Machines Corporation 1983, 1984

  Page 157

./ ADD NAME=IPDAN
%------------------  IPCS - PRIMARY SELECTION PANEL  ---------------------------
%SELECT OPTION ===>_ZCMD                                     +Job:%&IPJOBN
%                                                           +ASID:%&ASIDJUNK
+Dumptitle:%&IPTIT1
+          %&IPTIT2
%
%   H %HEADER  +- Display dump header diagnostic information   %(CSDL)
%   V %VIEW    +- View task control blocks in ISPF table format%(CSDL)
%   A +ANALYSIS - IPCS dump component data analysis
%   B +BROWSE   - Browse dump
%   D +SETDEF   - Review and change IPCS defaults
%   F +FORMAT   - View or print formatted dump
%   I +IPCS     - Enter IPCS commands
%   L +LISTDUMP - Display dump inventory
%   S +SUMMARY  - View or print dump summary
%
%&IPDT+&IPDANLT
%&IPDC+&IPDANLC
%
+JOB STATEMENT INFORMATION (required for options &IPDANJO) :
% ===>_ZLLGJOB1
% ===>_ZLLGJOB2
% ===>_ZLLGJOB3
% ===>_ZLLGJOB4
)INIT
  .HELP = IPHNONE
  VGET (IPASID IPASIDX) SHARED
  &ASIDJUNK = '&IPASID (X''&IPASIDX'')'
  IF (&IPDSN = &Z)
    .RESP = END
  IF (&IPDSN = 0,1)
    &IPDT = '     '
    &IPDANLT = ''
    &IPDC = '     '
    &IPDANLC = ''
    &IPDANJO = 'F,S'
  IF (&IPDSN ^= 0,1,&Z)
    &IPDT = '   M '
    &IPDANLT = 'MOVE     - Move &IPDSN'
    &IPDC = '   C '
    &IPDANLC = 'CLEAR    - Clear &IPDSN'
    &IPDANJO = 'C,F,M,S'
)REINIT
  VGET (IPASID IPASIDX) SHARED
  REFRESH(IPJOBN,IPASID,IPASIDX,ASIDJUNK)
)PROC
  IF (&IPDSN = 0,1)
    &SEL = TRANS( TRUNC (&ZCMD,'.')
                  A,'PGM(BLSGDCDA) NEWAPPL(BLSL) PASSLIB'
                  B,'PGM(BLSLDISP) NEWAPPL(BLSL) PASSLIB'
                  D,'CMD(IPDFS)    MODE(FSCR)'
                  F,'CMD(IPFORM)   MODE(FSCR)'
                  H,'CMD(IPHEADER) MODE(FSCR)'
                 HT,'CMD(IPHEADER XTRACE) MODE(FSCR)'
                  I,'PANEL(IPCMD)'
                  L,'PGM(BLSGDUIN) NEWAPPL(BLSL) PASSLIB'
                  S,'PANEL(IPSUM)'
                  V,'CMD(IPVIEW)   MODE(FSCR)'
                 VT,'CMD(IPVIEWXTRACE)   MODE(FSCR)'
                ' ',' '
                  *,'?' )
  IF (&IPDSN ^= 0,1)
    &SEL = TRANS( TRUNC (&ZCMD,'.')
                  A,'PGM(BLSGDCDA) NEWAPPL(BLSL) PASSLIB'
                  B,'PGM(BLSLDISP) NEWAPPL(BLSL) PASSLIB'
                  C,'CMD(IPCLEAR)  MODE(FSCR)'
                  D,'CMD(IPDFS)    MODE(FSCR)'
                  F,'CMD(IPFORM)   MODE(FSCR)'
                  H,'CMD(IPHEADER) MODE(FSCR)'
                 HT,'CMD(IPHEADER XTRACE) MODE(FSCR)'
                  I,'PANEL(IPCMD)'
                  L,'PGM(BLSGDUIN) NEWAPPL(BLSL) PASSLIB'
                  S,'PANEL(IPSUM)'
                  M,'CMD(IPMOVE)   MODE(FSCR)'
                 MT,'CMD(IPMOVE XTRACE)   MODE(FSCR)'
                  V,'CMD(IPVIEW)   MODE(FSCR)'
                 VT,'CMD(IPVIEWXTRACE)   MODE(FSCR)'
                ' ',' '
                  *,'?' )
  &ZTRAIL = .TRAIL
)END

  Source:

  "MVS/XA2.1.2 Installation and User's Guide"
  IBM International Systems Centers
  GG24-1596-1
  (c) Copyright International Business Machines Corporation 1983, 1984

  Page 153

./ ADD NAME=IPDCATBL
)Attr
   @ type(output) intens(low ) caps(off) just(asis )
   ? type(output) intens(low ) caps(off) just(right)
   ! type(output) intens(high) caps(off) just(asis )
)Body  Expand(\\)
%-\-\- IPCS - System Dumps in Your Catalog -\-\-
%Command ===>_zcmd                                 \ \%Scroll ===>_amt +
%
+Selection codes: %S+- select dump for IPCS processing
+                 %P+- purge and clear dump
+                 %H+- HSM-recall dump dataset
%   Name                                              Volume
+
)Model
_Z!DCADSN                                             @DCAVOL
)Init
  .ZVARS = '(DCASEL)'
  &amt = CSR
  &ZTDMARK = &Z
)Reinit
)Proc
  IF (&ZCMD ^= &Z) .MSG = ISPZ001
)End
./ ADD NAME=IPDEBTBL
)Attr
   ! type(output) intens(low ) caps(off) just(asis )
)Body  Expand(\\)
%-\-\- IPCS - DEB Table for TCB at &TCBADDR -\-\-
%Subcommand ===>_DEBCMD                            \ \%Scroll ===>_AMT +
%
%Primary commands: %?+- toggle row display between DEB info and DCB info (DSN).
                   %Other+- any IPCS subcommand.
%Line commands:   +None
%IPCS CLIST:      +Any command or CLIST that takes a DCB(addr) operand.
%
&DEBHEAD
+
)Model
&DEBMODL
)Init
  &amt = CSR
  .ZVARS = '(DEBSEL)'
  &ZTDMARK = '........................................+
              .......................................'
)Reinit
IF (&DEBCMD = ?)
 &DEBCMD = &Z
 IF (&DEBNUM = 1)
  &DEBHEAD = '&H2'
  &DEBMODL = '&M2'
  &NEWNUM = 2
 IF (&DEBNUM = 2)
  &DEBHEAD = '&H1'
  &DEBMODL = '&M1'
  &NEWNUM = 1
 &DEBNUM = &NEWNUM
REFRESH(DEBHEAD,DEBMODL,DEBNUM)
)Proc
IF (&DEBCMD = ?)
 &DEBCMD = &Z
 IF (&DEBNUM = 1)
  &DEBHEAD = '&H2'
  &DEBMODL = '&M2'
  &NEWNUM = 2
 IF (&DEBNUM = 2)
  &DEBHEAD = '&H1'
  &DEBMODL = '&M1'
  &NEWNUM = 1
 &DEBNUM = &NEWNUM
)End
 See 'SYSPGMR.CMD.CLIST(IPDEB)' for table header and model lines.
./ ADD NAME=IPDEF
%------------------  IPCS - DEFAULT VALUES -------------------------------------
%COMMAND ===>_ZCMD
+
+Dumptitle:%&IPTIT1
+          %&IPTIT2
+
+  Address space  %==>_IPQUAL
+
+  Message routing%==>_IPROUTE
+
+  Message control%==>_IPCNTRL
+
+  Display content%==>_IPDSP
+
+
+
+Press%ENTER+to update defaults.
+
+Press%END+to exit without an update.
)INIT
  &IPCNTRL = 'FLAG(&IPFLG) &IPCON &IPVER'
  &IPROUTE = '&IPPRI &IPTER'
)PROC
  IF (&ZCMD ^= ' ') .MSG = ISPZ001
  IF (&IPDSP=' ') &IPDSP='NOMACHINE REMARK REQUEST NOSTORAGE SYMBOL'
)END

  Source:

  "MVS/XA2.1.2 Installation and User's Guide"
  IBM International Systems Centers
  GG24-1596-1
  (c) Copyright International Business Machines Corporation 1983, 1984

  Page 156

./ ADD NAME=IPDLDTBL
)Attr
   @ type(output) intens(low ) caps(off) just(asis )
   ? type(output) intens(low ) caps(off) just(right)
   ! type(output) intens(high) caps(off) just(asis )
)Body  Expand(\\)
%-\-\- IPCS - Current Dump Directory Contents -\-\-
%Command ===>_zcmd                                 \ \%Scroll ===>_amt +
%
+Selection codes: %S+- select dump for IPCS processing
+                 %P+- purge and clear dump
+                 %H+- HRECALL dump dataset
+                 %A+- display availability of dump dataset
+
%   Name                                            Qualification     Blocks
+
)Model
_Z!DLDDSN                                          @DLDQUAL          ?DLDBLKS
)Init
  .ZVARS = '(DLDSEL)'
  &amt = CSR
  &ZTDMARK = &Z
)Reinit
)Proc
  IF (&ZCMD ^= &Z) .MSG = ISPZ001
)End
Notes:
 DLDBYTES is part of the table but not displayed - we have no room.
./ ADD NAME=IPERROR
%----------------------------  IPCS DIALOG ERROR  ------------------------------
%COMMAND ===>_ZCMD                                                             +
%
%
%******************************************************************************
%*+                                                                          %*
%*+ %Dialog program BLSG ended with return code &MYCC..                      %*
%*+                                                                          %*
%*+  IPCS dialog support may be used only in an ISPF Version 2 session       %*
%*+  started under control of the IPCS TSO command.                          %*
%*+                                                                          %*
%*+                                                                          %*
%*+  Press%ENTER+key to terminate the dialog.                                %*
%*+                                                                          %*
%******************************************************************************
)INIT
)PROC
  IF (&ZCMD ^= ' ') .MSG = ISPZ001      /* INVALID COMMAND            */
  .RESP = END
)END
./ ADD NAME=IPFORM
%------------------  IPCS - PRINT DUMP -----------------------------------------
%COMMAND ===>_ZCMD
+Dumptitle:%&IPTIT1
+          %&IPTIT2
+
+  Outputdevice :%===>_Z+ (P for printer / blank for display)
+
%>_Z+ ASMDATA  |IOSDATA %===>_IPIOS                                            +
%>_Z+ CPUDATA  |          ACTVUCBS,ALLUCB,SMGRBLKS,EXCEPTION
%>_Z+ CVTMAP   |PRINT   %===>_IPPRT1                                           +
%>_Z+ GRSTRACE |        %===>_IPPRT2                                           +
%>_Z+ LOGDATA  |          CURRENT,NUCLEUS,SQA,CSA,
%>_Z+ LPAMAP   |          STORAGE=ASID(as1,...)=(bbbbbbbb,eeeeeeee)
%>_Z+ MTRACE   |          JOBNAME=(job1,....)                                  +
%>_Z+ NUCMAP   |TRACE   %===>_IPTRC                                            +
%>_Z+ RSMDATA  |          ALL,CURRENT,ASID(as1,...),JOBNAME(job1,...)          +
%>_Z+ SRMDATA  |VSMDATA %===>_IPVSM                                            +
%>_Z+ VTAMMAP  |          ALL,CURRENT,ERROR,TCBERROR,NOGLOBAL,
%>_Z+ SUMDUMP  |          ASIDLIST(as1,...),JOBNAME(job1,...)                  +
+  CVT-address   %===>_IPCVT     +
+  SEGTAB-address%===>_IPSEG     +      Sort? %===>_IPZ+
+
+Press%END+to exit without output
)INIT
  &ZCMD = ' '
  .ZVARS = '(IPD,IPP1,IPP2,IPP3,IPP4,IPP5,IPP6,IPP7,IPP8,IPP9,+
             IPP10,IPP11,IPP12)'
  .CURSOR = IPD
)PROC
  IF (&ZCMD ^= ' ') .MSG = ISPZ001
  VER  (&IPD,LIST,' ',P)
  &IPSORT = TRANS(TRUNC(&IPZ,1) ' ',' ' Y,SORT N,' ')
  VPUT (IPP1,IPP2,IPP3,IPP4,IPP5,IPP6,IPP7,IPP8,IPP9,
        IPP10,IPP11,IPP12) PROFILE
  VPUT (IPIOS,IPPRT1,IPPRT2,IPTRC,IPVSM,IPD,IPSORT) PROFILE
)END

  Source:

  "MVS/XA2.1.2 Installation and User's Guide"
  IBM International Systems Centers
  GG24-1596-1
  (c) Copyright International Business Machines Corporation 1983, 1984

  Page 154

./ ADD NAME=IPHNONE
%---------------------------- IPCS - TUTORIAL ----------------------------------
%SELECTION ===>_ZCMD                                                           +
%
%                   --------------------------------------
                    | INTERACTIVE PROBLEM CONTROL SYSTEM |
                    --------------------------------------
+
%      ******************************************************************
       *                                                                *
       *   There is no tutorial available for the function you are      *
       *   currently executing.  Refer to the IPCS manual or the        *
       *   HELP member for IPCS for more information.                   *
       *                                                                *
       *  +Press%END key+to terminate the tutorial and return to IPCS. %*
       *                                                                *
       ******************************************************************

)INIT
)PROC
)END
./ ADD NAME=IPMOVE
%------------------  IPCS CONFIRMATION -----------------------------------------
%COMMAND ===>_ZCMD
+
+Dumptitle:%&IPTIT1
+          %&IPTIT2
+
+  Dataset:%&IPDSN
+
+  &IPSDSCN1
+  &IPSDSCN2
+
+  New dump dataset name ===>_IPSDSN                              +
+
+
+  The old dump dataset will be copied to the new one and then cleared.
+
+    Press%ENTER+to confirm request to move and clear.
+
+    Press%END to cancel request.
+
)INIT
  IF  (&IPSDSN = &Z)
   &IPSDSN = 'Z&ZYEAR&ZMONTH&ZDAY..XXXXXXXX.XXXXXXXX.XXXXX.DUMP'
  .CURSOR = IPSDSN
)PROC
  IF  (&ZCMD ^= ' ') .MSG = ISPZ001
  VER (&IPSDSN,NB,DSNAME)
  &TEMP = TRUNC(&IPSDSN,1)
  IF (&TEMP ^= '''')
    &IPSDSN = '''&ZPREFIX..&IPSDSN'''
)END

  Compare panel IPSAVE.

./ ADD NAME=IPPRIM
%------------------  IPCS - INITIALIZATION -------------------------------------
%SELECT OPTION ===>_ZCMD
%
%   B+(blank)     - Perform IPCS functions on a dump dataset
%
%   A +ACTIVE     - Perform IPCS functions on active main storage
%   C +CATALOG    - List dump datasets in your catalog
%   L +LISTDUMP   - List dump datasets in dump directory
%   S +SYSDSCAN   - List titles of SYS1.DUMPnn datasets
%   I +IBM        - Invoke IBM IPCS dialog
%   X +EXIT       - Terminate IPCS Dialog
+
+Press%END+to terminate IPCS session
+
+...............................................................................
+
%DUMP DATASET (mandatory for option Blank)
+
+   SYS1.DUMPnn SUFFIX%===>_Z +
+   OTHER DATASET NAME%===>_IPDDSN
+
+USE EXISTING DDIR-ENTRY FOR THIS DUMP%===>_IPUDD +(YES or NO)
%
)INIT
  .ZVARS = '(IPSF)'
  .HELP = TIPPRIM
  .CURSOR = ZCMD
  &IPFI = ' '
  IF (&IPDDSN ^= ' ')
    &IPDSN = ' '
  IF (&IPDSN ^= ' ',0,1)
    &IPDDSN = '&IPDSN'
  IF (&IPDDSN ^= ' ')
    &IPSF = ' '
  IF (&IPDDSN = ' ')
    IF (&IPSF = ' ')
      &IPSF = 00
    &TEMP = TRUNC(&IPSF,1)
    IF (&IPSF = &TEMP)
      &IPSF = '0&IPSF'
  &IPUDD = 'YES'
  &IPDSN = ' '
)PROC
  &IPAMS = TRANS(TRUNC(&ZCMD,'.') A,YES AT,YES *,NO)
  &IPUDD = TRANS(TRUNC(&IPUDD,1) ' ',' ' N,NO *,YES)

  &IPDSN = 0
  &IPFI = ' ' /* we don't use file name */
  IF (&ZCMD ^= ' ',T,B,BT)
    &IPDSN = 1
  IF (&ZCMD = ' ',T,B,BT)
    IF (&IPDDSN ^= ' ')
      IF (&IPSF ^= ' ') .MSG = IP007
      &IPDSN = &IPDDSN
    IF (&IPDDSN = ' ')
      &TEMP = TRUNC(&IPSF,1)
      IF (&IPSF = &TEMP)
        &IPSF = '0&IPSF'
      VER (&IPSF,NB,PICT,'NN')
      VER (&IPSF,NB,RANGE,0,9)
      &IPDSN = '''SYS1.DUMP&IPSF'''
  IF (&IPDSN ^= ' ',0,1)
    &TEMP = TRUNC(&IPDSN,':')
    IF (&TEMP = &IPDSN)
     &TEMP = TRUNC(&IPDSN,1)
     IF (&TEMP ^= '''')
       &IPDSN = '''&ZPREFIX..&IPDSN'''
  VPUT (IPSF,IPDDSN) PROFILE
  VPUT (IPDSN,IPFI) SHARED
  &SEL = TRANS( TRUNC (&ZCMD,'.')
              ' ','CMD(IPDSN)          MODE(FSCR)'
                B,'CMD(IPDSN)          MODE(FSCR)'
                T,'CMD(IPDSN   XTRACE) MODE(LINE)'
               BT,'CMD(IPDSN   XTRACE) MODE(LINE)'
                A,'CMD(IPDSN)          MODE(FSCR)'
               AT,'CMD(IPDSN   XTRACE) MODE(LINE)'
                C,'CMD(IPDCAT)         MODE(FSCR)'
               CT,'CMD(IPDCAT  XTRACE) MODE(LINE)'
                L,'CMD(IPDLIST)        MODE(FSCR) PASSLIB NEWAPPL(ISR)'
               LT,'CMD(IPDLIST XTRACE) MODE(LINE) PASSLIB NEWAPPL(ISR)'
                S,'CMD(IPDSCAN)        MODE(FSCR) PASSLIB NEWAPPL(ISR)'
               ST,'CMD(IPDSCAN XTRACE) MODE(LINE) PASSLIB NEWAPPL(ISR)'
                I,'PANEL(BLSPPRIM) NEWAPPL(BLSG) PASSLIB'
                X,'EXIT'
                *,'?' )
  &ZTRAIL = .TRAIL
)END

  Source:

  "MVS/XA2.1.2 Installation and User's Guide"
  IBM International Systems Centers
  GG24-1596-1
  (c) Copyright International Business Machines Corporation 1983, 1984

  Page 152

./ ADD NAME=IPRBTBL
)Attr
   ! type(output) intens(low ) caps(off) just(asis )
   @ type(output) intens(high) caps(off) just(asis )
)Body  Expand(\\)
%-\-\- IPCS - RB Table for TCB at &TCBADDR -\-\-
%Subcommand ===>_IRBCMD                            \ \%Scroll ===>_AMT +
   %IPCS CLIST:   +Any command or CLIST that takes an RB(addr) operand.
%  /IPCS Clist //Address  Type  CDE name  IC  PSW                Where
+
)Model
_Z+/_IRBEXIT  +//!Z      !Z    !IRBNAME  @Z  !IRBPSW1 !IRBPSW2  !IRBWHERE

              @R0  !IRBREG0   @R1  !IRBREG1   @R2  !IRBREG2   @R3  !IRBREG3
              @R4  !IRBREG4   @R5  !IRBREG5   @R6  !IRBREG6   @R7  !IRBREG7
              @R8  !IRBREG8   @R9  !IRBREG9   @R10 !IRBREGA   @R11 !IRBREGB
              @R12 !IRBREGC   @R13 !IRBREGD   @R14 !IRBREGE   @R15 !IRBREGF

)Init
  .ZVARS = '(IRBSEL IRBADDR IRBTYPE IRBINT)'
  &amt = CSR
  &ZTDMARK = '........................................+
              .......................................'
  &R0 = 'R0 ='
  &R1 = 'R1 ='
  &R2 = 'R2 ='
  &R3 = 'R3 ='
  &R4 = 'R4 ='
  &R5 = 'R5 ='
  &R6 = 'R6 ='
  &R7 = 'R7 ='
  &R8 = 'R8 ='
  &R9 = 'R9 ='
  &R10= 'R10='
  &R11= 'R11='
  &R12= 'R12='
  &R13= 'R13='
  &R14= 'R14='
  &R15= 'R15='
)Reinit
)Proc
  VPUT (IRBSEL IRBEXIT IRBADDR IRBNAME IRBINT IRBPSW1 IRBPSW2) SHARED
)End
%Primary command: +Any IPCS subcommand.
%Line commands:   +None
./ ADD NAME=IPSAVE
%------------------  IPCS CONFIRMATION -----------------------------------------
%COMMAND ===>_ZCMD
+
+Dumptitle:%&IPTIT1
+          %&IPTIT2
+
+  Dataset:%&IPDSN
+
+  &IPSDSCN1
+  &IPSDSCN2
+
+  New dump dataset name ===>_IPSDSN                              +
+
+
%  Note:+ The above new dataset will be created as new via batch job.
+
+
+    Press%ENTER+to confirm request to save and clear.
+
+    Press%END to cancel request.
+
)INIT
  IF  (&IPSDSN = &Z)
   &IPSDSN = 'Z&ZYEAR&ZMONTH&ZDAY..XXXXXXXX.XXXXXXXX.XXXXX.DUMP'
  .CURSOR = IPSDSN
)PROC
  IF  (&ZCMD ^= ' ') .MSG = ISPZ001
  VER (&IPSDSN,NB,DSNAME)
  &TEMP = TRUNC(&IPSDSN,1)
  IF (&TEMP ^= '''')
    &IPSDSN = '''&ZPREFIX..&IPSDSN'''
)END

  Source:

  "MVS/XA2.1.2 Installation and User's Guide"
  IBM International Systems Centers
  GG24-1596-1
  (c) Copyright International Business Machines Corporation 1983, 1984

  Page 157

  Copied from panel IPCONF.

./ ADD NAME=IPSDSTBL
)Attr
   @ type(output) intens(low ) caps(off) just(asis )
   ! type(output) intens(high) caps(off) just(asis )
)Body  Expand(\\)
%-\-\- IPCS - Current System Dumps -\-\-
%Command ===>_zcmd                                 \ \%Scroll ===>_amt +
%
+Selection codes: %S+- select old dump for IPCS processing
+                 %N+- select new dump for IPCS processing
+                 %B+- browse AUTOMATE dump listing
+                 %P+- purge and clear dump
+
%  Name        Date       Time   Title
+
)Model
_Z!Z          @Z         @Z     @Z
)Init
  .ZVARS = '(SDSSEL SDSDUMP SDSDATE SDSTIME SDSTITLE)'
  &amt = CSR
  &ZTDMARK = &Z
)Reinit
)Proc
  IF (&ZCMD ^= &Z) .MSG = ISPZ001
)End
./ ADD NAME=IPSUM
%------------------  IPCS - SUMMARY COMMAND ------------------------------------
%COMMAND ===>_ZCMD
+Dumptitle:%&IPTIT1
+          %&IPTIT2
+
+    %blank+Display Summary
+    %P    +Print Summary
+
%  ADDRESS SPACE SELECTION :
%>_Z+ ALL         all address spaces
%>_Z+ CURRENT     active at time of dump
%>_Z+ ERROR       error indicators on
%>_Z+ TCBERROR    containing TCB in error
%>_Z+ JOBLIST  %===>_IPJOB                                 +(separate by commas)
%>_Z+ ASIDLIST %===>_IPASID                                +(separate by commas)
%  REPORT OPTIONS :
%>_Z+ KEYFIELD    key fields of ASCB, TCB and RB
%>_Z+ TCBSUMMARY  summary of TCBs
%>_Z+ JOBSUMMARY  status of address spaces by jobname
%>_Z+ FORMAT      all major control blocks
%>_Z+ REGISTERS   display registers per TCB/RB
+
+Press%END+to exit without summary
)INIT
  .HELP = IPHNONE
  .ZVARS = '(IPA1,IPA2,IPA3,IPA4,IPA5,IPA6,IPR1,IPR2,IPR3,IPR4,IPR5)'
  &IPAS = ' '
  &IPRS = ' '
)PROC
  VER (&ZCMD,LIST,' ',P,MSG=ISPZ001)
  IF (&IPA1^= ' ') &IPAS = 'ALL '
  IF (&IPA1 = ' ')
    IF (&IPA2^= ' ') &IPAS = 'CURRENT '
    IF (&IPA3^= ' ') &IPAS = '&IPAS ERROR '
    IF (&IPA4^= ' ') &IPAS = '&IPAS TCBERROR '
    IF (&IPA5^= ' ') &IPAS = '&IPAS JOBLIST(&IPJOB) '
    IF (&IPA6^= ' ') &IPAS = '&IPAS ASIDLIST(&IPASID) '
  IF (&IPR1^= ' ') &IPRS = 'KEYFIELD '
  IF (&IPR2^= ' ') &IPRS = '&IPRS TCBSUMMARY '
  IF (&IPR3^= ' ') &IPRS = '&IPRS JOBSUMMARY '
  IF (&IPR4^= ' ') &IPRS = '&IPRS FORMAT '
  IF (&IPR5^= ' ') &IPRS = '&IPRS REGISTERS '
  VPUT (IPA1,IPA2,IPA3,IPA4,IPA5,IPA6,IPR1,IPR2,IPR3,IPR4,IPR5) PROFILE
  VPUT (IPAS,IPRS) PROFILE
  &ZSEL = TRANS(TRUNC(&ZCMD,'.')
          P,'CMD(IPPSUM) MODE(FSCR)'
        ' ','PGM(BLSGSCMD) PARM(SUMM &IPAS &IPRS)'
        '*','?')
)END

  Source:

  "MVS/XA2.1.2 Installation and User's Guide"
  IBM International Systems Centers
  GG24-1596-1
  (c) Copyright International Business Machines Corporation 1983, 1984

  Page 155

./ ADD NAME=IPSYS1
%------------------  IPCS - COPY &IPDSN ----------------------------------------
%COMMAND ===>_ZCMD
+
+
+  Dataset:%&IPDSN
+
+  New dump dataset name ===>_IPNEWDSN                            +
+
+
%  Note:+ The above new dataset will be created ON LINE.
+
+    (Leave blank to continue using &IPDSN as your dump dataset.)
+
+
+    Press%ENTER+to confirm request to copy and clear &IPDSN..
+
+    Press%END to cancel request.
+
)INIT
  .CURSOR = IPNEWDSN
)PROC
  IF  (&ZCMD ^= ' ') .MSG = ISPZ001
  VER (&IPNEWDSN,DSNAME)
  IF (&IPNEWDSN ^= &Z)
   &TEMP = TRUNC(&IPNEWDSN,1)
   IF (&TEMP ^= '''')
    &IPNEWDSN = '''&ZPREFIX..&IPNEWDSN'''
)END
./ ADD NAME=IPTCBTBL
)Attr
   ! type(output) intens(low ) caps(off) just(asis )
   ? type(output) intens(high) caps(off) just(asis )
)Body  Expand(\\)
%-\-\- IPCS - TCB Table for ASID &ASID, job &JOBNAME -\-\-
%Subcommand ===>_ITTCMD                            \ \%Scroll ===>_AMT +
%
%Primary commands:+Any IPCS subcommand
%Line commands:   %R+- display RB's;%D+- display DEB's;%V+- display VSM
%IPCS CLIST:      +Any command or CLIST that takes a TCB(addr) operand.
+
%Sel/IPCS Clist // Address  Module   * Compcode  RTWA     Mother Daughter Sister
+
)Model
 _Z+/_ITTEXIT  +//!ITTADDR!ITTNAME ?Z  ?ITTCOMP ?ITTRTWA !ITTMOM !ITTKID !ITTSIS
)Init
  .ZVARS = '(ITTSEL ITTSTUFF)'
  &amt = CSR
  &ZTDMARK = '+
* J = Job step TCB;  N = nondispatchable ......................................+
             '
)Reinit
)Proc
  VPUT (ITTSEL ITTEXIT ITTADDR ITTNAME ITTCOMP ITTRTWA
        ITTMOM ITTKID ITTSIS) SHARED
)End
./ ADD NAME=IPVS
%--------------------  IPCS Virtual Storage Management -------------------------
%SELECTION ===>_ZCMD                                                           +
+
   %1+- PVT-MAP - Map of allocated private area virtual storage
   %2+- PVT-CBS - Private area control blocks (SPQE, DQE, FQE)
   %3+- LSQA-AE - LSQA allocation elements (AE)
   %4+- LSQA-CB - LSQA control blocks (LDA, DFE)
   %5+- CSA-MAP - Map of allocated CSA virtual storage
   %6+- CSA-CBS - CSA control blocks (SPT, DQE, FQE)

   %8+- SQA-CBS - SQA control blocks (GDA, DFE)
   %9+- SPTT    - Subpool translation table

                                            %CSA: +&GDACSA (size &GDACSASZ)
+   TCB address      %===>_VVTCB   +        %ECSA:+&GDAECSA (size &GDAECSAS)
+   Subpool selection%===>_VVSPLIST+        %SQA: +&GDASQA (size &GDASQASZ)
                                            %ESQA:+&GDAESQA (size &GDAESQAS)
                                            %PVT: +&GDAPVT (size &GDAPVTSZ)
                                            %EPVT:+&GDAEPVT (size &GDAEPVTS)
)INIT
 .CURSOR = ZCMD
)PROC
 &VVTCB = TRUNC(&VVTCB,'.')
 VER(&VVTCB,NB,HEX)
 &TEMP1 = TRUNC(&ZCMD,'.')
 &ZTRAIL = .TRAIL
 &TEMP2 = TRUNC(&TEMP1,1)
 &TEMP3 = .TRAIL
 IF (&TEMP3 = T)
  &TEMP1   = &TEMP2
  &P       = '%'
  &XTRACE  = 'XTRACE'
  &MODE    = 'LINE'
 ELSE
  &P       = ''
  &XTRACE  = ''
  &MODE    = 'FSCR'
 &ZSEL=TRANS(&TEMP1
             1 ,IPVSPMAP
             2 ,IPVSPVT
             3 ,IPVSAE
             4 ,IPVSLSQA
             5 ,IPVSCMAP
             6 ,IPVSCSA

             8 ,IPVSSQA
             9 ,IPVSSPTT
             ' ',' '
             *,'?')
 IF (&ZSEL ^= ' ','?')
  &STUFF = '&VVTCB &XTRACE'
  IF (&VVSPLIST ^= &Z)
   &STUFF = '&VVTCB SUBPOOL(&VVSPLIST) &XTRACE'
  &ZSEL = 'PGM(BLSGSCMD) PARM(&P.&ZSEL &STUFF) MODE(&MODE)'
)END
./ ADD NAME=IPVSCSA1
)BODY EXPAND(\\)
%-\-\-  CSA Viewing Parameters -\-\-
%COMMAND ===>_ZCMD                                                             +
%
+
+  Subpool number%===>_Z  +   (227, 228, 231, 241)
+
+  Storage key   %===>_Z +    (0-15)
+
)INIT
 .ZVARS = '(CSASP CSAPK)'
)PROC
 IF (&ZCMD ^= &Z) .MSG = ISPZ001
 VER (&CSASP,NB,LIST,227,228,231,241)
 VER (&CSAPK,NB,RANGE,0,15)
)END
./ ADD NAME=IPVSROWS
%-------------------- TABLE ROW WARNING ----------------------------------------
%COMMAND ===>_ZCMD                                                             +
%
+   There are more than &ROWCOUNT rows generated for this table so far.
+
+
+   Press ENTER to continue, or press END key to show the table so far.
+
)INIT
)PROC
)END
./ ADD NAME=IPVSSPTT
%--------------------  IPCS SUBPOOL TRANSLATION TABLE INFO ---------------------
%COMMAND ===>_ZCMD                                                             +
%
%&WARNING
%
+
+Enter subpool number (0-255)%===>_Z  +
)INIT
 .ZVARS = '(SPNO)'
 .CURSOR = SPNO
)PROC
 IF (&ZCMD ^= &Z) .MSG = ISPZ001
 VER(&SPNO,NB,RANGE,0,255)
)END
./ ADD NAME=TIPPRIM
%TUTORIAL ---------  IPCS - INITIALIZATION ---------------------------- TUTORIAL
%OPTION ===>_ZCMD

+ This is the IPCS primary option menu you see when you enter the command%IP.+


+ The following topics will be displayed only if selected by letter:

%   B+(blank)     - Perform IPCS functions on a dump dataset
%   A+ ACTIVE     - Perform IPCS functions on active main storage
%   C+ CATALOG    - List dump datasets in your catalog
%   L+ LISTDUMP   - List dump datasets in dump directory
%   S+ SYSDSCAN   - List titles of SYS1.DUMPnn datasets
%   I+ IBM        - Invoke IBM IPCS dialog
)INIT
)PROC
     &ZSEL = TRANS( &ZCMD
                B,*TIPPRIMB
                A,*TIPPRIMA
                C,*TIPPRIMC
                L,*TIPPRIML
                S,*TIPPRIMS
                I,*BLSPHELP
                *,'?'
                )
)END
./ ADD NAME=TIPPRIMA
%---------------------------- IPCS - TUTORIAL ----------------------------------
%SELECTION ===>_ZCMD                                                           +
%
%                   --------------------------------------
                    | INTERACTIVE PROBLEM CONTROL SYSTEM |
                    --------------------------------------
+
%      ******************************************************************
       *                                                                *
       *   There is no tutorial available for the function you are      *
       *   currently executing.  Refer to the IPCS manual or the        *
       *   HELP member for IPCS for more information.                   *
       *                                                                *
       *  +Press%END key+to terminate the tutorial and return to IPCS. %*
       *                                                                *
       ******************************************************************

)INIT
)PROC
)END
./ ADD NAME=TIPPRIMB
%---------------------------- IPCS - TUTORIAL ----------------------------------
%SELECTION ===>_ZCMD                                                           +
%
%                   --------------------------------------
                    | INTERACTIVE PROBLEM CONTROL SYSTEM |
                    --------------------------------------
+
%      ******************************************************************
       *                                                                *
       *   There is no tutorial available for the function you are      *
       *   currently executing.  Refer to the IPCS manual or the        *
       *   HELP member for IPCS for more information.                   *
       *                                                                *
       *  +Press%END key+to terminate the tutorial and return to IPCS. %*
       *                                                                *
       ******************************************************************

)INIT
)PROC
)END
./ ADD NAME=TIPPRIMC
%---------------------------- IPCS - TUTORIAL ----------------------------------
%SELECTION ===>_ZCMD                                                           +
%
%                   --------------------------------------
                    | INTERACTIVE PROBLEM CONTROL SYSTEM |
                    --------------------------------------
+
%      ******************************************************************
       *                                                                *
       *   There is no tutorial available for the function you are      *
       *   currently executing.  Refer to the IPCS manual or the        *
       *   HELP member for IPCS for more information.                   *
       *                                                                *
       *  +Press%END key+to terminate the tutorial and return to IPCS. %*
       *                                                                *
       ******************************************************************

)INIT
)PROC
)END
./ ADD NAME=TIPPRIML
%---------------------------- IPCS - TUTORIAL ----------------------------------
%SELECTION ===>_ZCMD                                                           +
%
%                   --------------------------------------
                    | INTERACTIVE PROBLEM CONTROL SYSTEM |
                    --------------------------------------
+
%      ******************************************************************
       *                                                                *
       *   There is no tutorial available for the function you are      *
       *   currently executing.  Refer to the IPCS manual or the        *
       *   HELP member for IPCS for more information.                   *
       *                                                                *
       *  +Press%END key+to terminate the tutorial and return to IPCS. %*
       *                                                                *
       ******************************************************************

)INIT
)PROC
)END
./ ADD NAME=TIPPRIMS
%---------------------------- IPCS - TUTORIAL ----------------------------------
%SELECTION ===>_ZCMD                                                           +
%
%                   --------------------------------------
                    | INTERACTIVE PROBLEM CONTROL SYSTEM |
                    --------------------------------------
+
%      ******************************************************************
       *                                                                *
       *   There is no tutorial available for the function you are      *
       *   currently executing.  Refer to the IPCS manual or the        *
       *   HELP member for IPCS for more information.                   *
       *                                                                *
       *  +Press%END key+to terminate the tutorial and return to IPCS. %*
       *                                                                *
       ******************************************************************

)INIT
)PROC
)END
./ ENDUP
?!
//SKEL     EXEC MDLOAD,BS='6160',TRK1='5',TRK2='1',TO='SKEL'
//SYSIN    DD   DATA,DLM='?!'
./ ADD NAME=IPPRINT
)SEL  &ZLLGJOB1 ^= &Z
&ZLLGJOB1
)ENDSEL
)SEL  &ZLLGJOB2 ^= &Z
&ZLLGJOB2
)ENDSEL
)SEL  &ZLLGJOB3 ^= &Z
&ZLLGJOB3
)ENDSEL
)SEL  &ZLLGJOB4 ^= &Z
&ZLLGJOB4
)ENDSEL
/*JOBPARM LINES=9999
//************************
//* PRINT SYS1.DUMP      *
//************************
//PRDMP  EXEC PGM=IKJEFT01,REGION=4096K,PARM=AMDPRDMP
//SYSTSPRT DD SYSOUT=*
//SYSPRINT DD SYSOUT=*
//PRINTER  DD SYSOUT=*
//SYSTSIN  DD DUMMY
//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(10,10))
//TAPE     DD DISP=SHR,DSN=&IPDSN
//SYSIN    DD *
)SEL &IPP11 ^= &Z
  DAEDATA
  SUMDUMP
)ENDSEL
)SEL &IPP1 ^= &Z
  ASMDATA
)ENDSEL
)SEL &IPP2 ^= &Z
  CPUDATA
)ENDSEL
)SEL &IPP3 ^= &Z
  CVTMAP
)ENDSEL
)SEL &IPP4 ^= &Z
  GRSTRACE
)ENDSEL
)SEL &IPP5 ^= &Z
  LOGDATA
)ENDSEL
)SEL &IPP6 ^= &Z
  LPAMAP &IPSORT
)ENDSEL
)SEL &IPP7 ^= &Z
  MTRACE
)ENDSEL
)SEL &IPP8 ^= &Z
  NUCMAP &IPSORT
)ENDSEL
)SEL &IPP9 ^= &Z
  RSMDATA
)ENDSEL
)SEL &IPP10 ^= &Z
  SRMDATA
)ENDSEL
)SEL &IPP11 ^= &Z
  VTAMMAP
)ENDSEL
)SEL &IPIOS ^= &Z
  IOSDATA &IPIOS
)ENDSEL
)SEL &IPTRC ^= &Z
  TRACE &IPTRC
)ENDSEL
)SEL &IPVSM ^= &Z
  VSMDATA &IPVSM
)ENDSEL
)SEL &IPPRT1 ^= &Z
  PRINT &IPPRT1 &IPPRT2
)ENDSEL
)SEL &IPCVT ^= &Z
  CVT = &IPCVT
)ENDSEL
)SEL &IPSEG ^= &Z
  SEGTAB = &IPSEG
)ENDSEL
  END
/*
)CM
)CM Source:
)CM
)CM "MVS/XA2.1.2 Installation and User's Guide"
)CM IBM International Systems Centers
)CM GG24-1596-1
)CM (c) Copyright International Business Machines Corporation 1983, 1984
)CM
)CM Page 165
)CM
./ ADD NAME=IPPSUM
)SEL  &ZLLGJOB1 ^= &Z
&ZLLGJOB1
)ENDSEL
)SEL  &ZLLGJOB2 ^= &Z
&ZLLGJOB2
)ENDSEL
)SEL  &ZLLGJOB3 ^= &Z
&ZLLGJOB3
)ENDSEL
)SEL  &ZLLGJOB4 ^= &Z
&ZLLGJOB4
)ENDSEL
//*******************
//* PRINT SUMMARY   *
//*******************
//PRDMP  EXEC PGM=IKJEFT01,REGION=4096K,PARM=AMDPRDMP
//SYSTSPRT DD SYSOUT=*
//SYSPRINT DD SYSOUT=*
//PRINTER  DD SYSOUT=*
//SYSTSIN  DD DUMMY
//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(10,10))
//TAPE     DD DISP=SHR,DSN=&IPDSN
//SYSIN    DD *
  SUMMARY &IPAS
          &IPRS
  END
/*
)CM
)CM Source:
)CM
)CM "MVS/XA2.1.2 Installation and User's Guide"
)CM IBM International Systems Centers
)CM GG24-1596-1
)CM (c) Copyright International Business Machines Corporation 1983, 1984
)CM
)CM Page 167
)CM
./ ADD NAME=IPSAVE
)SEL  &ZLLGJOB1 ^= &Z
&ZLLGJOB1
)ENDSEL
)SEL  &ZLLGJOB2 ^= &Z
&ZLLGJOB2
)ENDSEL
)SEL  &ZLLGJOB3 ^= &Z
&ZLLGJOB3
)ENDSEL
)SEL  &ZLLGJOB4 ^= &Z
&ZLLGJOB4
)ENDSEL
//***********************
//* SAVE SYS1.DUMP      *
//***********************
//PRDMP  EXEC PGM=IKJEFT01,REGION=2048K,PARM=AMDPRDMP
//SYSTSPRT DD SYSOUT=*
//SYSPRINT DD SYSOUT=*
//PRINTER  DD SYSOUT=*
//SYSTSIN  DD DUMMY
//SYSUT2   DD DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,
//            DSN=&IPSDSN,
//            SPACE=(CYL,(25,15),RLSE),
//            DCB=(RECFM=F,LRECL=4104,BLKSIZE=4104)
//TAPE     DD DISP=SHR,DSN=&IPDSN
//SYSIN    DD *
  END
/*
)CM
)CM Source:
)CM
)CM "MVS/XA2.1.2 Installation and User's Guide"
)CM IBM International Systems Centers
)CM GG24-1596-1
)CM (c) Copyright International Business Machines Corporation 1983, 1984
)CM
)CM Page 169
)CM
)CM Originally appeared as "IPTAPE" but was changed to save to DASD.
)CM
./ ADD NAME=IPTAPE
)SEL  &ZLLGJOB1 ^= &Z
&ZLLGJOB1
)ENDSEL
)SEL  &ZLLGJOB2 ^= &Z
&ZLLGJOB2
)ENDSEL
)SEL  &ZLLGJOB3 ^= &Z
&ZLLGJOB3
)ENDSEL
)SEL  &ZLLGJOB4 ^= &Z
&ZLLGJOB4
)ENDSEL
//***********************
//* SAVE SYS1.DUMP      *
//***********************
//PRDMP  EXEC PGM=IKJEFT01,REGION=2048K,PARM=AMDPRDMP
//SYSTSPRT DD SYSOUT=*
//SYSPRINT DD SYSOUT=*
//PRINTER  DD SYSOUT=*
//SYSTSIN  DD DUMMY
//SYSUT2   DD DISP=(NEW,CATLG),DSN=&IPSDSN,UNIT=TAPE
//TAPE     DD DISP=SHR,DSN=&IPDSN
//SYSIN    DD *
  END
/*
)CM
)CM Source:
)CM
)CM "MVS/XA2.1.2 Installation and User's Guide"
)CM IBM International Systems Centers
)CM GG24-1596-1
)CM (c) Copyright International Business Machines Corporation 1983, 1984
)CM
)CM Page 169
)CM
./ ENDUP
?!
//ASM      EXEC MDLOAD,BS='6160',TRK1='10',TRK2='1',TO='ASM'
//SYSIN    DD   DATA,DLM='?!'
./ ADD NAME=$$INDEX
***********************************************************************
*                                                                     *
*  This PDS contains assembler source for IPCS exit routines that     *
*  may be used by IPCS subcommands TCBEXIT, ASCBEXIT, and VERBEXIT,   *
*  as well as supporting routines therefor.                           *
*                                                                     *
*  Note especially subroutine XABDGET, which is designed to permit    *
*  IPCS exits that use it to run as both IPCS exits and READY-mode    *
*  live-storage analyzers.                                            *
*                                                                     *
*  Oh yeah, it also contains other SYSPGMR goodies.                   *
*                                                                     *
***********************************************************************
./ ADD NAME=VITWHR
         TITLE 'VITWHR - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'VITWHR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'
         SPACE 1
***********************************************************************
*                                                                     *
* THIS IS AN IPCS TCB EXIT THAT, GIVEN AN ADDRESS (WHICH IS NOT       *
* REALLY A TCB ADDRESS AFTER ALL), REPORTS ON WHAT LOAD MODULE THE    *
* ADDRESS LIVES IN AS WELL AS THE OFFSET.  UNLIKE THE XITWHR EXIT,    *
* HOWEVER, THIS ROUTINE DOES NOT DISPLAY THE INFO, BUT RETURNS THE    *
* VALUES AS ISPF SHARED VARIABLES.                                    *
*                                                                     *
***********************************************************************
         SPACE 1
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    ADDRESS OF OPERAND
R6       EQU   6    LENGTH OF OPERAND
R7       EQU   7    POINTER TO CDE
R8       EQU   8    USED IN NUCMAP SCANNING
R9       EQU   9    USED IN NUCMAP SCANNING
R10      EQU   10   POINTER TO PARAMETER LIST EXTENSION
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
VITWHR   CSECT
         SAVE  (14,12),,VITWHR_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING VITWHR,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO
         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION
         EJECT
* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.
* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES
* THE CORRECT ASID, ETC.
         SPACE 1
         XR    R0,R0
         ST    R0,ADPLCOM1         CLEAR XIPSWHR COMMUNICATION FIELD
         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE
         LR    R1,R4               GET ADDRESS OF ABDPL
         SPACE 1
         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE
         SPACE 1
         MVI   VITPLACE,C' '
         MVC   VITPLACE+1(L'VITPLACE-1),VITPLACE
         MVI   VITNAME,C' '
         MVC   VITNAME+1(L'VITNAME-1),VITNAME
         MVI   VITLOC,C' '
         MVC   VITLOC+1(L'VITLOC-1),VITLOC
         MVI   VITOFF,C' '
         MVC   VITOFF+1(L'VITOFF-1),VITOFF
*
* SET VITPLACE = THE AREA WHERE IT WAS FOUND: JPA/PLPA/MLPA/NUC/ERR
*
         MVC   VITPLACE(4),ADPLFMT1
         CLI   VITPLACE,C' '
         BE    VITERROR
         CLI   VITPLACE,C'E'
         BE    VITERRNP
         B     VITOK
VITERROR DS    0H                  ERROR - MODULE NOT FOUND
         MVC   VITPLACE(11),=C'UNAVAILABLE'
VITERRNP DS    0H                  STORAGE ERROR - RETAIN VITPLACE
         MVC   VITNAME(11),=C'UNAVAILABLE'
         MVC   VITLOC(11),=C'UNAVAILABLE'
         B     VITSET
VITOK    DS    0H
*
* SET VITNAME = THE NAME OF THE LOAD MODULE
*
         MVC   VITNAME(8),ADPLCOM1
*
* SET VITLOC = THE DECIMAL OFFSET OF THE ADDRESS WITHIN THE LOAD MODULE
*
         L     R0,ADPLFMT2
         CVD   R0,DOUBLE
         UNPK  VITLOC(10),DOUBLE
         OI    VITLOC+9,X'F0'
*
* SET VITOFF = THE HEX OFFSET OF THE ADDRESS WITHIN THE LOAD MODULE
*
         L     R0,ADPLFMT2
         ST    R0,DOUBLE
         UNPK  VITOFF(9),DOUBLE(5)
         TR    VITOFF(8),HEXTBL
         MVC   VITOFF+8(8),=CL8'         '
         LA    R1,VITOFF
         LA    R15,7
VOLOOP   DS    0H
         CLI   0(R1),C'0'
         BNE   VOLEND
         LA    R1,1(,R1)
         BCT   R15,VOLOOP
VOLEND   DS    0H
         MVC   VITOFF(8),0(R1)
         SPACE 1
VITSET   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* OK, NOW INVOKE ISPF DIALOG SERVICES TO SET THE THREE VALUES AS      *
* ISPF DIALOG VARIABLES.                                              *
*                                                                     *
***********************************************************************
         SPACE 1
         LOAD  EPLOC==CL8'ISPLINK'
         ST    R0,@ISPLINK
*
* ISPEXEC VDEFINE (VITNAME VITPLACE VITLOC VITOFF)
*
         LA    R1,=C'VDEFINE '
         ST    R1,ISPPARMS+0
         LA    R1,=C'(VITPLACE VITNAME VITLOC VITOFF)'
         ST    R1,ISPPARMS+4
         LA    R1,VITPLACE
         ST    R1,ISPPARMS+8
         LA    R1,=C'CHAR '
         ST    R1,ISPPARMS+12
         LA    R1,=F'11'
         ST    R1,ISPPARMS+16
         OI    ISPPARMS+16,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
*
* ISPEXEC VPUT (VITNAME VITPLACE VITLOC VITOFF) SHARED
*
         LA    R1,=C'VPUT    '
         ST    R1,ISPPARMS+0
         LA    R1,=C'(VITPLACE VITNAME VITLOC VITOFF)'
         ST    R1,ISPPARMS+4
         LA    R1,=C'SHARED '
         ST    R1,ISPPARMS+8
         OI    ISPPARMS+8,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
*
* ISPEXEC VDELETE (VITNAME VITPLACE VITLOC VITOFF)
*
         LA    R1,=C'VDELETE '
         ST    R1,ISPPARMS+0
         LA    R1,=C'(VITPLACE VITNAME VITLOC VITOFF)'
         ST    R1,ISPPARMS+4
         OI    ISPPARMS+4,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
*
* GOODBYE
*
         DELETE EPLOC==CL8'ISPLINK '
*
* RETURN TO CALLER
*
         B     RETURN0
         SPACE 2
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15             CALL IT
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ...........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D                   WORK AREA FOR NUMERIC CONVERSION
OUTSAVE  DS    A
         SPACE 1
@ISPLINK DS    A                   ADDRESS OF ISPLINK
ISPPARMS DS    6A                  PARMS FOR ISPLINK
         SPACE 1
VITPLACE DS    CL11                VALUE OF ISPF VARIABLE
VITNAME  DS    CL11                VALUE OF ISPF VARIABLE
VITLOC   DS    CL11                VALUE OF ISPF VARIABLE
VITOFF   DS    CL11                VALUE OF ISPF VARIABLE
         DS    CL8                 PADDING
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL133               WORK AREA FOR OUTPUT LINES
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 2
         IHACDE
         EJECT
         IHAXTLST
         EJECT
         IHALPDE
         EJECT
         IKJTCB
         EJECT
         IKJTSVT
         EJECT
         CVT   DSECT=YES
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ADD NAME=XABDGET
         TITLE 'XABDGET  - VERB EXIT INTERFACE MODULE'
***********************************************************************
*                                                                     *
* XABDGET  - VERB EXIT INTERFACE MODULE                               *
*                                                                     *
* THIS MODULE HAS SEVERAL ENTRY POINTS, ALL USED TO ENABLE A PROGRAM  *
* TO RUN AS A TSO COMMAND PROCESSOR OR AN IPCS VERB EXIT:             *
*                                                                     *
* XABDGET - DETERMINE IF THE PROGRAM WAS INVOKED AS A VERB EXIT AND   *
*           RETURN THE ADDRESS OF THE ABDPL IF SO, OTHERWISE BUILD    *
*           A FAKE ABDPL AND RETURN ITS ADDRESS.                      *
* XABDFRE - FREE THE FAKE ABDPL BUILT BY XABDGET.                     *
* XABDMEM - FAKE STORAGE ACCESS ROUTINE.                              *
* XABDPRT - FAKE OUTPUT WRITING ROUTINE.                              *
*                                                                     *
* (THERE MAY BE OTHERS, LIKE A FAKE FORMATTER, IN THE FUTURE.)        *
*                                                                     *
* NOTE: CURRENTLY THERE IS NO "XABDFRE" ENTRY POINT - THE XABDGET     *
*       EP WITH R1 = 0 IS A GET REQUEST, ELSE A FREE REQUEST.         *
*                                                                     *
* 09/26/1997 SEB1525 - replaced XPUTLINE with direct call to PUTLINE  *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    NUMBER OF ELEMNTS IN PARAMETER LIST
R4       EQU   4    ADDRESS OF ABDPL
R5       EQU   5    ADDRESS OF ABDPL EXTENSION
R6       EQU   6    ADDRESS OF OUTPUT BUFFER
R7       EQU   7    .
R8       EQU   8    SAVED PARM POINTER
R9       EQU   9    .
R10      EQU   10   .
R11      EQU   11   .
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XABDGET  CSECT
         SPACE 1
         SAVE  (14,12),,XABDGET_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XABDGET,R12
         SPACE 1
***********************************************************************
*                                                                     *
* XABDGET IS CALLED WITH R1 CONTAINING:                               *
*    THE ADDRESS OF THE FAKE ABDPL, IF IT IS TO BE FREED.             *
*    ZEROES, IF AN ABDPL IS TO BE OBTAINED.                           *
*                                                                     *
***********************************************************************
         SPACE 1
         LTR   R1,R1
         BNZ   FREEPL
         EJECT
GETPL    DS    0H                  R1 = 0, GET AN ABDPL
         SPACE 1
         L     R1,4(,R13)          GET SA WHERE CALLER SAVED REGS
         L     R1,24(,R1)          GET R1 PASSED TO CALLER
         LR    R8,R1               SAVE FOR FUTURE USE
         LR    R2,R1               POINT TO FIRST PARM
* COUNT # OF PARMS PASSED.  IF GE 7, ASSUME CALLED AS VERB EXIT.
         LA    R0,6                INITIALIZE PARAMETER COUNT
         LA    R3,1                CLEAR PARAMETER COUNT
PARMLOOP TM    0(R2),X'80'         IF VL BIT (LAST PARM ADDR) FOUND,
         BO    LASTPARM            THEN WE GOT IT
         LA    R3,1(,R3)
         LA    R2,4(,R2)           ELSE BUMP POINTER
         BCT   R0,PARMLOOP         AND CONTINUE LOOPING
LASTPARM LTR   R0,R0               IF LESS THAN 7 PARMS (R0 ^= 0)
         BNZ   GETFAKE             THEN NOT INVOKED AS VERB EXIT
         L     R15,X'21C'          -> TCB
         L     R15,X'B4'(,R15)     -> JSCB
         L     R15,X'15C'(,R15)    -> ACTIVE JSCB
         L     R15,X'108'(,R15)    -> PSCB
         C     R15,8(,R1)          IF PARM 3 -> PSCB (INVOKED AS CMD)
******** BE    GETFAKE             THEN NOT INVOKED AS VERB EXIT
         BNE   RETURN0             ELSE RETURN, R1 -> ABDPL
         SPACE 1
* ELSE WE HAVE TO BUILD OUR OWN FAKE ABDPL
         SPACE 1
GETFAKE  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* WE ACQUIRE A WORK AREA WITH THE FOLLOWING CONTIGUOUS AREAS:         *
*                                                                     *
*   THE ABDPL                                                         *
*   THE ABDPL EXTENSION                                               *
*   OUR OWN AREA, INCLUDING OUTPUT BUFFER, CPPL, AND LOTS OF OTHERS.  *
*                                                                     *
***********************************************************************
         SPACE 1
         GETMAIN R,LV=TOTAREAL     GET STORAGE FOR ABDPL ET AL.
         LR    R4,R1               SAVE ITS ADDRESS
         USING ABDPL,R4
         LA    R5,ADPLLEN(,R4)     ADDRESS THE EXTENSION
         USING ADPLEXTN,R5
         LA    R6,ADPLEXTL(,R5)    ADDRESS OUR ADDITIONAL AREA
         USING OURAREA,R6
*
* INITIALIZE ABDPL
*
         XC    ABDPL(ADPLLEN),ABDPL
         L     R15,X'21C'          ->TCB
         ST    R15,ADPLTCB         SET TCB OF CURRENT TASK
         L     R15,X'224'          ->ASCB
         LH    R15,X'24'(,R15)     ASID
         STH   R15,ADPLASID        ADDRESS SPACE IDENTIFIER
         MVI   ADPLFLAG,ADPLSYTM   SET VS1 BIT (REALLY "FAKE" BIT)
         LA    R15,OURBUF
         ST    R15,ADPLBUF         ADDRESS OF OUTPUT BUFFER
         L     R15,=V(XABDPRT)
         ST    R15,ADPLPRNT        ADDRESS OF PRINT ROUTINE
         L     R15,X'10'
         ST    R15,ADPLCVT         ADDRESS OF CVT
         L     R15,=V(XABDMEM)
         ST    R15,ADPLMEMA        ADDRESS OF MEMORY ACCESS ROUTINE
*        L     R15,=V(XABDFMT)
*        ST    R15,ADPLFRMT        ADDRESS OF FORMAT ROUTINE
*
         ST    R5,ADPLEXT          ADDRESS OF EXTENSION
*        L     R15,=V(XABDSRV)
*        ST    R15,ADPLSERV        ADDRESS OF SERVICES ROUTER
*
* INITIALIZE ADPL EXTENSION
*
         XC    ADPLEXTN(ADPLEXTL),ADPLEXTN
* CHECK # OF PARMS PASSED.  IF 4, ASSUME CPPL PASSED
         L     R15,X'21C'          GET TCB ADDRESS
         L     R15,X'B4'(,R15)     GET JSCB ADDRESS
         L     R15,X'15C'(,R15)    GET ADDRESS OF ACTIVE JSCB
         L     R15,X'108'(,R15)    GET ADDRESS OF PSCB
         CH    R3,=H'4'            IF AT LEAST 4 PARMS
         BL    NOTTSOCP            AND
         C     R15,8(,R8)          PARM 3 -> PSCB (INVOKED AS CMD)
         BNE   NOTTSOCP            THEN
         ST    R8,ADPLCPPL          INPUT PARM -> CPPL
         L     R1,0(,R8)            POINT TO COMMAND BUFFER
         LH    R14,0(,R1)           GET LENGTH OF COMMAND BUFFER
         LH    R15,2(,R1)           GET OFFSET TO FIRST OPERAND
         LA    R15,4(R15,R1)        ABSOLUTE ADDRESS OF OPERAND
         ST    R15,ADPLOPTR         SET ADDRESS OF OPERANDS BUFFER
         ALR   R14,R1               POINT TO END OF COMMAND BUFFER
         SR    R14,R15              SUBTRACT OFFSET TO FIRST OPERAND
         STH   R14,ADPLOPLN         SET LENGTH OF VERB OPERAND LIST
         B     AFTTSOCP            ELSE
NOTTSOCP DS    0H                   ...BUILD OUR OWN CPPL
         ST    R15,CPPLPSCB         SAVE PSCB ADDRESS
         MVC   CPPLUPT,X'34'(R15)   SAVE UPT ADDRESS
         L     R15,X'30'(,R15)      GET ADDRESS OF RELOGON BUFFER
         L     R15,X'100'(,R15)     GET ADDRESS OF ECT
         ST    R15,CPPLECT          SAVE ECT ADDRESS
         XC    CPPLCBUF,CPPLCBUF    NO COMMAND BUFFER
         LA    R1,OURCPPL
         ST    R1,ADPLCPPL          SET CPPL ADDRESS
         L     R1,0(,R8)            ASSUME FIRST PARM IS A CALL PARM
         LA    R15,2(,R1)           ADDRESS OF PARM TEXT
         ST    R15,ADPLOPTR         SET ADDRESS OF OPERANDS BUFFER
         LH    R14,0(,R1)           GET LENGTH OF PARM FIELD
         STH   R14,ADPLOPLN         SET LENGTH OF VERB OPERAND LIST
AFTTSOCP DS    0H
         L     R1,ADPLCPPL
         MVC   IOPLUPT,CPPLUPT-OURCPPL(R1) PTR TO UPT
         MVC   IOPLECT,CPPLECT-OURCPPL(R1) PTR TO ECT
         LA    R0,ECB
         ST    R0,IOPLECB              PTR TO USER'S ECB
         LA    R0,1                DEFINE 1 MESSAGE SEGMENT
         LA    R1,MSGHDR
         STM   R0,R1,OLD           SET UP OUTPUT LINE DESCRIPTOR
*
* INITIALIZE OUTPUT BUFFER TO BLANKS
*
         MVI   OURBUFB,C' '        BLANK REQUIRED FOR PUTLINE
         MVI   OURBUF,C' '
         MVC   OURBUF+1(OURBUFL-1),OURBUF
         EJECT
         LR    R1,R4               SET ABDPL POINTER FOR RETURN
         B     RETURN0
         EJECT
FREEPL   DS    0H                  R1 -> ABDPL TO BE FREED
         SPACE 1
         TM    ADPLFLAG-ABDPL(R1),ADPLSYTM  IF VS1/FAKE FLAG SET,
         BZ    RETURN0             THEN
         FREEMAIN R,LV=TOTAREAL,A=(1) FREE IT
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 1
RETURN   DS    0H                  RETURN
         SPACE 1
***********************************************************************
* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *
*                                 R1 CONTAINS ABDPL POINTER           *
***********************************************************************
         SPACE 1
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         ST    R1,24(,R13)         STORE ABDPL PTR (R1) IN SAVE AREA
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* DECLARATIVES, ETC.                                                  *
***********************************************************************
         SPACE 1
         LTORG
         SPACE 3
         DROP  R12
         TITLE 'XABDPRT  - VERB EXIT FAKE OUTPUT PRINT ROUTINE'
***********************************************************************
*                                                                     *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 1
XABDPRT  CSECT
         SPACE 1
         SAVE  (14,12),,XABDPRT
         LR    R12,R15
         USING XABDPRT,R12
         LR    R4,R1               SAVE ABDPL ADDRESS
         USING ABDPL,R4
         L     R5,ADPLEXT
         USING ADPLEXTN,R5
         LA    R6,ADPLEXTL(,R5)    ADDRESS OUR ADDITIONAL AREA
         USING OURAREA,R6
         SPACE 1
         ST    R13,OURSAVE+4       SET UP SAVE AREA
         LA    R1,OURSAVE
         ST    R1,8(,R13)
         LR    R13,R1
         SPACE 1
         TR    OURBUF(OURBUFL),PRTTRTBL  FIX ALL BAD CHARACTERS
         SPACE 1
         LA    R0,OURBUFL+1        LENGTH OF OUTPUT BUFFER
         LA    R1,OURBUFB          THE OUTPUT BUFFER
         BAL   R14,PUTLINE         Call PUTLINE to display line
         LTR   R15,R15             IF PUTLINE FAILED
         BZ    PRTPUTOK            THEN
         LA    R1,400(,R15)         ABEND WITH PUTLINE RC + 400
         ABEND (1),DUMP
         SPACE 1
PRTPUTOK DS    0H
         MVI   OURBUF,C' '         CLEAR OUTPUT BUFFER TO BLANKS
         MVC   OURBUF+1(OURBUFL-1),OURBUF
         B     PRTRET0
         EJECT
PRTRET4  DS    0H                  RETURN WITH CODE 4
         LA    R15,4               SET RETURN CODE TO FOUR
         B     PRTRET
PRTRET0  DS    0H                  RETURN WITH CODE 0
         XR    R15,R15             SET RETURN CODE TO ZERO
******** B     PRTRET
PRTRET   DS    0H                  RETURN
         SPACE 1
***********************************************************************
* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *
***********************************************************************
         SPACE 1
         L     R13,4(,R13)         RESTORE SAVE AREA POINTER
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
MPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
LENPUTL  EQU   *-MPTLIST
*
PRTTRTBL DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ...........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'.........`:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4BA1A2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         TITLE 'PUTLINE SUBROUTINE'
         SPACE
PUTLINE  DS    0H
*
***********************************************************************
*                                                                     *
* This routine displays messages to the TSO user using the TSO        *
* PUTLINE service routine.  At entry R1 contains the address of the   *
* message to be displayed, and R0 contains the length of the message. *
* The message is assumed to begin with a message ID unless            *
* the first character is blank, in which case the initial blank is    *
* stripped off by PUTLINE anyhow.                                     *
*                                                                     *
***********************************************************************
*
         ST    R14,PUTLIN14        Save return register
         LTR   R15,R0              Load length value
         BNP   PUTLRET             If zero, don't do anything
         BCTR  R15,0               Else reduce length for execute
         LTR   R1,R1               If R1 is zero,
         BZ    PUTIT               then message already set up.
         EX    R15,MVCPUT          Else move message to work area
PUTIT    DS    0H
         LA    R15,5(,R15)         Restore length + 4 for header
         SLL   R15,16              Shift length into left half of hdr
         STCM  R15,15,MSGHDR       Put zeroes into right half of hdr
         MVC   PTLIST(LENPUTL),MPTLIST SET UP PUTLINE LIST FORM
PUTRETRY DS    0H
         XC    ECB,ECB             Clear ECB
         PUTLINE PARM=PTLIST,                                          X
               MF=(E,IOPL),                                            X
               OUTPUT=(OLD,TERM,SINGLE,INFOR)
         LTR   R15,R15             If PUTLINE OK
         BZ    PUTLRET             then return
         CH    R15,=H'8'           Else if attention interrupt
         BE    PUTLRET             then OK
         CH    R15,=H'12'          Else if pending 2nd level message
         BE    PUTL12              then OK
PUTERROR DS    0H                  Else PUTLINE error
         CVD   R15,OURWORK
         UNPK  OURWORK(2),OURWORK(8)
         OI    OURWORK+1,X'F0'
         MVC   PUTWA+1(L'PUTFMSG1),PUTFMSG1
         MVC   PUTWA+1+L'PUTFMSG1(2),OURWORK
         MVC   PUTWA+1+L'PUTFMSG1+2(L'PUTFMSG2),PUTFMSG2
         TPUT  PUTWA+1,L'PUTFMSG1+2+L'PUTFMSG2
         LA    R1,MSGWA
         LH    R0,MSGHDR
         SH    R0,=H'4'
         TPUT  (1),(0),R           Try to display original message
PUTLRET  L     R14,PUTLIN14        Restore return register
         BR    R14                 Return
*
PUTL12   DS    0H                  Try putting out pending 2nd level ms
         XC    ECB,ECB             Clear ecb
         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(0,TERM,SINGLE,INFOR)
         B     PUTRETRY
*
MVCPUT   MVC   MSGWA(*-*),0(R1)    Executed
*
PUTFMSG1 DC    C'*** XABDGET: PUTLINE error code '
PUTFMSG2 DC    C' trying to issue the following message:'
         EJECT
         LTORG
         EJECT
         TITLE 'XABDMEM  - VERB EXIT FAKE MEMORY ACCESS ROUTINE'
***********************************************************************
*                                                                     *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 1
XABDMEM  CSECT
         SPACE 1
         SAVE  (14,12),,XABDMEM
         LR    R12,R15
         USING XABDMEM,R12
         LR    R4,R1               SAVE ABDPL ADDRESS
         USING ABDPL,R4
         L     R5,ADPLEXT
         USING ADPLEXTN,R5
         LA    R6,ADPLEXTL(,R5)    ADDRESS OUR ADDITIONAL AREA
         USING OURAREA,R6
         SPACE 1
***********************************************************************
*                                                                     *
* FOR NOW, JUST RETURN THE ADDRESS AS IS.                             *
*                                                                     *
***********************************************************************
         SPACE 1
         B     MEMRET0             RETURN OK, ADDRESS IN R0
         SPACE 1
         EJECT
MEMRET4  DS    0H                  RETURN WITH CODE 4
         LA    R15,4               SET RETURN CODE TO FOUR
         B     MEMRET
MEMRET0  DS    0H                  RETURN WITH CODE 0
         XR    R15,R15             SET RETURN CODE TO ZERO
******** B     MEMRET
MEMRET   DS    0H                  RETURN
         SPACE 1
***********************************************************************
* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *
*                                 R0 CONTAINS ADDRESS OF DATA         *
***********************************************************************
         SPACE 1
         STM   R15,R0,16(R13)      STORE VALUES IN SAVE AREA
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
         LTORG
***********************************************************************
* MAP OF THE ADDITIONAL AREA FOLLOWING ABDPL AND ADPLEXT              *
***********************************************************************
         SPACE 1
OURAREA  DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
OURSAVE  DS    9D                  SAVE AREA IF NEEDED
OURWORK  DS    D                   MISCELLANEOUS WORKAREA
PUTLIN14 DS    A                   PUTLINE SAVE AREA
OURPLIST DS    0A                  PARAMETER LIST
OURPARM1 DS    A                   PARAMETER 1
OURPARM2 DS    A                   PARAMETER 2
OURPARM3 DS    A                   PARAMETER 3
OURPARM4 DS    A                   PARAMETER 4
OURCPPL  DS    0F       TSO COMMAND PROCESSOR PARAMETER LIST
CPPLCBUF DS    A        PTR TO COMMAND BUFFER
CPPLUPT  DS    A        PTR TO UPT
CPPLPSCB DS    A        PTR TO PSCB
CPPLECT  DS    A        PTR TO ECT
*
IOPL     DS    0A
*
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
*
ECB      DS    F                   ECB for TSO routines
*
PTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
*
OLD      DS    0F                  PUTLINE output line descriptor
OLDF1    DS    F'1'                Number of message segments
OLDMSG   DS    A(*-*)              Address of the first message segment
*
MSGHDR   DS    F                   PUTLINE message header
MSGWA    DS    CL256               PUTLINE message work area
PUTWA    DS    CL256               PUTLINE message work area
*
         SPACE 1
OURBUFB  DS    CL1                 LEADING BLANK REQUIRED FOR XPUTLINE
OURBUF   DS    CL133               OUTPUT BUFFER
OURBUFL  EQU   *-OURBUF
         SPACE 1
         DS    0D                  ALIGN TO DOUBLEWORD
         SPACE 2
OURAREAL EQU   *-OURAREA           LENGTH OF OUR AREA
         EJECT
         BLSABDPL
         EJECT
***********************************************************************
* ADDITIONAL EQUATES                                                  *
***********************************************************************
         SPACE 1
TOTAREAL EQU   ADPLLEN+ADPLEXTL+OURAREAL
         SPACE 1
         END
./ ADD NAME=XIPMAP
         TITLE 'XIPMAP - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN-ABDPL(,R1)  STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA-ABDPL(,R1) GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         EJECT
         MACRO
&SYM     GDUMP &REG,&PLACE,&FILL=' ',&STG=DOUBLE
         AIF   ('&REG' EQ '*').NOSTORE
&SYM     ST    &REG,&STG               REGISTER CONTENTS TO BE DUMPED
         AGO   .AFT
.NOSTORE ANOP
&SYM     DS    0H                      CONTENTS OF STORAGE TO BE DUMPED
.AFT     ANOP
         UNPK  &PLACE.(9),&STG.(5)
         TR    &PLACE.(8),HEXTBL
         MVI   &PLACE.+8,C&FILL
         MEND
         TITLE 'XIPMAP - IPCS VERB EXIT TO MAP TCB TREE CONTROL BLOCKS'
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    TCB POINTER
R4       EQU   4    ABDPL ADDRESS
R5       EQU   5    LLS POINTER
R6       EQU   6    RB POINTER
R7       EQU   7    CDE POINTER
R8       EQU   8    DEB POINTER
R9       EQU   9    DCB POINTER
R10      EQU   10   JPQ POINTER
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XIPMAP   CSECT
         SAVE  (14,12),,XIPMAP-&SYSDATE-&SYSTIME
         LR    R12,R15
         USING XIPMAP,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ADDRESS OF ABDPL
         USING ABDPL,R4
         L     R11,ADPLBUF         ESTABLISH ADDRESSABILITY TO
         USING LINEDSCT,R11            OUTPUT BUFFER
         XC    WHRADDR,WHRADDR
         XC    FIRSTTCB,FIRSTTCB
         EJECT
*
* Instead of using the low-core pointer to get to the TCB,
* use the ASID to locate the ASCB (via the ASVT) and get the
* first TCB from there.  In that way, setting the ASID via
* SETDEF will affect which address space gets mapped.
*
*        LA    R3,X'21C'           ADDRESS OF CVTTCBP
*        GSTOR R3,4,ERRET=BAD21C   GET PSATOLD FROM DUMP
*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB
*        LTR   R3,R3               IF POINTER AT 21C IS ZEROES,
*        BNZ   FINDTOP             THEN...
*        MVI   LINE,C' '
*        MVC   LINE+1(L'LINE-1),LINE
*        MVC   LINE(L'TRY218),TRY218
*        BAL   R14,OUTPUT
*        LA    R3,X'218'
*        GSTOR R3,4,ERRET=BAD218   GET PSATNEW FROM DUMP
*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB
*        LTR   R3,R3               IF POINTER AT 218 IS ZEROES,
*        BNZ   FINDTOP             THEN...
*        MVI   LINE,C' '
*        MVC   LINE+1(L'LINE-1),LINE
*        MVC   LINE(L'TRY224),TRY224
*        BAL   R14,OUTPUT
*
* Try to get ASCB.  Instead of relying on the low-core pointer,
* use the ASID to locate it via the ASVT.  In that way, setting
* the ASID with SETDEF will cause this exit to pick up the right one.
*
*----------------------------------------------------------------------
*        LA    R3,X'224'            TRY VIA ASCB
*        GSTOR R3,4,ERRET=BAD224   GET PSA'S ASCB PTR FROM DUMP
*        L     R3,0(,R3)           ADDRESS OF CURRENT ASCB
*        GSTOR R3,X'70',ERRET=BADASCB   GET CURRENT ASCB FROM DUMP
*----------------------------------------------------------------------
         L     R3,ADPLCVT          Get CVT pointer
         LA    R3,X'22C'(,R3)      CVT+22C -> ASVT
         GSTOR R3,4,ERRET=BADCVT   Get loc of CVT's ASVT ptr from dump
         L     R3,0(,R3)           Load address of CVT's ASVT pointer
         LH    R2,ADPLASID         Get the current ASID
         SLA   R2,2                Multiply by 4 making index into ASVT
         LA    R3,X'20C'(R2,R3)    Point to ASCB address for this ASID
         GSTOR R3,4,ERRET=BADASVT  Get ASCB address from dump
         L     R3,0(,R3)           Load the ASCB address
         GSTOR R3,X'70',ERRET=BADASCB   Get the ASCB from dump
         L     R3,X'6C'(,R3)       GET POINTER TO ASXB
         GSTOR R3,8,ERRET=BADASXB  GET ASXB FROM DUMP
         L     R3,4(,R3)           GET 1ST TCB ADDRESS FROM ASXB
         ST    R3,FIRSTTCB         Save it for module findings
FINDTOP  DS    0H                  SCAN FOR TOP TCB
         LR    R2,R3               SAVE ACTUAL TCB ADDRESS
         GSTOR R3,X'8C',ERRET=BADTCB GET CURRENT TCB FROM DUMP
         ICM   R15,15,X'84'(R3)    ADDRESS OF MOTHER TCB
         BZ    USETCB              IF NONE, THIS IS THE TOP TCB
         LR    R3,R15              IF THERE IS A MOTHER,
         B     FINDTOP             THEN GO FIND ITS MOTHER OR USE IT
USETCB   DS    0H                  START WITH THIS TCB
         LR    R3,R2               GET ACTUAL TCB ADDRESS AGAIN
         SPACE 1
*******                            (WE DON'T DO THIS ANY MORE)
*******  L     R3,X'7C'(,R3)       GET POINTER TO TCBJSTCB
*******
*
         BAL   R14,OUTPUT          Print a blank line
         MVC   LINE(L'HIMSG),HIMSG
         LH    R2,ADPLASID
         GDUMP R2,LINE+L'HIMSG     FORMAT AND PRINT ASID
         BAL   R14,OUTPUT          PRINT "HI THERE" MESSAGE
         BAL   R14,OUTPUT          Print a blank line
*
DOIT     DS    0H
         BAL   R14,PROCESS
         ICM   R3,15,COPYTCB+X'88' DAUGHTER TCB
         BNZ   DOIT
NODTR    DS    0H                  ELSE
         ICM   R3,15,COPYTCB+X'80' SISTER TCB
         BNZ   DOIT
NOSISTER DS    0H                  ELSE
         ICM   R3,15,COPYTCB+X'84' MOTHER TCB
         BZ    NOMORE              IF NONE, FINISHED WITH TCB TREE
         GSTOR R3,X'8C',ERRET=BADTCB ELSE GET MOTHER TCB FROM DUMP
         MVC   COPYTCB(X'8C'),0(R3) SAVE TCB STORAGE
         B     NODTR               PROCESS ITS SISTER, ETC.
NOMORE   DS    0H
         B     RETURN0
         EJECT
PROCESS  DS    0H                  R3 = ADDRESS OF TCB BEING PROCESSED
         SPACE
         ST    R14,PRCSSAVE        SAVE RETURN REGISTER
         BAL   R14,OUTPUT          PRINT A BLANK LINE
         MVC   LINE(L'TCBMSG),TCBMSG
         GDUMP R3,LINE+L'TCBMSG    FORMAT AND PRINT TCB ADDRESS
         BAL   R14,OUTPUT          PRINT "PROCESSING TCB"
         GSTOR R3,256,ERRET=BADTCB GET TCB ITSELF FROM DUMP
         MVC   COPYTCB(256),0(R3)  SAVE TCB STORAGE FOR FUTURE USE
         ICM   R6,15,COPYTCB+X'10' PICK UP COMPLETION CODE
         BZ    NOTCBCMP            IF THERE IS ONE, THEN...
         MVC   LINE(L'CMPMSG),CMPMSG
         GDUMP R6,LINE+L'CMPMSG               FORMAT IT AND PRINT IT
         MVC   LINE+L'CMPMSG+9(L'RTM2MSG),RTM2MSG
         ICM   R6,15,COPYTCB+X'E0'            PICK UP ADDRESS OF RTM2WA
         GDUMP R6,LINE+L'CMPMSG+9+L'RTM2MSG   FORMAT IT AND PRINT IT
         BAL   R14,OUTPUT          PRINT COMPLETION CODE
NOTCBCMP DS    0H
         L     R6,COPYTCB+0        ADDRESS OF RB
         MVC   LINE(L'RBMSG),RBMSG
         GDUMP R6,LINE+L'RBMSG     FORMAT AND PRINT RB ADDRESS
         BAL   R14,OUTPUT          PRINT "PROCESSING RB"
RBLOOP   DS    0H
         LR    R2,R6               SAVE TRUE RB ADDRESS
         SH    R6,=H'32'           POINT TO RB PREFIX
         BM    BADRB               IF MAKES IT GO NEGATIVE, BAD ADDR
         GSTOR R6,96,ERRET=BADRB   GET RB FROM DUMP
         MVC   RBPREFIX(96),0(R6)  MAKE A COPY OF IT
         GDUMP R2,LINE+0           FORMAT AND PRINT RB ADDRESS
         TM    COPYRB+X'0A',X'C0'  CHECK RB TYPE
         BZ    PRB
         BO    SVRB
         LA    R1,=CL8'(IRB)'
         B     RBTYPE
SVRB     LA    R1,=CL8'(SVRB)'
RBTYPE   DS    0H
         MVC   LINE+10(8),0(R1)    MOVE RB TYPE
         B     RBOUT
PRB      DS    0H
         XR    R7,R7
         ICM   R7,7,COPYRB+X'0D'   ADDRESS OF RBCDE
         BNZ   GOTACDE             IF ZERO, THEN...
         TM    COPYRB+X'0C',X'04'   IF REQUESTED BY SYNCH MACRO
         BZ    NOCDE                 THEN
         MVC   LINE+10(8),=CL8'(SYNCH)'   SAY SO
         B     RBOUT                 ELSE
NOCDE    MVC   LINE+10(8),=CL8'(NO CDE)'  JUST SAY NO CDE
         B     RBOUT
GOTACDE  DS    0H
         MVC   LINE+10(8),=CL8'(*N/A*)' IN CASE CDE NOT AVAILABLE
         GSTOR R7,32,ERRET=RBOUT   GET CDE FROM DUMP
         MVC   LINE+10(8),CDNAME-CDENTRY(R7) CDE NAME
RBOUT    DS    0H
         MVC   LINE+21(4),=C'INT='
         UNPK  LINE+25(3),COPYRB-1(2) INTERRUPT CODE
         TR    LINE+25(2),HEXTBL
         MVI   LINE+27,C' '
         MVC   LINE+29(4),=C'PSW='
         UNPK  LINE+33(9),COPYRB+X'10'(5) LEFT HALF OF RBOPSW
         TR    LINE+33(8),HEXTBL
         MVI   LINE+41,C' '
         UNPK  LINE+42(9),COPYRB+X'14'(5) RIGHT HALF OF RBOPSW
         TR    LINE+42(8),HEXTBL
         MVI   LINE+50,C' '
         L     R0,COPYRB+X'14'     GET RIGHT HALF OF PSW
         BAL   R14,FINDMOD         LOCATE MODULE WHERE IT IS
         BAL   R14,OUTPUT          PRINT CDE NAME TO IDENTIFY RB
RBNEXT   DS    0H
         TM    COPYRB+X'0B',X'80'  IF NEXTRB POINTS TO TCB
         BO    ENDRB               THEN NO MORE RB'S. ELSE
         XR    R6,R6
         ICM   R6,7,COPYRB+X'1D'   ADDRESS OF NEXT RB
         B     RBLOOP
BADRB    DS    0H                  RB STORAGE NOT AVAILABLE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'RBERRMSG),RBERRMSG
         GDUMP R6,LINE+L'RBERRMSG  FORMAT AND PRINT ADDRESS OF RB
         BAL   R14,OUTPUT
ENDRB    DS    0H
         ICM   R10,15,COPYTCB+X'2C' ADDRESS OF JOB PACK QUEUE
         BZ    ENDCDE
         MVC   LINE(L'JPQMSG),JPQMSG
         BAL   R14,OUTPUT          PRINT "MAPPING JOB PACK QUEUE"
CDELOOP  DS    0H
         BAL   R14,DUMPCDE         WRITE OUT CDE INFO
         ICM   R10,15,0(R10)
         BNZ   CDELOOP
ENDCDE   DS    0H
TCB2LOOP DS    0H
         ICM   R5,15,COPYTCB+X'24' ADDRESS OF LOAD LIST ELEMENTS
         BZ    ENDLLS
         MVC   LINE(L'LLSMSG),LLSMSG
         BAL   R14,OUTPUT          PRINT "MAPPING LOAD LIST"
LLSLOOP  DS    0H
         GSTOR R5,16,ERRET=BADLLS  GET LLS FROM DUMP
         L     R2,0(,R5)           SAVE ADDRESS OF NEXT LLS
         L     R10,4(,R5)          CDE FOR LOAD LIST ENTRY
         BAL   R14,DUMPCDE         WRITE OUT CDE INFO
NEXTLLS  DS    0H
         LTR   R5,R2               GET ADDRESS OF NEXT LLS
         BZ    ENDLLS
         B     LLSLOOP
BADLLS   DS    0H                  ERROR ACCESSING LLS
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'LLSERMSG),LLSERMSG
         GDUMP R5,LINE+L'LLSERMSG
         BAL   R14,OUTPUT
         SPACE 1
ENDLLS   DS    0H
         ICM   R8,15,COPYTCB+X'08' ADDRESS OF DEB
         BNZ   GOTDEBS
         MVC   LINE(L'NODEBS),NODEBS
         BAL   R14,OUTPUT          PRINT "NO OPEN DATA SETS"
         B     ENDDEB
GOTDEBS  DS    0H
         MVC   LINE(L'DEBMSG),DEBMSG
         GDUMP R8,LINE+L'DEBMSG    FORMAT AND PRINT ADDRESS OF DEB
         BAL   R14,OUTPUT          PRINT "MAPPING DEB CHAIN"
DEBLOOP  DS    0H
         MVC   LINE(4),=C'DEB='
         GDUMP R8,LINE+4           FORMAT AND PRINT ADDRESS OF DEB
         GSTOR R8,32,ERRET=BADDEB  GET DEB FROM DUMP
         MVC   COPYDEB(32),0(R8)   MAKE A COPY OF IT
         L     R9,COPYDEB+X'18'    ADDRESS OF DCB FOR THIS DEB
         N     R9,=X'00FFFFFF'     CLEAR HIGH ORDER BYTE
         MVC   LINE+14(4),=C'DCB='
         GDUMP R9,LINE+18          FORMAT AND PRINT ADDRESS OF DCB
         GSTOR R9,X'30',ERRET=BADDCB GET DCB FROM DUMP
         L     R2,COPYTCB+X'0C'    ADDRESS OF TIOT
         AH    R2,X'28'(,R9)       ADD TIOT OFFSET FROM DCB
         GSTOR R2,20,ERRET=BADTIOT GET TIOT ENTRY FROM DUMP
         MVC   LINE+28(8),4(R2)    DDNAME FROM TIOT
         MVI   LINE+36,C' '
         ICM   R9,7,X'C'(R2)       POINTER TO JFCB FROM TIOT
         LA    R9,X'10'(,R9)       ADDRESS OF JFCB
         GSTOR R9,176,ERRET=BADJFCB GET JFCB FROM DUMP
         MVC   LINE+37(44),0(R9)   DSNAME
         LA    R1,LINE+37+44-1
DSNLOOP  CLI   0(R1),C' '
         BNE   DSNEND
         BCTR  R1,0
         B     DSNLOOP
DSNEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN DSNAME
         CLI   44(R9),C' '         IF THERE IS A MEMBER NAME IN JFCB
         BE    NOMEMBER            THEN
         MVI   1(R1),C'('
         MVC   2(8,R1),44(R9)
         LA    R1,9(,R1)
MEMLOOP  CLI   0(R1),C' '
         BNE   MEMEND
         BCTR  R1,0
         B     MEMLOOP
MEMEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN MEMBER
         LA    R1,1(,R1)
         MVI   0(R1),C')'
NOMEMBER DS    0H                  R1 POINTS TO LAST NONBLANK
         TM    COPYDEB+X'08',X'01' IF CONCATENATED DATA SETS,
         BZ    PRINTDEB            THEN...
         MVC   2(7,R1),=C' ET AL.'  LET ME KNOW
         B     PRINTDEB
BADDCB   DS    0H                  ERROR ACCESSING DCB
         MVC   LINE+14(L'DCBERMSG),DCBERMSG
         GDUMP R9,LINE+14+L'DCBERMSG
         B     PRINTDEB
BADTIOT  DS    0H                  ERROR ACCESSING DCB
         MVC   LINE+28(L'TIOERMSG),TIOERMSG
         GDUMP R2,LINE+28+L'TIOERMSG
         B     PRINTDEB
BADJFCB  DS    0H                  ERROR ACCESSING DCB
         MVC   LINE+37(L'JFERRMSG),JFERRMSG
         GDUMP R9,LINE+37+L'JFERRMSG
         B     PRINTDEB
PRINTDEB DS    0H
         BAL   R14,OUTPUT          PRINT DEB=ADDR DCB=ADDR DDNAME
         B     NEXTDEB             GO TO NEXT DEB
BADOTHER DS    0H                  ERROR ACCESSING STORAGE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ERRMSG),ERRMSG
         BAL   R14,OUTPUT
******** B     NEXTDEB
NEXTDEB  DS    0H
         XR    R8,R8
         ICM   R8,7,COPYDEB+5      ADDRESS OF NEXT DEB
         BZ    ENDDEB
         B     DEBLOOP
BADDEB   DS    0H                  ERROR ACCESSING DEB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'DEBERMSG),DEBERMSG
         GDUMP R8,LINE+L'DEBERMSG
         BAL   R14,OUTPUT
ENDDEB   DS    0H
ENDPROC  DS    0H
         L     R14,PRCSSAVE        RETURN
         BR    R14
         EJECT
DUMPCDE  DS    0H                  THIS ROUTINE DUMPS A CDE
*
* THIS SUBROUTINE FORMATS AND WRITES OUT CDE INFORMATION,
* ON ENTRY R10 CONTAINS THE ADDRESS OF THE CDE.
*
         SPACE 1
         ST    R14,DCDESAVE        SAVE RETURN REGISTER
         ST    R10,DOUBLE          CDE ADDRESS
         GSTOR R10,32,ERRET=BADCDE GET CDE FROM DUMP
         USING CDENTRY,R10
         GDUMP *,LNCDADDR          FORMAT AND PRINT ADDRESS OF CDE
         MVC   LNCDNAME(8),CDNAME   CDE NAME
         MVC   LNCDEPEQ(3),=C'EP='
         GDUMP *,LNCDEPA,STG=CDENTPT ENTRY POINT FROM CDE
         TM    CDATTR,CDREN
         BZ    NOTRENT
         MVC   LNCDRENT,=C'RENT'
NOTRENT  TM    CDATTR,CDSER
         BZ    NOTREUS
         MVC   LNCDREUS,=C'REUS'
NOTREUS  TM    CDATTR2,CDEANYM
         BZ    NOTANY
         MVC   LNCDANY,=C'ANY'
NOTANY   TM    CDATTR2,CDOLY
         BZ    NOTOVLY
         MVC   LNCDOVLY,=C'OVLY'
NOTOVLY  TM    CDATTR2,CDSYSLIB
         BZ    NOTSYSL
         MVC   LNCDSYSL,=C'SYSLIB'
NOTSYSL  TM    CDATTR2,CDAUTH
         BZ    NOTAUTH
         MVC   LNCDAUTH,=C'AUTH'
NOTAUTH  DS    0H
         B     OUTCDE
BADCDE   DS    0H                  CDE STORAGE NOT AVAILABLE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'CDERRMSG),CDERRMSG
         GDUMP R10,LINE+L'CDERRMSG FORMAT AND PRINT CDE ADDRESS
OUTCDE   BAL   R14,OUTPUT          PRINT CDE MODULE NAME
         L     R14,DCDESAVE        RESTORE RETURN REGISTER
         BR    R14                 RETURN
         EJECT
BAD21C   DS    0H                  ERROR ACCESSING TCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ER21CMSG),ER21CMSG
         GDUMP R3,LINE+L'ER21CMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BAD218   DS    0H                  ERROR ACCESSING TCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ER218MSG),ER218MSG
         GDUMP R3,LINE+L'ER218MSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BAD224   DS    0H                  ERROR ACCESSING ASCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ER224MSG),ER224MSG
         GDUMP R3,LINE+L'ER224MSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BADTCB   DS    0H                  ERROR ACCESSING TCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'TCBERMSG),TCBERMSG
         GDUMP R3,LINE+L'TCBERMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BADASCB  DS    0H                  ERROR ACCESSING ASCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ASCBEMSG),ASCBEMSG
         GDUMP R3,LINE+L'ASCBEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BADASXB  DS    0H                  ERROR ACCESSING ASXB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ASXBEMSG),ASXBEMSG
         GDUMP R3,LINE+L'ASXBEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BADCVT   DS    0H                  ERROR ACCESSING ASXB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'CVTEMSG),CVTEMSG
         GDUMP R3,LINE+L'CVTEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BADCASVT DS    0H                  ERROR ACCESSING ASXB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'CASVEMSG),CASVEMSG
         GDUMP R3,LINE+L'CASVEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BADASVT  DS    0H                  ERROR ACCESSING ASXB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ASVTEMSG),ASVTEMSG
         GDUMP R3,LINE+L'ASVTEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
STORERR  DS    0H                  ERROR ACCESSING STORAGE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ERRMSG),ERRMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
FINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME
*                                  R0 CONTAINS ADDRESS TO SEARCH ON
         ST    R14,FMSAVE
         LTR   R0,R0               IF AMODE 31 BIT IS NOT ON
         BM    FMASIS              THEN
         N     R0,=X'00FFFFFF'      CLEAR HIGH-ORDER BYTE FOR 24-BIT AD
FMASIS   DS    0H
         ICM   R15,15,WHRADDR
         BNZ   FMGOTWHR
         ST    R0,FMWORK
         LOAD  EPLOC==CL8'XIPSWHR',ERRET=FMNF
         ST    R0,WHRADDR
         LR    R15,R0
         L     R0,FMWORK
FMGOTWHR DS    0H
         L     R14,FIRSTTCB        Get address of first TCB
         ST    R14,ADPLCOM1        Set first-TCB pointer for XIPSWHR
         LR    R1,R4               POINT TO ABDPL
         BASSM R14,R15             CALL XIPSWHR TO GET MODULE NAME
         CLI   ADPLFMT1,C' '       IF NOT FOUND...
         BE    FMNF
         CLI   ADPLFMT1,C'E'       IF STORAGE ERROR...
         BE    FMERR
         MVC   LINE+52(16),ADPLCOM1
         B     FMRET
FMERR    DS    0H
         MVC   LINE+52(16),=CL16'(STORAGE ERROR) '
         B     FMRET
FMNF     DS    0H
         MVC   LINE+52(16),=CL16'(UNKNOWN)       '
FMRET    DS    0H
         L     R14,FMSAVE
         BR    R14
         EJECT
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT-ABDPL(,R1) GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15                 CALL IT
         LTR   R15,R15
         BNZ   RETURN0
         L     R11,ADPLBUF-ABDPL(,R1)  POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         ICM   R15,R15,WHRADDR
         BZ    NODELETE
         DELETE EPLOC==CL8'XIPSWHR'
NODELETE DS    0H
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
HIMSG    DC    C'                 MAP FOR ASID '
TCBMSG   DC    C'*** P R O C E S S I N G   T C B *** - '
CMPMSG   DC    C'*** COMPCODE='
RTM2MSG  DC    C' RTWA AT '
RBMSG    DC    C'---MAPPING RBS - '
JPQMSG   DC    C'---MAPPING CDES FROM JOB PACK QUEUE'
LLSMSG   DC    C'---MAPPING CDES FROM LOAD LIST'
NODEBS   DC    C'---TASK HAS NO OPEN DATA SETS'
DEBMSG   DC    C'---MAPPING DEBS - '
TRY218   DC    C'PSATOLD TCB POINTER IS ZEROES, USING PSATNEW POINTER'
TRY224   DC    C'PSATNEW TCB POINTER IS ZEROES, USING ASXB POINTER'
ERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'
ER21CMSG DC    C'ERROR - PSATOLD UNAVAILABLE'
ER218MSG DC    C'ERROR - PSATNEW UNAVAILABLE'
ER224MSG DC    C'ERROR - ASCB UNAVAILABLE'
TCBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR TCB AT '
ASCBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASCB AT '
ASXBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASXB AT '
RBERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR RB AT '
CDERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR CDE AT '
LLSERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR LLS AT '
DEBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR DEB AT '
DCBERMSG DC    C'DCB UNAVAILABLE AT '
TIOERMSG DC    C'TIOT ENTRY UNAVAILABLE AT '
JFERRMSG DC    C'JFCB UNAVAILABLE AT '
CVTEMSG  DC    C'CVT ASVT POINTER UNAVAILABLE AT '
CASVEMSG DC    C'ASVT ADDRESS UNAVAILABLE AT '
ASVTEMSG DC    C'ASVT ASCB POINTER UNAVAILABLE AT '
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ...........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D
PRCSSAVE DS    A                   SAVE AREA FOR PROCESS SUBROUTINE
DCDESAVE DS    A                   SAVE AREA FOR DUMPCDE SUBROUTINE
OUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE
FMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE
FMWORK   DS    A                   WORK AREA FOR FINDMOD SUBROUTINE
WHRADDR  DS    A                   ADDRESS OF XIPSWHR LOAD MODULE
FIRSTTCB DS    A                   Address of first TCB to search
         SPACE 1
COPYTCB  DS    CL256               COPY OF MOST OF TCB
COPYDEB  DS    CL32                COPY OF MOST OF DEB
RBPREFIX DS    CL32                COPY OF RB PREFIX
COPYRB   DS    CL64                COPY OF MOST OF RB
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINEDSCT DSECT ,                   MAP THE OUTPUT BUFFER
LINE     DS    CL132               WORD AREA FOR OUTPUT LINES
         ORG   LINE
LNCDADDR DS    CL8                 ADDRESS OF CONTROL BLOCK
         DS    CL2
LNCDNAME DS    CL8                 NAME
         DS    CL3
LNCDEPEQ DS    C'EP='              "EP="
LNCDEPA  DS    CL8                 ENTRY POINT
         DS    CL3                 FOLLOWED BY ATTRIBUTES
LNCDRENT DS    C'RENT'
         DS    CL1
LNCDREUS DS    C'REUS'
         DS    CL1
LNCDANY  DS    C'ANY'
         DS    CL1
LNCDOVLY DS    C'OVLY'
         DS    CL1
LNCDSYSL DS    C'SYSLIB'
         DS    CL1
LNCDAUTH DS    C'AUTH'
         DS    CL1
         ORG
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         BLSABDPL
         SPACE 1
         IHACDE
         SPACE 1
         END
./ ADD NAME=XIPSWHR
         TITLE 'XIPSWHR - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'XIPSWHR - VERB EXIT SUBROUTINE TO LOCATE AN ADDRESS'
         SPACE 1
***********************************************************************
*                                                                     *
* THIS SUBROUTINE IS INVOKED FROM IPCS VERB EXITS TO RETURN           *
* INFORMATION ABOUT AN ADDRESS.                                       *
*                                                                     *
* ON ENTRY REGISTER 1 POINTS TO THE ABDPL (EXIT PARAMETER LIST),      *
*      AND REGISTER 0 CONTAINS THE ADDRESS TO BE SEARCHED FOR.        *
*                                                                     *
* In addition, the following field must be filled in by the caller:   *
*                                                                     *
*    ADPLCOM1 - 4 bytes - the address of the first TCB to search,     *
*                         or zeroes if not known.                     *
*                                                                     *
* ON RETURN THE FOLLOWING FIELDS OF THE PARAMETER LIST ARE FILLED:    *
*                                                                     *
*    ADPLCOM1 - 8 BYTES - THE NAME OF THE MODULE IT WAS FOUND IN.     *
*                                                                     *
*    ADPLCOM3 - 8 BYTES - EBCDIC REPRESENTATION OF THE OFFSET,        *
*                         INCLUDING LEADING PLUS SIGN.                *
*                                                                     *
*    ADPLFMT1 - ONE OF THE FOLLOWING 4-CHARACTER VALUES:              *
*                                                                     *
*    "JPA "  -  THE ADDRESS IS IN A MODULE IN THE JOB PACK AREA.      *
*    "PLPA"  -  THE ADDRESS IS IN A PAGEABLE LINK PACK AREA MODULE.   *
*    "MLPA"  -  THE ADDRESS IS IN A MODULE IN THE MLPA.               *
*    "NUC "  -  THE ADDRESS IS IN THE NUCLEUS.                        *
*    "ERR "  -  A STORAGE ERROR OCCURRED TRYING TO LOCATE IT.         *
*    "    "  -  BLANK IF THE ADDRESS WAS NOT FOUND.                   *
*                                                                     *
*    ADPLFMT2 - THE BINARY VALUE OF THE OFFSET.                       *
*                                                                     *
* NOTE: THIS ROUTINE MUST BE INVOKED VIA LINK OR LOAD/BASSM,          *
*       SINCE IT RUNS IN AMODE 31.                                    *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3    DUMP STORAGE ACCESS REGISTER
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    INPUT ADDRESS TO BE SEARCHED FOR
R6       EQU   6    POINTER TO TCB
R7       EQU   7    POINTER TO CDE
R8       EQU   8    USED IN NUCMAP SCANNING
R9       EQU   9    USED IN NUCMAP SCANNING
R10      EQU   10   .
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XIPSWHR  CSECT
XIPSWHR  AMODE 31
XIPSWHR  RMODE 24
         SAVE  (14,12),,XIPSWHR_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XIPSWHR,R12
         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LR    R5,R0               SAVE INPUT ADDRESS PARAMETER
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         EJECT
         N     R5,=X'7FFFFFFF'     CLEAR HIGH ORDER BIT OF ADDRESS
         MVC   ADPLFMT1(4),=C'    '
         EJECT
*
* If a TCB address has been provided by the caller, it will be in
* the ADPLCOM1 field and nonzero.  In this case, use that as the
* first TCB to search, since that should have been chosen to work
* with the current ASID.
*
         ICM   R6,15,ADPLCOM1      Get communication word TCB address
         BNZ   GOT1TCB             If provided, skip TCB search
         EJECT
*
* We don't do this anymore.  Must go by current ASID.
*
* FIRST SEARCH THE JOB PACK AREA.
*        SPACE 1
*        LA    R6,X'21C'           ADDRESS OF CVTTCBP
*        GSTOR R6,4                GET PSATOLD FROM DUMP
*        L     R6,0(,R6)           ADDRESS OF CURRENT TCB
*        LTR   R6,R6               IF POINTER AT 21C IS ZEROES,
*        BNZ   GOT1TCB             THEN...
*        LA    R6,X'218'
*        GSTOR R6,4                GET PSATNEW FROM DUMP
*        L     R6,0(,R6)           ADDRESS OF CURRENT TCB
*        LTR   R6,R6               IF POINTER AT 218 IS ZEROES,
*        BNZ   GOT1TCB             THEN...
*        LA    R6,X'224'            TRY VIA ASCB
*        GSTOR R6,4                GET PSA'S ASCB PTR FROM DUMP
*        L     R6,0(,R6)           ADDRESS OF CURRENT ASCB
*        GSTOR R6,X'70'            GET CURRENT ASCB FROM DUMP
*        L     R6,X'6C'(,R6)       GET POINTER TO ASXB
*        GSTOR R6,8                GET ASXB FROM DUMP
*        L     R6,4(,R6)           GET 1ST TCB ADDRESS FROM ASXB
*
         L     R6,ADPLCVT          Get CVT pointer
         LA    R6,X'22C'(,R6)      CVT+22C -> ASVT
         GSTOR R6,4                Get loc of CVT's ASVT ptr from dump
         L     R6,0(,R6)           Load address of CVT's ASVT pointer
         LH    R2,ADPLASID         Get the current ASID
         SLA   R2,2                Multiply by 4 making index into ASVT
         LA    R6,X'20C'(R2,R6)    Point to ASCB address for this ASID
         GSTOR R6,4                Get ASCB address from dump
         L     R6,0(,R6)           Load the ASCB address
         GSTOR R6,X'70'            Get the ASCB from dump
         L     R6,X'6C'(,R6)       GET POINTER TO ASXB
         GSTOR R6,8                GET ASXB FROM DUMP
         L     R6,4(,R6)           GET 1ST TCB ADDRESS FROM ASXB
*
GOT1TCB  DS    0H                  SCAN FOR TOP TCB
         SPACE 1
         GSTOR R6,X'A0'            GET MOST OF THIS TCB FROM DUMP
         USING TCB,R6
*
* WE DON'T GO DIRECTLY TO THE JOB STEP TCB ANY MORE, SINCE UNDER
* PIE/SESSIONS THERE MAY BE MORE THAN ONE.  INSTEAD, WE GO TO THE
* TOP OF THE TCB TREE EVERY TIME, AND THEN DESCEND LEVELS UNTIL
* WE FIND THE LEVEL WITH THE JOB STEP TCB'S.  ALL THE SISTERS IN
* THAT LEVEL ARE THEN PROCESSED.
*
****     LA    R6,TCBJSTCB         POINTER TO JOB STEP TCB
****     GSTOR R6,4                GET TCBJSTCB FROM DUMP
****     L     R6,0(,R6)           ADDRESS OF JOB STEP TCB
****     GSTOR R6,X'A0'            GET MOST OF JSTCB FROM DUMP
****     L     R7,TCBJPQ           ADDRESS OF FIRST CDE IN JOB PACK Q
****     LTR   R7,R7               IF NO CDE'S IN JOB PACK QUEUE
****     BNZ   LOOPCDE             THEN...
*
* IF JSTCB HAS NO JOB PACK QUEUE, THIS MAY BE A DUMP OF JES2 OR
* SOMETHING WHERE THE JSTCB IS NOT THE TCB WITH THE JPQ.  WE MUST
* THEN SEARCH FOR THE TCB WITH THE GOODS.
*
FINDTOP  DS    0H
         L     R7,TCBOTC           GET ADDRESS OF MOTHER TCB
         LTR   R7,R7               IF ZERO, THEN...
         BZ    TRYJPQ               THIS IS THE TOP TCB
         LR    R6,R7               ELSE GET ADDRESS OF THIS TCB
         GSTOR R6,X'A0'            GET MOST OF THIS TCB FROM DUMP
         B     FINDTOP             CONTINUE SEARCHING FOR TOP TCB
TRYJPQ   DS    0H                  R6 --> TOP TCB FROM DUMP
         MVC   COPYTCB(X'A0'),0(R6)
         LA    R6,COPYTCB
         L     R7,TCBJPQ           OK, TRY THE JOB PACK QUEUE HERE
         LTR   R7,R7               IF WE GOT ONE,
         BNZ   LOOPCDE             THEN GO TO SCAN IT.
         L     R7,TCBLTC           ELSE GET NEXT DAUGHTER TASK
         LTR   R7,R7               IF NONE,
         BZ    ENDCDE              THEN GIVE UP, NO JOB PACK FOUND
         LR    R6,R7               ELSE...
         GSTOR R6,X'A0'            GET IT FROM THE DUMP
         B     TRYJPQ              AND TRY IT AGAIN.
LOOPCDE  DS    0H                  LOOP THROUGH CDE'S
         LTR   R7,R7               UNTIL NO MORE
         BZ    ENDCDE
         GSTOR R7,32               GET CDE FROM DUMP
         MVC   COPYCDE(32),0(R7)   COPY INTO OUR WORK AREA
         LA    R7,COPYCDE
         USING CDENTRY,R7
         TM    CDATTR,CDMIN        IF THIS IS A MINOR CDE,
         BO    CONTCDE             THEN SKIP IT
         L     R3,CDXLMJP          ELSE GET ADDRESS OF EXTENT LIST
         LTR   R3,R3               IF NONE
         BZ    CONTCDE             THEN SKIP THIS CDE, GO TO NEXT ONE
         GSTOR R3,16               GET XTLST FROM DUMP
         USING XTLST,R3
         L     R0,XTLMSBAA         GET LOAD POINT
         N     R0,=X'7FFFFFFF'
         XR    R1,R1
         ICM   R1,7,XTLMSBLN       GET MODULE LENGTH
         ALR   R1,R0               CONVERT IT TO LOAD END POINT
         CR    R0,R5               IF ADDRESS LESS THAN LOAD POINT
         BH    CONTCDE             THEN THIS IS NOT THE ONE
         CR    R1,R5               IF ADDRESS NOT LESS THAN LOAD END
         BNH   CONTCDE             THEN THIS IS NOT THE ONE
         LR    R2,R5               ELSE ADDRESS MINUS LOAD POINT
         SR    R2,R0                GIVES OFFSET WITHIN JPA MODULE
         ST    R2,ADPLFMT2         PUT OFFSET IN RETURN FIELD
         MVC   ADPLFMT1(4),=C'JPA ' TELL WHERE IT WAS FOUND
         MVC   ADPLCOM1(8),CDNAME   PUT MODULE NAME IN RETURN FIELD
         B     FORMAT              GO TO FORMAT OFFSET AND RETURN
CONTCDE  DS    0H
         L     R7,CDCHAIN          GET ADDRESS OF NEXT CDE IN CHAIN
         B     LOOPCDE             CONTINUE LOOPING
ENDCDE   DS    0H                  SCANNED ALL OF JPQ - NOT FOUND YET
         SPACE 1
JSSISTER DS    0H
         L     R7,TCBNTC           GET SISTER TASK
         LTR   R7,R7               IF NONE,
         BZ    NOSISTER            THEN THROUGH WITH SISTER TASKS
         LR    R6,R7               ELSE...
         GSTOR R6,X'A0'            GET IT FROM THE DUMP
         MVC   COPYTCB(X'A0'),0(R6)
         LA    R6,COPYTCB
         L     R7,TCBJPQ           TRY THE JOB PACK QUEUE HERE
         LTR   R7,R7               IF WE GOT ONE,
         BNZ   LOOPCDE             THEN GO TO SCAN IT
         B     JSSISTER            ELSE TRY NEXT SISTER
NOSISTER DS    0H
         L     R7,TCBLTC           GET NEXT DAUGHTER TASK
         LTR   R7,R7               IF NONE,
         BZ    ENDJSTS             THEN GIVE UP, NO JOB PACK FOUND
         LR    R6,R7               ELSE...
         GSTOR R6,X'A0'            GET IT FROM THE DUMP
         B     TRYJPQ              AND TRY IT AGAIN.
ENDJSTS  DS    0H                  NO MORE JOB STEP TCB'S
         EJECT
* THEN SEARCH THE LINK PACK AREA.
         SPACE 1
         L     R3,ADPLCVT          ADDRESS OF CVT
         USING CVT,R3
         LA    R3,CVTLPDIR         POINTER TO LPA DIRECTORY
         GSTOR R3,3                GET CVTLPDIR FROM DUMP
         XR    R7,R7
         ICM   R7,7,0(R3)          ADDRESS OF LPA DIRECTORY
         USING LPDE,R7
LOOPLPDE DS    0H                  LOOP THROUGH LPDE'S
         LA    R2,LPDEXTAD+4       GET TRUE ADDR OF NEXT LPDE IN CHAIN
         GSTOR R7,40               GET LPA DIRECTORY FROM DMP
         ICM   R0,15,LPDENTP       UNTIL NO MORE
         BZ    ENDLPDE
         TM    LPDEATTR,LPDEMIN    IF THIS IS A MINOR LPDE,
         BO    CONTLPDE            THEN SKIP IT
         L     R0,LPDEXTAD         GET LOAD POINT
         N     R0,=X'7FFFFFFF'
         ICM   R1,15,LPDEXTLN      GET MODULE LENGTH
         ALR   R1,R0               CONVERT IT TO LOAD END POINT
         CR    R0,R5               IF ADDRESS LESS THAN LOAD POINT
         BH    CONTLPDE            THEN THIS IS NOT THE ONE
         CR    R1,R5               IF ADDRESS NOT LESS THAN LOAD END
         BNH   CONTLPDE            THEN THIS IS NOT THE ONE
         LR    R1,R5               ELSE ADDRESS MINUS LOAD POINT
         SR    R1,R0                GIVES OFFSET WITHIN PLPA MODULE
         ST    R1,ADPLFMT2         PUT OFFSET IN RETURN FIELD
         MVC   ADPLFMT1(4),=C'PLPA' TELL WHERE IT WAS FOUND
         MVC   ADPLCOM1(8),LPDENAME PUT MODULE NAME IN RETURN FIELD
         B     FORMAT
CONTLPDE DS    0H
         LR    R7,R2               GET (SAVED) ADDRESS OF NEXT LPDE
         B     LOOPLPDE            CONTINUE LOOPING
ENDLPDE  DS    0H                  SCANNED ALL PLPA - NOT FOUND YET
         EJECT
* THEN SEARCH THE MLPA.
         SPACE 1
         L     R3,ADPLCVT          ADDRESS OF CVT
         USING CVT,R3
         LA    R3,CVTQLPAQ         POINTER TO MLPA CDE'S
         GSTOR R3,4                GET ADDR OF 1ST LPAQ CDE FROM DUMP
         L     R3,0(,R3)           ADDRESS OF POINTER TO 1ST LPA Q CDE
         GSTOR R3,4                GET ADDR OF 1ST LPAQ CDE FROM DUMP
         L     R7,0(,R3)           ADDRESS OF FIRST CDE IN LPA Q
LOOPMLPA DS    0H                  LOOP THROUGH CDE'S
         LTR   R7,R7               UNTIL NO MORE
         BZ    ENDMLPA
         GSTOR R7,32               GET CDE FROM DUMP
         MVC   COPYCDE(32),0(R7)   COPY INTO OUR WORK AREA
         LA    R7,COPYCDE
         USING CDENTRY,R7
         TM    CDATTR,CDMIN        IF THIS IS A MINOR CDE,
         BO    CONTMLPA            THEN SKIP IT
         L     R3,CDXLMJP          ELSE GET ADDRESS OF EXTENT LIST
         GSTOR R3,16               GET XTLST FROM DUMP
         USING XTLST,R3
         L     R0,XTLMSBAA         GET LOAD POINT
         N     R0,=X'7FFFFFFF'
         XR    R1,R1
         ICM   R1,7,XTLMSBLN       GET MODULE LENGTH
         ALR   R1,R0               CONVERT IT TO LOAD END POINT
         CR    R0,R5               IF ADDRESS LESS THAN LOAD POINT
         BH    CONTMLPA            THEN THIS IS NOT THE ONE
         CR    R1,R5               IF ADDRESS NOT LESS THAN LOAD END
         BNH   CONTMLPA            THEN THIS IS NOT THE ONE
         LR    R2,R5               ELSE ADDRESS MINUS LOAD POINT
         SR    R2,R0                GIVES OFFSET WITHIN JPA MODULE
         ST    R2,ADPLFMT2         PUT OFFSET IN RETURN FIELD
         MVC   ADPLFMT1(4),=C'MLPA' TELL WHERE IT WAS FOUND
         MVC   ADPLCOM1(8),CDNAME   PUT MODULE NAME IN RETURN FIELD
         B     FORMAT
CONTMLPA DS    0H
         L     R7,CDCHAIN          GET ADDRESS OF NEXT CDE IN CHAIN
         B     LOOPMLPA            CONTINUE LOOPING
ENDMLPA  DS    0H                  SCANNED ALL MLPA - NOT FOUND YET
         EJECT
* THEN SEARCH THE NUCLEUS MAP.
         SPACE 1
         L     R3,ADPLCVT          ADDRESS OF CVT
         USING CVT,R3
         LA    R3,CVTNUCMP         POINTER TO NUCLEUS MAP
         GSTOR R3,4                GET ADDR OF NUCMAP FROM DUMP
         L     R3,0(,R3)           ADDRESS OF NUCMAP
         LR    R2,R5               SET ADDRESS FOR COMPARISONS
         LR    R7,R3               SAVE DUMP ADDRESS
         GSTOR R3,16               GET NUCMAP HEADER FROM DUMP
         L     R9,X'08'(,R3)       GET ADDRESS OF LAST NUCMAP ENTRY
         LA    R8,16               SET NUCMAP ENTRY INCREMENT
LOOPNUC  DS    0H                  LOOP THROUGH CDE'S
         BXH   R7,R8,ENDNUC        BUMP TO NEXT NUCMAP ENTRY UNTIL LAST
         LR    R3,R7               GET ADDRESS OF NUCMAP ENTRY
         GSTOR R3,16               GET NUCMAP ENTRY FROM DUMP
         TM    X'0C'(R3),X'10'     IF THIS IS NOT A CSECT ENTRY
         BNO   LOOPNUC             THEN CONTINUE
         L     R0,X'08'(,R3)       GET LOCATION OF NUCLEUS CSECT
         CR    R2,R0               IF ADDRESS LESS THAN NUC CSECT LOC
         BL    LOOPNUC             THEN THIS IS NOT THE ONE
         XR    R1,R1
         ICM   R1,7,X'0D'(R3)      GET LENGTH
         ALR   R1,R0               ADD LOC GIVING END POINT
         CR    R2,R1               IF ADDRESS NOT LESS THAN END POINT
         BNL   LOOPNUC             THEN THIS IS NOT THE ONE
*                                  ELSE ADDRESS MINUS LOAD POINT
         SR    R2,R0                GIVES OFFSET WITHIN JPA MODULE
         ST    R2,ADPLFMT2         PUT OFFSET IN RETURN FIELD
         MVC   ADPLFMT1(4),=C'NUC ' TELL WHERE IT WAS FOUND
         MVC   ADPLCOM1(8),0(R3)    PUT MODULE NAME IN RETURN FIELD
         B     FORMAT
ENDNUC   DS    0H
         SPACE 1
* IF ALL FAILS, NOT FOUND.
         SPACE 1
         B     NOTFOUND
         EJECT
STORERR  DS    0H                  ERROR ACCESSING STORAGE
         SPACE 1
         MVC   ERRBUG(L'BUGMSG),BUGMSG
         STCM  R0,15,OFFWORK
         UNPK  ERRWORK(9),OFFWORK(5)
         TR    ERRWORK(8),HEXTBL
         MVI   ERRWORK+8,C' '
         LA    R1,ERRBUG
         LA    R0,L'ERRBUG
         TPUT  (1),(0),R
         SPACE 1
         XR    R2,R2
         ST    R2,ADPLFMT2         PUT NO OFFSET IN RETURN FIELD
         MVC   ADPLFMT1(4),=C'ERR ' TELL WHY IT WAS NOT FOUND
         MVI   ADPLCOM1,C' '        PUT BLANKS IN RETURN FIELD
         MVC   ADPLCOM1+1(7),ADPLCOM1
         B     FORMAT
         EJECT
NOTFOUND DS    0H
         SPACE 1
         XR    R2,R2
         ST    R2,ADPLFMT2         PUT NO OFFSET IN RETURN FIELD
         MVC   ADPLFMT1(4),=C'    ' TELL WHERE IT WAS NOT FOUND
         MVI   ADPLCOM1,C' '        PUT BLANKS IN RETURN FIELD
         MVC   ADPLCOM1+1(7),ADPLCOM1
         B     FORMAT
         EJECT
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BASSM R14,R15             CALL IT
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
FORMAT   DS    0H                  FORMAT OFFSET AND RETURN
         MVI   ADPLCOM3,C'+'       BEGIN FORMATTING OFFSET FIELD
         MVI   ADPLCOM3+1,C' '     CLEAR OFFSET RETURN FIELD TO BLANKS
         MVC   ADPLCOM3+2(6),ADPLCOM3+1
         UNPK  OFFWORK(7),ADPLFMT2+1(4) FORMAT OFFSET FIELD IN WORKAREA
         TR    OFFWORK(6),HEXTBL
         LA    R0,5                SKIP OVER LEADING ZEROES
         LA    R1,OFFWORK
OFFLOOP  DS    0H
         CLI   0(R1),C'0'
         BNE   OFFEND
         LA    R1,1(,R1)
         BCT   R0,OFFLOOP
OFFEND   DS    0H
         LA    R15,OFFWORK+5
         SR    R15,R1
         EX    R15,OFFMOVE
         B     RETURN
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BSM   0,R14               RETURN IN CALLER'S ADDRESSING MODE
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
OFFMOVE  MVC   ADPLCOM3+1(*-*),0(R1) MOVE FORMATTED OFFSET TO FIELD
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
BUGMSG   DC    C'XIPSWHR: STORAGE NOT AVAILABLE AT ADDRESS '
ERRMSG   DC    C'XIPSWHR: ERROR ACCESSING STORAGE IN MODULE SEARCH.'
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ...........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
OUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE
COPYCDE  DS    CL32                WORK AREA FOR CDE'S
COPYTCB  DS    CL(X'A0')           WORK AREA FOR TCB'S
OFFWORK  DS    CL8                 WORK AREA TO BUILD OFFSET
ERRBUG   DS    CL(L'BUGMSG+9)
ERRWORK  EQU   *-9,9,C'C'
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL132               WORD AREA FOR OUTPUT LINES
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 2
         IHACDE
         EJECT
         IHAXTLST
         EJECT
         IHALPDE
         EJECT
         IKJTCB
         EJECT
         CVT   DSECT=YES
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ADD NAME=XIPWHR
         TITLE 'XIPWHR - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'XIPWHR - IPCS VERB EXIT TO TELL WHERE AN ADDRESS IS'
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3    DUMP STORAGE ACCESS REGISTER
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    ADDRESS OF OPERAND
R6       EQU   6    LENGTH OF OPERAND
R7       EQU   7    POINTER TO CDE
R8       EQU   8    USED IN NUCMAP SCANNING
R9       EQU   9    USED IN NUCMAP SCANNING
R10      EQU   10   POINTER TO PARAMETER LIST EXTENSION
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XIPWHR   CSECT
         SAVE  (14,12),,XIPWHR_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XIPWHR,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO
         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION
         EJECT
* EXTRACT THE PARAMETER (MUST BE AN ADDRESS).
         SPACE 1
         L     R5,ADPLOPTR         GET ADDRESS OF OPERAND FIELD
         LTR   R5,R5               IF ZERO,
         BZ    MISSING              THEN MISSING
         LH    R6,ADPLOPLN         GET LENGTH OF OPERAND FIELD
         LTR   R6,R6               IF ZERO,
         BNP   MISSING              THEN MISSING
         LA    R1,0(R5,R6)         POINT TO END OF OPERAND FIELD
         BCTR  R1,0                POINT TO LAST CHARACTER OF OPERAND
         CLI   0(R1),C'.'          IF A PERIOD
         BNE   NOTPD               THEN
         BCTR  R6,0                 REDUCE LENGTH BY 1
NOTPD    LTR   R6,R6               IF REMAINING LENGTH IS ZERO
         BNP   INVALID             THEN BAD ADDRESS
         CH    R6,=H'8'            IF MORE THAN 8 CHARACTERS,
         BH    TOOLONG              THEN TOO LONG
         BCTR  R6,0                ELSE REDUCE FOR EXECUTES
         EX    R6,TRTOP            SCAN FOR VALID HEX CHARACTERS
         BNZ   INVALID             IF BAD CHARACTERS, INVALID
         EX    R6,MVCOP            ELSE MOVE OPERAND TO SAFE AREA
         EX    R6,TROP             TRANSLATE ABCDEF TO FAFBFCFDFEFF
         LA    R6,1(,R6)           ADD 1 FOR PACKING EXTRA BYTE
         EX    R6,PACKOP           CREATE FULLWORD HEX ADDRESS FIELD
*                                  THIS SETS FIELD "ADDRESS"
         EJECT
         XR    R0,R0
         ST    R0,ADPLCOM1         Clear XIPSWHR communication word
         L     R0,ADDRESS          GET BINARY ADDRESS VALUE
         LR    R1,R4               GET ADDRESS OF ABDPL
         SPACE 1
         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE
         SPACE 1
         UNPK  LINE+00(9),ADDRESS(5)
         TR    LINE+00(8),HEXTBL
         MVI   LINE+08,C'.'
         CLC   ADPLFMT1(4),=C'    '
         BE    NOTFOUND
         CLC   ADPLFMT1(4),=C'JPA '
         BE    INJPA
         CLC   ADPLFMT1(4),=C'PLPA'
         BE    INPLPA
         CLC   ADPLFMT1(4),=C'MLPA'
         BE    INMLPA
         CLC   ADPLFMT1(4),=C'NUC '
         BE    INNUC
         CLC   ADPLFMT1(4),=C'ERR '
         BE    INERROR
         B     INLIMBO
         EJECT
NOTFOUND DS    0H
         SPACE 1
         MVC   LINE+09(L'NFMSG),NFMSG
         B     ERROUT
         EJECT
INERROR  DS    0H
         SPACE 1
         MVC   LINE+09(L'ERMSG),ERMSG
         B     ERROUT
         SPACE 1
INVALID  MVC   LINE(L'INVMSG),INVMSG
         B     ERROUT
         SPACE 1
TOOLONG  MVC   LINE(L'TLMSG),TLMSG
         B     ERROUT
         SPACE 1
MISSING  MVC   LINE(L'MISSMSG),MISSMSG
         B     ERROUT
         SPACE 1
STORERR  DS    0H                  ERROR ACCESSING STORAGE
         MVC   LINE(L'ERMSG),ERMSG
ERROUT   DS    0H
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 1
INJPA    DS    0H
         SPACE 1
         MVC   LINE+09(L'JPAMSG),JPAMSG
         MVC   LINE+09+L'JPAMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'JPAMSG+08,C' '
         MVC   LINE+09+L'JPAMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'JPAMSG+10,C' '
         MVC   LINE+09+L'JPAMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INPLPA   DS    0H
         SPACE 1
         MVC   LINE+09(L'PLPAMSG),PLPAMSG
         MVC   LINE+09+L'PLPAMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'PLPAMSG+08,C' '
         MVC   LINE+09+L'PLPAMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'PLPAMSG+10,C' '
         MVC   LINE+09+L'PLPAMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INMLPA   DS    0H
         SPACE 1
         MVC   LINE+09(L'MLPAMSG),MLPAMSG
         MVC   LINE+09+L'MLPAMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'MLPAMSG+08,C' '
         MVC   LINE+09+L'MLPAMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'MLPAMSG+10,C' '
         MVC   LINE+09+L'MLPAMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INNUC    DS    0H
         SPACE 1
         MVC   LINE+09(L'NUCMSG),NUCMSG
         MVC   LINE+09+L'NUCMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'NUCMSG+08,C' '
         MVC   LINE+09+L'NUCMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'NUCMSG+10,C' '
         MVC   LINE+09+L'NUCMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INLIMBO  DS    0H
         SPACE 1
         MVC   LINE+09(L'LIMBOMSG),LIMBOMSG
         MVC   LINE+09+LIMBOFF(4),ADPLFMT1
         MVC   LINE+09+L'LIMBOMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'LIMBOMSG+08,C' '
         MVC   LINE+09+L'LIMBOMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'LIMBOMSG+10,C' '
         MVC   LINE+09+L'LIMBOMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15             CALL IT
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
TRTOP    TRT   0(*-*,R5),VALTBL    SCAN FOR VALID HEX CHARACTERS
MVCOP    MVC   OPWORK(*-*),0(R5)   MOVE OPERAND TO SAFE AREA
TROP     TR    OPWORK(0),FTBL      TRANSLATE ABCDEF TO FAFBFCFDFEFF
PACKOP   PACK  ADDRESS(5),OPWORK(0) CREATE BINARY VALUE FROM OPERAND
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
MISSMSG  DC    C'ADDRESS OPERAND MISSING'
TLMSG    DC    C'ADDRESS OPERAND TOO LONG'
INVMSG   DC    C'ADDRESS OPERAND SYNTAX ERROR'
JPAMSG   DC    C'  FOUND IN JPA MODULE '
PLPAMSG  DC    C'  FOUND IN PLPA MODULE '
MLPAMSG  DC    C'  FOUND IN MLPA MODULE '
NUCMSG   DC    C'  FOUND IN NUCLEUS CSECT '
NFMSG    DC    C'  NOT FOUND IN JPA, LPA OR NUCLEUS'
ERMSG    DC    C'  STORAGE ERROR - UNABLE TO FIND MODULE'
LIMBOMS1 DC    C'  FOUND IN '
LIMBOMS2 DC    CL4'    '
LIMBOMS3 DC    C' MODULE '
LIMBOMSG EQU   LIMBOMS1,*-LIMBOMS1,C'C'
LIMBOFF  EQU   LIMBOMS2-LIMBOMS1
         SPACE
VALTBL   DC    256YL1(1)
         ORG   VALTBL+X'81'
         DC    6YL1(0)             LOWER CASE ABCDEF
         ORG   VALTBL+C'A'
         DC    6YL1(0)             UPPER CASE ABCDEF
         ORG   VALTBL+C'0'
         DC    10YL1(0)            0123456789
         ORG
         SPACE
FTBL     DC    256YL1(*-FTBL)
         ORG   FTBL+X'81'
         DC    X'FAFBFCFDFEFF'     LOWER CASE ABCDEF
         ORG   FTBL+C'A'
         DC    X'FAFBFCFDFEFF'     UPPER CASE ABCDEF
         ORG
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ...........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
OUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE
ADDRESS  DS    A                   THE ADDRESS TO BE SEARCHED ON
         DS    XL1                 PADDING FOR CONVERSION
OPWORK   DS    0F,CL9              WORK AREA FOR OPERAND CONVERSION
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL133               WORD AREA FOR OUTPUT LINES
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 2
         IHACDE
         EJECT
         IHAXTLST
         EJECT
         IHALPDE
         EJECT
         IKJTCB
         EJECT
         CVT   DSECT=YES
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ADD NAME=XITMAP
         TITLE 'XITMAP - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN-ABDPL(,R1)  STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA-ABDPL(,R1) GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         EJECT
         MACRO
&SYM     GDUMP &REG,&PLACE,&FILL=' ',&STG=DOUBLE
         AIF   ('&REG' EQ '*').NOSTORE
&SYM     ST    &REG,&STG               REGISTER CONTENTS TO BE DUMPED
         AGO   .AFT
.NOSTORE ANOP
&SYM     DS    0H                      CONTENTS OF STORAGE TO BE DUMPED
.AFT     ANOP
         UNPK  &PLACE.(9),&STG.(5)
         TR    &PLACE.(8),HEXTBL
         MVI   &PLACE.+8,C&FILL
         MEND
         TITLE 'XITMAP - IPCS TCB EXIT TO MAP RB CONTROL BLOCKS'
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    TCB POINTER
R4       EQU   4    ABDPL ADDRESS
R5       EQU   5    LLS POINTER
R6       EQU   6    RB POINTER
R7       EQU   7    CDE POINTER
R8       EQU   8    DEB POINTER
R9       EQU   9    DCB POINTER
R10      EQU   10   JPQ POINTER
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XITMAP   CSECT
         SAVE  (14,12),,XITMAP-&SYSDATE-&SYSTIME
         LR    R12,R15
         USING XITMAP,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ADDRESS OF ABDPL
         USING ABDPL,R4
         L     R11,ADPLBUF         ESTABLISH ADDRESSABILITY TO
         USING LINEDSCT,R11            OUTPUT BUFFER
         XC    WHRADDR,WHRADDR
         XC    FIRSTTCB,FIRSTTCB
         EJECT
         L     R3,ADPLTCB          GET TCB PASSED FOR TCB EXIT
         LTR   R3,R3               IF TCB ADDRESS IS ZERO
         BZ    SCANTREE            THEN SCAN TCB TREE FOR ALL TASKS,
         BAL   R14,PROCESS         ELSE JUST PROCESS THIS ONE
         B     RETURN0             AND RETURN.
         SPACE 1
SCANTREE DS    0H                  PROCESS ALL TCB'S...
*
*
* Instead of using the low-core pointer to get to the TCB,
* use the ASID to locate the ASCB (via the ASVT) and get the
* first TCB from there.  In that way, setting the ASID via
* SETDEF will affect which address space gets mapped.
*
*        LA    R3,X'21C'           ADDRESS OF CVTTCBP
*        GSTOR R3,4,ERRET=BAD21C   GET PSATOLD FROM DUMP
*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB
*        LTR   R3,R3               IF POINTER AT 21C IS ZEROES,
*        BNZ   FINDTOP             THEN...
*        MVI   LINE,C' '
*        MVC   LINE+1(L'LINE-1),LINE
*        MVC   LINE(L'TRY218),TRY218
*        BAL   R14,OUTPUT
*        LA    R3,X'218'
*        GSTOR R3,4,ERRET=BAD218   GET PSATNEW FROM DUMP
*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB
*        LTR   R3,R3               IF POINTER AT 218 IS ZEROES,
*        BNZ   FINDTOP             THEN...
*        MVI   LINE,C' '
*        MVC   LINE+1(L'LINE-1),LINE
*        MVC   LINE(L'TRY224),TRY224
*        BAL   R14,OUTPUT
*
* Try to get ASCB.  Instead of relying on the low-core pointer,
* use the ASID to locate it via the ASVT.  In that way, setting
* the ASID with SETDEF will cause this exit to pick up the right one.
*
*----------------------------------------------------------------------
*        LA    R3,X'224'            TRY VIA ASCB
*        GSTOR R3,4,ERRET=BAD224   GET PSA'S ASCB PTR FROM DUMP
*        L     R3,0(,R3)           ADDRESS OF CURRENT ASCB
*        GSTOR R3,X'70',ERRET=BADASCB   GET CURRENT ASCB FROM DUMP
*----------------------------------------------------------------------
         L     R3,ADPLCVT          Get CVT pointer
         LA    R3,X'22C'(,R3)      CVT+22C -> ASVT
         GSTOR R3,4,ERRET=BADCVT   Get loc of CVT's ASVT ptr from dump
         L     R3,0(,R3)           Load address of CVT's ASVT pointer
         LH    R2,ADPLASID         Get the current ASID
         SLA   R2,2                Multiply by 4 making index into ASVT
         LA    R3,X'20C'(R2,R3)    Point to ASCB address for this ASID
         GSTOR R3,4,ERRET=BADASVT  Get ASCB address from dump
         L     R3,0(,R3)           Load the ASCB address
         GSTOR R3,X'70',ERRET=BADASCB   Get the ASCB from dump
         L     R3,X'6C'(,R3)       GET POINTER TO ASXB
         GSTOR R3,8,ERRET=BADASXB  GET ASXB FROM DUMP
         L     R3,4(,R3)           GET 1ST TCB ADDRESS FROM ASXB
         ST    R3,FIRSTTCB         Save for future module findings
FINDTOP  DS    0H                  SCAN FOR TOP TCB
         LR    R2,R3               SAVE ACTUAL TCB ADDRESS
         GSTOR R3,X'8C',ERRET=BADTCB GET CURRENT TCB FROM DUMP
         ICM   R15,15,X'84'(R3)    ADDRESS OF MOTHER TCB
         BZ    USETCB              IF NONE, THIS IS THE TOP TCB
         LR    R3,R15              IF THERE IS A MOTHER,
         B     FINDTOP             THEN GO FIND ITS MOTHER OR USE IT
USETCB   DS    0H                  START WITH THIS TCB
         LR    R3,R2               GET ACTUAL TCB ADDRESS AGAIN
         SPACE 1
*******                            (WE DON'T DO THIS ANY MORE)
*******  L     R3,X'7C'(,R3)       GET POINTER TO TCBJSTCB
*******
*
         BAL   R14,OUTPUT          Print a blank line
         MVC   LINE(L'HIMSG),HIMSG
         LH    R2,ADPLASID
         GDUMP R2,LINE+L'HIMSG     FORMAT AND PRINT ASID
         BAL   R14,OUTPUT          PRINT "HI THERE" MESSAGE
         BAL   R14,OUTPUT          Print a blank line
*
DOIT     DS    0H
         BAL   R14,PROCESS
         ICM   R3,15,COPYTCB+X'88' DAUGHTER TCB
         BNZ   DOIT
NODTR    DS    0H                  ELSE
         ICM   R3,15,COPYTCB+X'80' SISTER TCB
         BNZ   DOIT
NOSISTER DS    0H                  ELSE
         ICM   R3,15,COPYTCB+X'84' MOTHER TCB
         BZ    NOMORE              IF NONE, FINISHED WITH TCB TREE
         GSTOR R3,X'8C',ERRET=BADTCB ELSE GET MOTHER TCB FROM DUMP
         MVC   COPYTCB(X'8C'),0(R3) SAVE TCB STORAGE
         B     NODTR               PROCESS ITS SISTER, ETC.
NOMORE   DS    0H
         B     RETURN0
         EJECT
PROCESS  DS    0H                  R3 = ADDRESS OF TCB BEING PROCESSED
         SPACE
         ST    R14,PRCSSAVE        SAVE RETURN REGISTER
         BAL   R14,OUTPUT          PRINT A BLANK LINE
         MVC   LINE(L'TCBMSG),TCBMSG
         GDUMP R3,LINE+L'TCBMSG    FORMAT AND PRINT TCB ADDRESS
         BAL   R14,OUTPUT          PRINT "PROCESSING TCB"
         GSTOR R3,256,ERRET=BADTCB GET TCB ITSELF FROM DUMP
         MVC   COPYTCB(256),0(R3)  SAVE TCB STORAGE FOR FUTURE USE
         ICM   R6,15,COPYTCB+X'10' PICK UP COMPLETION CODE
         BZ    NOTCBCMP            IF THERE IS ONE, THEN...
         MVC   LINE(L'CMPMSG),CMPMSG
         GDUMP R6,LINE+L'CMPMSG               FORMAT IT AND PRINT IT
         MVC   LINE+L'CMPMSG+9(L'RTM2MSG),RTM2MSG
         ICM   R6,15,COPYTCB+X'E0'            PICK UP ADDRESS OF RTM2WA
         GDUMP R6,LINE+L'CMPMSG+9+L'RTM2MSG   FORMAT IT AND PRINT IT
         BAL   R14,OUTPUT          PRINT COMPLETION CODE
NOTCBCMP DS    0H
         L     R6,COPYTCB+0        ADDRESS OF RB
         MVC   LINE(L'RBMSG),RBMSG
         GDUMP R6,LINE+L'RBMSG     FORMAT AND PRINT RB ADDRESS
         BAL   R14,OUTPUT          PRINT "PROCESSING RB"
RBLOOP   DS    0H
         LR    R2,R6               SAVE TRUE RB ADDRESS
         SH    R6,=H'32'           POINT TO RB PREFIX
         BM    BADRB               IF IT MAKES IT GO NEGATIVE, BAD ADDR
         GSTOR R6,96,ERRET=BADRB   GET RB FROM DUMP
         MVC   RBPREFIX(96),0(R6)  MAKE A COPY OF IT
         GDUMP R2,LINE+0           FORMAT AND PRINT RB ADDRESS
         TM    COPYRB+X'0A',X'C0'  CHECK RB TYPE
         BZ    PRB
         BO    SVRB
         LA    R1,=CL8'(IRB)'
         B     RBTYPE
SVRB     LA    R1,=CL8'(SVRB)'
RBTYPE   DS    0H
         MVC   LINE+10(8),0(R1)    MOVE RB TYPE
         B     RBOUT
PRB      DS    0H
         XR    R7,R7
         ICM   R7,7,COPYRB+X'0D'   ADDRESS OF RBCDE
         BNZ   GOTACDE             IF ZERO, THEN...
         TM    COPYRB+X'0C',X'04'   IF REQUESTED BY SYNCH MACRO
         BZ    NOCDE                 THEN
         MVC   LINE+10(8),=CL8'(SYNCH)'   SAY SO
         B     RBOUT                 ELSE
NOCDE    MVC   LINE+10(8),=CL8'(NO CDE)'  JUST SAY NO CDE
         B     RBOUT
GOTACDE  DS    0H
         MVC   LINE+10(8),=CL8'(*N/A*)' IN CASE CDE NOT AVAILABLE
         GSTOR R7,32,ERRET=RBOUT   GET CDE FROM DUMP
         MVC   LINE+10(8),CDNAME-CDENTRY(R7) CDE NAME
RBOUT    DS    0H
         MVC   LINE+21(4),=C'INT='
         UNPK  LINE+25(3),COPYRB-1(2) INTERRUPT CODE
         TR    LINE+25(2),HEXTBL
         MVI   LINE+27,C' '
         MVC   LINE+29(4),=C'PSW='
         UNPK  LINE+33(9),COPYRB+X'10'(5) LEFT HALF OF RBOPSW
         TR    LINE+33(8),HEXTBL
         MVI   LINE+41,C' '
         UNPK  LINE+42(9),COPYRB+X'14'(5) RIGHT HALF OF RBOPSW
         TR    LINE+42(8),HEXTBL
         MVI   LINE+50,C' '
         L     R0,COPYRB+X'14'     GET RIGHT HALF OF PSW
         BAL   R14,FINDMOD         LOCATE MODULE WHERE IT IS
         BAL   R14,OUTPUT          PRINT CDE NAME TO IDENTIFY RB
RBNEXT   DS    0H
         TM    COPYRB+X'0B',X'80'  IF NEXTRB POINTS TO TCB
         BO    ENDRB               THEN NO MORE RB'S. ELSE
         XR    R6,R6
         ICM   R6,7,COPYRB+X'1D'   ADDRESS OF NEXT RB
         B     RBLOOP
BADRB    DS    0H                  RB STORAGE NOT AVAILABLE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'RBERRMSG),RBERRMSG
         GDUMP R6,LINE+L'RBERRMSG  FORMAT AND PRINT ADDRESS OF RB
         BAL   R14,OUTPUT
ENDRB    DS    0H
         ICM   R10,15,COPYTCB+X'2C' ADDRESS OF JOB PACK QUEUE
         BZ    ENDCDE
         MVC   LINE(L'JPQMSG),JPQMSG
         BAL   R14,OUTPUT          PRINT "MAPPING JOB PACK QUEUE"
CDELOOP  DS    0H
         BAL   R14,DUMPCDE         WRITE OUT CDE INFO
         ICM   R10,15,0(R10)
         BNZ   CDELOOP
ENDCDE   DS    0H
TCB2LOOP DS    0H
         ICM   R5,15,COPYTCB+X'24' ADDRESS OF LOAD LIST ELEMENTS
         BZ    ENDLLS
         MVC   LINE(L'LLSMSG),LLSMSG
         BAL   R14,OUTPUT          PRINT "MAPPING LOAD LIST"
LLSLOOP  DS    0H
         GSTOR R5,16,ERRET=BADLLS  GET LLS FROM DUMP
         L     R2,0(,R5)           SAVE ADDRESS OF NEXT LLS
         L     R10,4(,R5)          CDE FOR LOAD LIST ENTRY
         BAL   R14,DUMPCDE         WRITE OUT CDE INFO
NEXTLLS  DS    0H
         LTR   R5,R2               GET ADDRESS OF NEXT LLS
         BZ    ENDLLS
         B     LLSLOOP
BADLLS   DS    0H                  ERROR ACCESSING LLS
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'LLSERMSG),LLSERMSG
         GDUMP R5,LINE+L'LLSERMSG
         BAL   R14,OUTPUT
         SPACE 1
ENDLLS   DS    0H
         ICM   R8,15,COPYTCB+X'08' ADDRESS OF DEB
         BNZ   GOTDEBS
         MVC   LINE(L'NODEBS),NODEBS
         BAL   R14,OUTPUT          PRINT "NO OPEN DATA SETS"
         B     ENDDEB
GOTDEBS  DS    0H
         MVC   LINE(L'DEBMSG),DEBMSG
         GDUMP R8,LINE+L'DEBMSG    FORMAT AND PRINT ADDRESS OF DEB
         BAL   R14,OUTPUT          PRINT "MAPPING DEB CHAIN"
DEBLOOP  DS    0H
         MVC   LINE(4),=C'DEB='
         GDUMP R8,LINE+4           FORMAT AND PRINT ADDRESS OF DEB
         GSTOR R8,32,ERRET=BADDEB  GET DEB FROM DUMP
         MVC   COPYDEB(32),0(R8)   MAKE A COPY OF IT
         L     R9,COPYDEB+X'18'    ADDRESS OF DCB FOR THIS DEB
         N     R9,=X'00FFFFFF'     CLEAR HIGH ORDER BYTE
         MVC   LINE+14(4),=C'DCB='
         GDUMP R9,LINE+18          FORMAT AND PRINT ADDRESS OF DCB
         GSTOR R9,X'30',ERRET=BADDCB GET DCB FROM DUMP
         L     R2,COPYTCB+X'0C'    ADDRESS OF TIOT
         AH    R2,X'28'(,R9)       ADD TIOT OFFSET FROM DCB
         GSTOR R2,20,ERRET=BADTIOT GET TIOT ENTRY FROM DUMP
         MVC   LINE+28(8),4(R2)    DDNAME FROM TIOT
         MVI   LINE+36,C' '
         ICM   R9,7,X'C'(R2)       POINTER TO JFCB FROM TIOT
         LA    R9,X'10'(,R9)       ADDRESS OF JFCB
         GSTOR R9,176,ERRET=BADJFCB GET JFCB FROM DUMP
         MVC   LINE+37(44),0(R9)   DSNAME
         LA    R1,LINE+37+44-1
DSNLOOP  CLI   0(R1),C' '
         BNE   DSNEND
         BCTR  R1,0
         B     DSNLOOP
DSNEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN DSNAME
         CLI   44(R9),C' '         IF THERE IS A MEMBER NAME IN JFCB
         BE    NOMEMBER            THEN
         MVI   1(R1),C'('
         MVC   2(8,R1),44(R9)
         LA    R1,9(,R1)
MEMLOOP  CLI   0(R1),C' '
         BNE   MEMEND
         BCTR  R1,0
         B     MEMLOOP
MEMEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN MEMBER
         LA    R1,1(,R1)
         MVI   0(R1),C')'
NOMEMBER DS    0H                  R1 POINTS TO LAST NONBLANK
         TM    COPYDEB+X'08',X'01' IF CONCATENATED DATA SETS,
         BZ    PRINTDEB            THEN...
         MVC   2(7,R1),=C' ET AL.'  LET ME KNOW
         B     PRINTDEB
BADDCB   DS    0H                  ERROR ACCESSING DCB
         MVC   LINE+14(L'DCBERMSG),DCBERMSG
         GDUMP R9,LINE+14+L'DCBERMSG
         B     PRINTDEB
BADTIOT  DS    0H                  ERROR ACCESSING DCB
         MVC   LINE+28(L'TIOERMSG),TIOERMSG
         GDUMP R2,LINE+28+L'TIOERMSG
         B     PRINTDEB
BADJFCB  DS    0H                  ERROR ACCESSING DCB
         MVC   LINE+37(L'JFERRMSG),JFERRMSG
         GDUMP R9,LINE+37+L'JFERRMSG
         B     PRINTDEB
PRINTDEB DS    0H
         BAL   R14,OUTPUT          PRINT DEB=ADDR DCB=ADDR DDNAME
         B     NEXTDEB             GO TO NEXT DEB
BADOTHER DS    0H                  ERROR ACCESSING STORAGE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ERRMSG),ERRMSG
         BAL   R14,OUTPUT
******** B     NEXTDEB
NEXTDEB  DS    0H
         XR    R8,R8
         ICM   R8,7,COPYDEB+5      ADDRESS OF NEXT DEB
         BZ    ENDDEB
         B     DEBLOOP
BADDEB   DS    0H                  ERROR ACCESSING DEB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'DEBERMSG),DEBERMSG
         GDUMP R8,LINE+L'DEBERMSG
         BAL   R14,OUTPUT
ENDDEB   DS    0H
ENDPROC  DS    0H
         L     R14,PRCSSAVE        RETURN
         BR    R14
         EJECT
DUMPCDE  DS    0H                  THIS ROUTINE DUMPS A CDE
*
* THIS SUBROUTINE FORMATS AND WRITES OUT CDE INFORMATION,
* ON ENTRY R10 CONTAINS THE ADDRESS OF THE CDE.
*
         SPACE 1
         ST    R14,DCDESAVE        SAVE RETURN REGISTER
         ST    R10,DOUBLE          CDE ADDRESS
         GSTOR R10,32,ERRET=BADCDE GET CDE FROM DUMP
         USING CDENTRY,R10
         GDUMP *,LNCDADDR          FORMAT AND PRINT ADDRESS OF CDE
         MVC   LNCDNAME(8),CDNAME   CDE NAME
         MVC   LNCDEPEQ(3),=C'EP='
         GDUMP *,LNCDEPA,STG=CDENTPT ENTRY POINT FROM CDE
         TM    CDATTR,CDREN
         BZ    NOTRENT
         MVC   LNCDRENT,=C'RENT'
NOTRENT  TM    CDATTR,CDSER
         BZ    NOTREUS
         MVC   LNCDREUS,=C'REUS'
NOTREUS  TM    CDATTR2,CDEANYM
         BZ    NOTANY
         MVC   LNCDANY,=C'ANY'
NOTANY   TM    CDATTR2,CDOLY
         BZ    NOTOVLY
         MVC   LNCDOVLY,=C'OVLY'
NOTOVLY  TM    CDATTR2,CDSYSLIB
         BZ    NOTSYSL
         MVC   LNCDSYSL,=C'SYSLIB'
NOTSYSL  TM    CDATTR2,CDAUTH
         BZ    NOTAUTH
         MVC   LNCDAUTH,=C'AUTH'
NOTAUTH  DS    0H
         B     OUTCDE
BADCDE   DS    0H                  CDE STORAGE NOT AVAILABLE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'CDERRMSG),CDERRMSG
         GDUMP R10,LINE+L'CDERRMSG FORMAT AND PRINT CDE ADDRESS
OUTCDE   BAL   R14,OUTPUT          PRINT CDE MODULE NAME
         L     R14,DCDESAVE        RESTORE RETURN REGISTER
         BR    R14                 RETURN
         EJECT
BAD21C   DS    0H                  ERROR ACCESSING TCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ER21CMSG),ER21CMSG
         GDUMP R3,LINE+L'ER21CMSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BAD218   DS    0H                  ERROR ACCESSING TCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ER218MSG),ER218MSG
         GDUMP R3,LINE+L'ER218MSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BAD224   DS    0H                  ERROR ACCESSING ASCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ER224MSG),ER224MSG
         GDUMP R3,LINE+L'ER224MSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BADTCB   DS    0H                  ERROR ACCESSING TCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'TCBERMSG),TCBERMSG
         GDUMP R3,LINE+L'TCBERMSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BADASCB  DS    0H                  ERROR ACCESSING ASCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ASCBEMSG),ASCBEMSG
         GDUMP R3,LINE+L'ASCBEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BADASXB  DS    0H                  ERROR ACCESSING ASXB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ASXBEMSG),ASXBEMSG
         GDUMP R3,LINE+L'ASXBEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BADCVT   DS    0H
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'CVTEMSG),CVTEMSG
         GDUMP R3,LINE+L'CVTEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BADCASVT DS    0H
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'CASVEMSG),CASVEMSG
         GDUMP R3,LINE+L'CASVEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BADASVT  DS    0H
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ASVTEMSG),ASVTEMSG
         GDUMP R3,LINE+L'ASVTEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
         EJECT
STORERR  DS    0H                  ERROR ACCESSING STORAGE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ERRMSG),ERRMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
FINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME
*                                  R0 CONTAINS ADDRESS TO SEARCH ON
         ST    R14,FMSAVE
         LTR   R0,R0               IF AMODE 31 BIT IS NOT ON
         BM    FMASIS              THEN
         N     R0,=X'00FFFFFF'      CLEAR HIGH-ORDER BYTE FOR 24-BIT AD
FMASIS   DS    0H
         ICM   R15,15,WHRADDR
         BNZ   FMGOTWHR
         ST    R0,FMWORK
         LOAD  EPLOC==CL8'XIPSWHR',ERRET=FMNF
         ST    R0,WHRADDR
         LR    R15,R0
         L     R0,FMWORK
FMGOTWHR DS    0H
         L     R14,FIRSTTCB
         ST    R14,ADPLCOM1        Get first TCB address for XIPSWHR
         LR    R1,R4               POINT TO ABDPL
         BASSM R14,R15             CALL XIPSWHR TO GET MODULE NAME
         CLI   ADPLFMT1,C' '       IF NOT FOUND...
         BE    FMNF
         CLI   ADPLFMT1,C'E'       IF STORAGE ERROR...
         BE    FMERR
         MVC   LINE+52(16),ADPLCOM1
         B     FMRET
FMERR    DS    0H
         MVC   LINE+52(16),=CL16'(STORAGE ERROR) '
         B     FMRET
FMNF     DS    0H
         MVC   LINE+52(16),=CL16'(UNKNOWN)       '
FMRET    DS    0H
         L     R14,FMSAVE
         BR    R14
         EJECT
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT-ABDPL(,R1) GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15                 CALL IT
         LTR   R15,R15
         BNZ   RETURN0
         L     R11,ADPLBUF-ABDPL(,R1)  POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         ICM   R15,R15,WHRADDR
         BZ    NODELETE
         DELETE EPLOC==CL8'XIPSWHR'
NODELETE DS    0H
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
HIMSG    DC    C'                 MAP FOR ASID '
TCBMSG   DC    C'*** P R O C E S S I N G   T C B *** - '
CMPMSG   DC    C'*** COMPCODE='
RTM2MSG  DC    C' RTM2 AT '
RBMSG    DC    C'---MAPPING RBS - '
JPQMSG   DC    C'---MAPPING CDES FROM JOB PACK QUEUE'
LLSMSG   DC    C'---MAPPING CDES FROM LOAD LIST'
NODEBS   DC    C'---TASK HAS NO OPEN DATA SETS'
DEBMSG   DC    C'---MAPPING DEBS - '
TRY218   DC    C'PSATOLD TCB POINTER IS ZEROES, USING PSATNEW POINTER'
TRY224   DC    C'PSATNEW TCB POINTER IS ZEROES, USING ASXB POINTER'
ERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'
ER21CMSG DC    C'ERROR - PSATOLD UNAVAILABLE'
ER218MSG DC    C'ERROR - PSATNEW UNAVAILABLE'
ER224MSG DC    C'ERROR - ASCB UNAVAILABLE'
TCBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR TCB AT '
ASCBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASCB AT '
ASXBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASXB AT '
RBERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR RB AT '
CDERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR CDE AT '
LLSERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR LLS AT '
DEBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR DEB AT '
DCBERMSG DC    C'DCB UNAVAILABLE AT '
TIOERMSG DC    C'TIOT ENTRY UNAVAILABLE AT '
JFERRMSG DC    C'JFCB UNAVAILABLE AT '
CVTEMSG  DC    C'CVT ASVT POINTER UNAVAILABLE AT '
CASVEMSG DC    C'ASVT ADDRESS UNAVAILABLE AT '
ASVTEMSG DC    C'ASVT ASCB POINTER UNAVAILABLE AT '
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ...........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D
PRCSSAVE DS    A                   SAVE AREA FOR PROCESS SUBROUTINE
DCDESAVE DS    A                   SAVE AREA FOR DUMPCDE SUBROUTINE
OUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE
FMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE
FMWORK   DS    A                   WORK AREA FOR FINDMOD SUBROUTINE
WHRADDR  DS    A                   ADDRESS OF XIPSWHR LOAD MODULE
FIRSTTCB DS    A                   First TCB address
         SPACE 1
COPYTCB  DS    CL256               COPY OF MOST OF TCB
COPYDEB  DS    CL32                COPY OF MOST OF DEB
RBPREFIX DS    CL32                COPY OF RB PREFIX
COPYRB   DS    CL64                COPY OF MOST OF RB
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINEDSCT DSECT ,                   MAP THE OUTPUT BUFFER
LINE     DS    CL132               WORD AREA FOR OUTPUT LINES
         ORG   LINE
LNCDADDR DS    CL8                 ADDRESS OF CONTROL BLOCK
         DS    CL2
LNCDNAME DS    CL8                 NAME
         DS    CL3
LNCDEPEQ DS    C'EP='              "EP="
LNCDEPA  DS    CL8                 ENTRY POINT
         DS    CL3                 FOLLOWED BY ATTRIBUTES
LNCDRENT DS    C'RENT'
         DS    CL1
LNCDREUS DS    C'REUS'
         DS    CL1
LNCDANY  DS    C'ANY'
         DS    CL1
LNCDOVLY DS    C'OVLY'
         DS    CL1
LNCDSYSL DS    C'SYSLIB'
         DS    CL1
LNCDAUTH DS    C'AUTH'
         DS    CL1
         ORG
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         BLSABDPL
         SPACE 1
         IHACDE
         SPACE 1
         END
./ ADD NAME=XITSAV
         TITLE 'XITSAV - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   ('&LENGTH' EQ '(0)').GOTLEN
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'XITSAV - IPCS TCB EXIT TO DISPLAY SAVE AREA TRACE'
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3    DUMP STORAGE ACCESS REGISTER
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    ADDRESS OF OPERAND
R6       EQU   6    LENGTH OF OPERAND
R7       EQU   7    ADDRESS OF PREVIOUS SAVE AREA (COMPARE WITH HSA)
R8       EQU   8    TRUE ADDRESS OF CURRENT SAVE AREA
R9       EQU   9    ADDRESS OF DATA WHERE SAVEAREA'S R15 POINTS
R10      EQU   10   POINTER TO PARAMETER LIST EXTENSION
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XITSAV   CSECT
         SAVE  (14,12),,XITSAV_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XITSAV,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ADDRESS OF ABDPL
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO
         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION
         EJECT
PROCESS  DS    0H
         SPACE 1
         LOAD  EP=XIPSWHR          LOAD ADDRESS SEARCH ROUTINE
         ST    R0,WHRADDR
         SPACE 1
         L     R3,ADPLTCB          R3 = ADDRESS OF TCB
         USING TCB,R3
         XR    R7,R7               INITIALIZE HSA POINTER
         LA    R3,TCBFSA           POINTER TO ADDRESS OF FIRST SAVEAREA
         GSTOR R3,4                GET TCBFSA FROM DUMP
         ICM   R3,15,0(R3)         ADDRESS OF FIRST SAVE AREA
         BNZ   LOOP                IF NONE, THEN...
         MVC   LINE(L'NOSAMSG),NOSAMSG SAY SO
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 1
LOOP     DS    0H
         LTR   R3,R3               UNTIL NO MORE
         BZ    ENDLOOP
         MVC   LINE(L'SAMSG),SAMSG "SAVE AREA AT "
         LR    R8,R3               TRUE ADDRESS OF THIS SAVE AREA
         ST    R8,OPWORK           DISPLAY IT
         UNPK  LINESAA+0(9),OPWORK(5)
         TR    LINESAA+0(8),HEXTBL
         MVI   LINESAA+8,C'.'
         GSTOR R3,72,ERRET=SANA    GET SAVE AREA FROM DUMP
         MVC   COPYSA(72),0(R3)    COPY INTO OUR WORK AREA
CONTLOOP DS    0H
         SPACE
         MVC   LINEL1(4),=C'WD1='
         UNPK  LINEN1(9),SAWD1(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'HSA='
         UNPK  LINEN2(9),SAHSA(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'LSA='
         UNPK  LINEN3(9),SALSA(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         BAL   R14,OUTPUT
         C     R7,SAHSA            CHECK HSA POINTER
         BE    HSAOK               IF IT DOESN'T MATCH, THEN...
         MVC   LINEL1(L'IBCMSG),IBCMSG
         BAL   R14,OUTPUT          NOTE INVALID BACK CHAIN
HSAOK    DS    0H
         LR    R7,R8               SET PREVIOUS-SAVE-AREA ADDRESS
         MVC   LINEL1(4),=C'R14='
         UNPK  LINEN1(9),SAR14(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         L     R0,SAR14
         BAL   R14,FINDMOD         RESOLVE RETURN ADDRESS
         BAL   R14,OUTPUT
         MVC   LINEL1(4),=C'R15='
         UNPK  LINEN1(9),SAR15(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         L     R0,SAR15
         BAL   R14,FINDMOD         RESOLVE ENTRY ADDRESS
         SPACE 1
         L     R9,FMWHERE          ADDRESS THAT HAS BEEN RESOLVED
         LTR   R9,R9               IF ZERO, IGNORE IT
         BZ    NOEP
         GSTOR R9,8,ERRET=NOEP     TRY TO GET ENTRY POINT DATA
         ICM   R0,15,0(R9)         GET ENTRY POINT INSTRUCTION
         N     R0,=X'FFFFF000'     AND OUT THE DISPLACEMENT
         CL    R0,=X'47F0F000'     IF IT IS NOT A BRANCH-AROUND
         BNE   NOEP                THEN NO EP DATA
         XR    R2,R2               CLEAR INSERT REG
         IC    R2,4(,R9)           GET LENGTH OF IDENTIFIER
         LTR   R2,R2               IF ZERO
         BZ    NOEP                THEN NO EP DATA
         CH    R2,=Y(EPLENGTH)     SET MAXIMUM LENGTH THAT WE CAN SHOW
         BNH   SETMAX
         LA    R2,EPLENGTH
SETMAX   DS    0H
         LA    R9,4
         A     R9,FMWHERE          POINT TO IDENTIFIER STUFF
         LA    R0,1+3(,R2)         SET LENGTH+1 AND PREPARE TO...
         N     R0,=X'FFFFFFFC'     ....ROUND UP TO FULLWORD BOUNDARY
         GSTOR R9,(0),ERRET=NOEP   GET DATA FOR THE LENGTH NEEDED
         MVC   LINEEP1(6),=CL6'AT EP '
         BCTR  R2,0                REDUCE LENGTH FOR EXECUTE
         EX    R2,EPMVC            TRANSLATE EP DATA
NOEP     DS    0H
         SPACE 1
         BAL   R14,OUTPUT
         MVC   LINEL1(4),=C'R0 ='
         UNPK  LINEN1(9),SAR00(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         BAL   R14,OUTPUT
         MVC   LINEL1(4),=C'R1 ='
         UNPK  LINEN1(9),SAR01(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'R2 ='
         UNPK  LINEN2(9),SAR02(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'R3 ='
         UNPK  LINEN3(9),SAR03(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         MVC   LINEL4(4),=C'R4 ='
         UNPK  LINEN4(9),SAR04(5)
         TR    LINEN4(8),HEXTBL
         MVI   LINEB4,C' '
         BAL   R14,OUTPUT
         SPACE
         MVC   LINEL1(4),=C'R5 ='
         UNPK  LINEN1(9),SAR05(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'R6 ='
         UNPK  LINEN2(9),SAR06(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'R7 ='
         UNPK  LINEN3(9),SAR07(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         MVC   LINEL4(4),=C'R8 ='
         UNPK  LINEN4(9),SAR08(5)
         TR    LINEN4(8),HEXTBL
         MVI   LINEB4,C' '
         BAL   R14,OUTPUT
         SPACE
         MVC   LINEL1(4),=C'R9 ='
         UNPK  LINEN1(9),SAR09(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'R10='
         UNPK  LINEN2(9),SAR10(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'R11='
         UNPK  LINEN3(9),SAR11(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         MVC   LINEL4(4),=C'R12='
         UNPK  LINEN4(9),SAR12(5)
         TR    LINEN4(8),HEXTBL
         MVI   LINEB4,C' '
         BAL   R14,OUTPUT
         SPACE
         BAL   R14,OUTPUT          JUST A BLANK LINE
         SPACE
         L     R3,SALSA            GET ADDRESS OF NEXT SAVE AREA
         B     LOOP                CONTINUE LOOPING
         SPACE 1
SANA     DS    0H                  SAVE AREA NOT AVAILABLE FROM DUMP
         SPACE 1
         MVC   LINE+L'SAMSG+08+2(L'SANAMSG),SANAMSG
         BAL   R14,OUTPUT
         B     ERROUT
         SPACE 1
ENDLOOP  DS    0H
         B     RETURN0
         SPACE 2
EPMVC    MVC   LINEEP2(0),1(R9)    EXECUTED
         EJECT
STORERR  DS    0H                  ERROR ACCESSING STORAGE
         MVC   LINE(L'ERRMSG),ERRMSG
******** B     ERROUT
         SPACE 1
ERROUT   DS    0H
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
FINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME
*                                  R0 CONTAINS ADDRESS TO SEARCH ON
         ST    R0,FMWHERE          STORE ADDRESS TO BE RESOLVED
         LTR   R0,R0               IF ADDRESS IS ZEROES,
         BZR   R14                 THEN PRINT NOTHING, NOT AN EP
         ST    R14,FMSAVE
         NI    FMWHERE,B'01111111' TURN OFF HIGH-ORDER BIT FOR ADDRESS
FMDOIT   DS    0H
         XR    R0,R0
         ST    R0,ADPLCOM1
         L     R0,FMWHERE
         LR    R1,R4
         L     R15,WHRADDR
         BALR  R14,R15
         CLI   ADPLFMT1,C' '
         BE    FMNF
         MVC   LINEMOD(16),ADPLCOM1
         B     FMRET
FMNF     DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* IF ADDRESS UNKNOWN, MAYBE THE HIGH-ORDER BYTE IS CONFUSING THE      *
* ADDRESS SEARCH ROUTINE.  SO WE SET IT TO ZEROES AND TRY AGAIN.      *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   FMWHERE,X'00'       IF IT'S ALREADY A 24-BIT ADDRESS
         BE    FMFAIL              THEN DON'T TRY AGAIN
         MVI   FMWHERE,X'00'       ELSE CHANGE IT TO A 24-BIT ADDRESS
         B     FMDOIT               TRY AGAIN WITH 0 IN H.O.BYTE
FMFAIL   DS    0H                  ELSE GIVE UP
         MVC   LINEMOD(16),=CL16'(UNKNOWN)       '
         XC    FMWHERE,FMWHERE
FMRET    DS    0H
         L     R14,FMSAVE
         BR    R14
         EJECT
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15             CALL IT
         LTR   R15,R15             IF LINE NOT PRINTED
         BNZ   RETURN0             THEN...
NORETYET DS    0H
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         DELETE EP=XIPSWHR
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
ERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'
NOSAMSG  DC    C'NO SAVE AREA CHAIN FOR THIS TCB'
IBCMSG   DC    C'*** INVALID BACK CHAIN ***'
SANAMSG  DC    C'STORAGE UNAVAILABLE'
SAMSG    DC    C'SAVE AREA AT '
         SPACE
VALTBL   DC    256YL1(1)
         ORG   VALTBL+X'81'
         DC    6YL1(0)             LOWER CASE ABCDEF
         ORG   VALTBL+C'A'
         DC    6YL1(0)             UPPER CASE ABCDEF
         ORG   VALTBL+C'0'
         DC    10YL1(0)            0123456789
         ORG
         SPACE
FTBL     DC    256YL1(*-FTBL)
         ORG   FTBL+X'81'
         DC    X'FAFBFCFDFEFF'     LOWER CASE ABCDEF
         ORG   FTBL+C'A'
         DC    X'FAFBFCFDFEFF'     UPPER CASE ABCDEF
         ORG
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ...........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
OUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE
FMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE
FMWHERE  DS    A                   ADDRESS PASSED TO FINDMOD SUBROUTINE
WHRADDR  DS    A                   ADDRESS OF XIPSWHR, SEARCH ROUTINE
         DS    XL1                 PADDING FOR CONVERSION
OPWORK   DS    0F,CL9              WORK AREA FOR OPERAND CONVERSION
COPYSA   DS    18F                 WORK AREA FOR SAVE AREA
         ORG   COPYSA
SAWD1    DS    F                   00 = FIRST WORD
SAHSA    DS    F                   04 = HSA
SALSA    DS    F                   08 = LSA
SAR14    DS    F                   0C = REG14
SAR15    DS    F                   10 = REG15
SAR00    DS    F                   14 = REG0
SAR01    DS    F                   18 = REG1
SAR02    DS    F                   1C = REG2
SAR03    DS    F                   20 = REG3
SAR04    DS    F                   24 = REG4
SAR05    DS    F                   28 = REG5
SAR06    DS    F                   2C = REG6
SAR07    DS    F                   30 = REG7
SAR08    DS    F                   34 = REG8
SAR09    DS    F                   38 = REG9
SAR10    DS    F                   3C = REG10
SAR11    DS    F                   40 = REG11
SAR12    DS    F                   44 = REG12
         ORG
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL133               WORD AREA FOR OUTPUT LINES
         ORG   LINE
         DS    CL(L'SAMSG)         "SAVE AREA AT "
LINESAA  DS    CL8                 ADDRESS OF SAVE AREA
         DS    CL2                 "  "
LINEL1   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN1   DS    CL8                 "NNNNNNNN"
LINEB1   DS    CL1                 " "
LINEL2   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN2   DS    CL8                 "NNNNNNNN"
LINEB2   DS    CL1                 " "
LINEL3   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN3   DS    CL8                 "NNNNNNNN"
LINEB3   DS    CL1                 " "
LINEL4   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN4   DS    CL8                 "NNNNNNNN"
LINEB4   DS    CL1                 " "
LINEL5   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN5   DS    CL8                 "NNNNNNNN"
LINEB5   DS    CL1                 " "
         ORG   LINEL2
         DS    CL1
LINEMOD  DS    CL16                "WHERE" DATA
         DS    CL1
LINEEP1  DS    CL6                 "AT EP "
LINEEP2  DS    CL(EPLENGTH)
         SPACE 1
EPLENGTH EQU   78-(LINEEP2-LINE)
         ORG
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 2
         IKJTCB
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ADD NAME=XITWHR
         TITLE 'XITWHR - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'XITWHR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3    DUMP STORAGE ACCESS REGISTER
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    ADDRESS OF OPERAND
R6       EQU   6    LENGTH OF OPERAND
R7       EQU   7    POINTER TO CDE
R8       EQU   8    USED IN NUCMAP SCANNING
R9       EQU   9    USED IN NUCMAP SCANNING
R10      EQU   10   POINTER TO PARAMETER LIST EXTENSION
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XITWHR   CSECT
         SAVE  (14,12),,XITWHR_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XITWHR,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO
         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION
         EJECT
* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.
* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES
* THE CORRECT ASID, ETC.
         SPACE 1
         XR    R0,R0
         ST    R0,ADPLCOM1         Clear communication word
         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE
         LR    R1,R4               GET ADDRESS OF ABDPL
         SPACE 1
         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE
         SPACE 1
         UNPK  LINE+00(9),ADPLTCB(5)
         TR    LINE+00(8),HEXTBL
         MVI   LINE+08,C'.'
         CLC   ADPLFMT1(4),=C'    '
         BE    NOTFOUND
         CLC   ADPLFMT1(4),=C'JPA '
         BE    INJPA
         CLC   ADPLFMT1(4),=C'PLPA'
         BE    INPLPA
         CLC   ADPLFMT1(4),=C'MLPA'
         BE    INMLPA
         CLC   ADPLFMT1(4),=C'NUC '
         BE    INNUC
         CLC   ADPLFMT1(4),=C'ERR '
         BE    INERROR
         B     INLIMBO
         EJECT
NOTFOUND DS    0H
         SPACE 1
         MVC   LINE+09(L'NFMSG),NFMSG
         B     ERROUT
         EJECT
INERROR  DS    0H
         SPACE 1
         MVC   LINE+09(L'ERMSG),ERMSG
         B     ERROUT
         SPACE 1
STORERR  DS    0H                  ERROR ACCESSING STORAGE
         MVC   LINE(L'ERMSG),ERMSG
ERROUT   DS    0H
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 1
INJPA    DS    0H
         SPACE 1
         MVC   LINE+09(L'JPAMSG),JPAMSG
         MVC   LINE+09+L'JPAMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'JPAMSG+08,C' '
         MVC   LINE+09+L'JPAMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'JPAMSG+10,C' '
         MVC   LINE+09+L'JPAMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INPLPA   DS    0H
         SPACE 1
         MVC   LINE+09(L'PLPAMSG),PLPAMSG
         MVC   LINE+09+L'PLPAMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'PLPAMSG+08,C' '
         MVC   LINE+09+L'PLPAMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'PLPAMSG+10,C' '
         MVC   LINE+09+L'PLPAMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INMLPA   DS    0H
         SPACE 1
         MVC   LINE+09(L'MLPAMSG),MLPAMSG
         MVC   LINE+09+L'MLPAMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'MLPAMSG+08,C' '
         MVC   LINE+09+L'MLPAMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'MLPAMSG+10,C' '
         MVC   LINE+09+L'MLPAMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INNUC    DS    0H
         SPACE 1
         MVC   LINE+09(L'NUCMSG),NUCMSG
         MVC   LINE+09+L'NUCMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'NUCMSG+08,C' '
         MVC   LINE+09+L'NUCMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'NUCMSG+10,C' '
         MVC   LINE+09+L'NUCMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INLIMBO  DS    0H
         SPACE 1
         MVC   LINE+09(L'LIMBOMSG),LIMBOMSG
         MVC   LINE+09+LIMBOFF(4),ADPLFMT1
         MVC   LINE+09+L'LIMBOMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'LIMBOMSG+08,C' '
         MVC   LINE+09+L'LIMBOMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'LIMBOMSG+10,C' '
         MVC   LINE+09+L'LIMBOMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15             CALL IT
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
JPAMSG   DC    C'  FOUND IN JPA MODULE '
PLPAMSG  DC    C'  FOUND IN PLPA MODULE '
MLPAMSG  DC    C'  FOUND IN MLPA MODULE '
NUCMSG   DC    C'  FOUND IN NUCLEUS CSECT '
NFMSG    DC    C'  NOT FOUND IN JPA, LPA OR NUCLEUS'
ERMSG    DC    C'  STORAGE ERROR - UNABLE TO FIND MODULE'
LIMBOMS1 DC    C'  FOUND IN '
LIMBOMS2 DC    CL4'    '
LIMBOMS3 DC    C' MODULE '
LIMBOMSG EQU   LIMBOMS1,*-LIMBOMS1,C'C'
LIMBOFF  EQU   LIMBOMS2-LIMBOMS1
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ...........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
OUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL133               WORD AREA FOR OUTPUT LINES
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 2
         IHACDE
         EJECT
         IHAXTLST
         EJECT
         IHALPDE
         EJECT
         IKJTCB
         EJECT
         CVT   DSECT=YES
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ADD NAME=YITADDR
         TITLE 'YITADDR - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BASSM R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'YITADDR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'
         SPACE 1
***********************************************************************
*                                                                     *
* THIS IS AN IPCS TCB EXIT THAT, GIVEN AN ADDRESS (WHICH IS NOT       *
* REALLY A TCB ADDRESS AFTER ALL), RETURNS THE HEX ADDRESS AS A       *
* CLIST VARIABLE.                                                     *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    ADDRESS OF OPERAND
R6       EQU   6    LENGTH OF OPERAND
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10   POINTER TO PARAMETER LIST EXTENSION
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
YITADDR  CSECT
         SAVE  (14,12),,YITADDR_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING YITADDR,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO
         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION
         EJECT
* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.
* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES
* THE CORRECT ASID, ETC.
         SPACE 1
         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE
         LR    R1,R4               GET ADDRESS OF ABDPL
         MVI   YITHEX,C' '
         MVC   YITHEX+1(L'YITHEX-1),YITHEX
*
* SET YITHEX = THE VALUE
*
         ST    R0,DOUBLE
         UNPK  YITHEX(9),DOUBLE(5)
         TR    YITHEX(8),HEXTBL
         SPACE 1
YITSET   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* OK, NOW INVOKE THE CLIST VARIABLE ACCESS FACILITY TO SET THE        *
* VALUE AS A CLIST VARIABLE.                                          *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R14,CENTRY
         LA    R15,CNAMEA
         LA    R0,CNAMEL
         LA    R1,CVALUEA
         LA    R2,CVALUEL
         LA    R3,CTOKEN
         STM   R14,R3,CPARM1
         L     R1,ADPLCPPL
         USING CPPL,R1
         L     R1,CPPLECT
         DROP  R1
         ST    R1,CPARM7
         OI    CPARM7,X'80'
         LA    R0,TSVEUPDT
         ST    R0,CENTRY
         XR    R0,0
         ST    R0,CNAMEA           ADDRESS OF VARIABLE NAME
         ST    R0,CNAMEL           LENGTH OF VARIABLE NAME
         ST    R0,CVALUEA          ADDRESS OF VARIABLE VALUE
         ST    R0,CVALUEL          LENGTH OF VARIABLE VALUE
*
* SET YITHEX
*
         LA    R14,=C'YITHEX'
         LA    R15,6
         LA    R0,YITHEX
         LA    R1,L'YITHEX
         STM   R14,R1,CNAMEA
         BAL   R2,CALL441
*
* RETURN TO CALLER
*
         B     RETURN0
         SPACE 2
CALL441  DS    0H
         LA    R1,CPARM1           POINT TO PARAMETER LIST
         L     R15,X'10'               GET ADDRESS OF CVT
         L     R15,CVTTVT-CVT(,R15)    GET ADDRESS OF TSO VECTOR TABLE
         L     R15,TSVTVACC-TSVT(,R15) GET ADDRESS OF IKJCT441
         BALR  R14,R15             CALL CLIST VARIABLE ACCESS ROUTINE
         LTR   R15,R15             IF RETURN CODE IS ZERO
         BZR   R2                  THEN EVERYTHING IS OK
         MVC   LINE(L'ERR441),ERR441
         CVD   R15,DOUBLE
         UNPK  LINE+L'ERR441(2),DOUBLE
         OI    LINE+L'ERR441+1,X'F0'
         BAL   R14,OUTPUT
         BR    R2
         SPACE 2
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BASSM R14,R15             CALL IT
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
ERR441   DC    C'YITADDR: CLIST VARIABLE ACCESS FACILITY ERROR '
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ...........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D                   WORK AREA FOR NUMERIC CONVERSION
OUTSAVE  DS    A
         SPACE 1
CPARMS   DS    0A                  PARMS FOR CLIST VARIABLE ACCESS
         SPACE 1
CPARM1   DC    A(CENTRY)           POINTER TO ENTRY CODE
CPARM2   DC    A(CNAMEA)           POINTER TO ADDRESS OF VARIABLE NAME
CPARM3   DC    A(CNAMEL)           POINTER TO LENGTH OF VARIABLE NAME
CPARM4   DC    A(CVALUEA)          POINTER TO ADDRESS OF VARIABLE VALUE
CPARM5   DC    A(CVALUEL)          POINTER TO LENGTH OF VARIABLE VALUE
CPARM6   DC    A(CTOKEN)           POINTER TO TOKEN (NOT USED)
CPARM7   DS    A                   POINTER TO IPCS'S ECT
         SPACE 1
CENTRY   DC    A(TSVEUPDT)         ENTRY CODE FOR VARIABLE UPDATE
CNAMEA   DC    A(0)                ADDRESS OF VARIABLE NAME
CNAMEL   DC    A(0)                LENGTH OF VARIABLE NAME
CVALUEA  DC    A(0)                ADDRESS OF VARIABLE NAME
CVALUEL  DC    A(0)                LENGTH OF VARIABLE VALUE
CTOKEN   DC    A(0)                TOKEN (NOT USED)
         SPACE 1
YITHEX   DS    CL8                 VALUE OF CLIST VARIABLE
         DS    CL4                 PADDING
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL133               WORD AREA FOR OUTPUT LINES
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         EJECT
         IKJTCB
         EJECT
         IKJTSVT
         EJECT
         IKJCPPL
         EJECT
         CVT   DSECT=YES
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ADD NAME=YITSAV
         TITLE 'YITSAV - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   ('&LENGTH' EQ '(0)').GOTLEN
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'YITSAV - IPCS TCB EXIT TO DISPLAY SAVE AREA TRACE'
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3    DUMP STORAGE ACCESS REGISTER
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    ADDRESS OF OPERAND
R6       EQU   6    LENGTH OF OPERAND
R7       EQU   7    ADDRESS OF PREVIOUS SAVE AREA (COMPARE WITH HSA)
R8       EQU   8    TRUE ADDRESS OF CURRENT SAVE AREA
R9       EQU   9    ADDRESS OF DATA WHERE SAVEAREA'S R15 POINTS
R10      EQU   10   POINTER TO PARAMETER LIST EXTENSION
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
YITSAV   CSECT
         SAVE  (14,12),,YITSAV_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING YITSAV,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ADDRESS OF ABDPL
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO
         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION
         EJECT
PROCESS  DS    0H
         SPACE 1
         LOAD  EP=XIPSWHR          LOAD ADDRESS SEARCH ROUTINE
         ST    R0,WHRADDR
         SPACE 1
         XR    R7,R7               INITIALIZE HSA POINTER
         ICM   R3,15,ADPLTCB       ADDRESS OF FIRST SAVE AREA
         BNZ   LOOP                IF NONE, THEN...
         MVC   LINE(L'NOSAMSG),NOSAMSG SAY SO
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 1
LOOP     DS    0H
         LTR   R3,R3               UNTIL NO MORE
         BZ    ENDLOOP
         MVC   LINE(L'SAMSG),SAMSG "SAVE AREA AT "
         LR    R8,R3               TRUE ADDRESS OF THIS SAVE AREA
         ST    R8,OPWORK           DISPLAY IT
         UNPK  LINESAA+0(9),OPWORK(5)
         TR    LINESAA+0(8),HEXTBL
         MVI   LINESAA+8,C'.'
         GSTOR R3,72,ERRET=SANA    GET SAVE AREA FROM DUMP
         MVC   COPYSA(72),0(R3)    COPY INTO OUR WORK AREA
CONTLOOP DS    0H
         SPACE
         MVC   LINEL1(4),=C'WD1='
         UNPK  LINEN1(9),SAWD1(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'HSA='
         UNPK  LINEN2(9),SAHSA(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'LSA='
         UNPK  LINEN3(9),SALSA(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         BAL   R14,OUTPUT
         C     R7,SAHSA            CHECK HSA POINTER
         BE    HSAOK               IF IT DOESN'T MATCH, THEN...
         MVC   LINEL1(L'IBCMSG),IBCMSG
         BAL   R14,OUTPUT          NOTE INVALID BACK CHAIN
HSAOK    DS    0H
         LR    R7,R8               SET PREVIOUS-SAVE-AREA ADDRESS
         MVC   LINEL1(4),=C'R14='
         UNPK  LINEN1(9),SAR14(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         L     R0,SAR14
         BAL   R14,FINDMOD         RESOLVE RETURN ADDRESS
         BAL   R14,OUTPUT
         MVC   LINEL1(4),=C'R15='
         UNPK  LINEN1(9),SAR15(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         L     R0,SAR15
         BAL   R14,FINDMOD         RESOLVE ENTRY ADDRESS
         SPACE 1
         L     R9,FMWHERE          ADDRESS THAT HAS BEEN RESOLVED
         LTR   R9,R9               IF ZERO, IGNORE IT
         BZ    NOEP
         GSTOR R9,8,ERRET=NOEP     TRY TO GET ENTRY POINT DATA
         ICM   R0,15,0(R9)         GET ENTRY POINT INSTRUCTION
         N     R0,=X'FFFFF000'     AND OUT THE DISPLACEMENT
         CL    R0,=X'47F0F000'     IF IT IS NOT A BRANCH-AROUND
         BNE   NOEP                THEN NO EP DATA
         XR    R2,R2               CLEAR INSERT REG
         IC    R2,4(,R9)           GET LENGTH OF IDENTIFIER
         LTR   R2,R2               IF ZERO
         BZ    NOEP                THEN NO EP DATA
         CH    R2,=Y(EPLENGTH)     SET MAXIMUM LENGTH THAT WE CAN SHOW
         BNH   SETMAX
         LA    R2,EPLENGTH
SETMAX   DS    0H
         LA    R9,4
         A     R9,FMWHERE          POINT TO IDENTIFIER STUFF
         LA    R0,1+3(,R2)         SET LENGTH+1 AND PREPARE TO...
         N     R0,=X'FFFFFFFC'     ....ROUND UP TO FULLWORD BOUNDARY
         GSTOR R9,(0),ERRET=NOEP   GET DATA FOR THE LENGTH NEEDED
         MVC   LINEEP1(6),=CL6'AT EP '
         BCTR  R2,0                REDUCE LENGTH FOR EXECUTE
         EX    R2,EPMVC            TRANSLATE EP DATA
NOEP     DS    0H
         SPACE 1
         BAL   R14,OUTPUT
         MVC   LINEL1(4),=C'R0 ='
         UNPK  LINEN1(9),SAR00(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         BAL   R14,OUTPUT
         MVC   LINEL1(4),=C'R1 ='
         UNPK  LINEN1(9),SAR01(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'R2 ='
         UNPK  LINEN2(9),SAR02(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'R3 ='
         UNPK  LINEN3(9),SAR03(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         MVC   LINEL4(4),=C'R4 ='
         UNPK  LINEN4(9),SAR04(5)
         TR    LINEN4(8),HEXTBL
         MVI   LINEB4,C' '
         BAL   R14,OUTPUT
         SPACE
         MVC   LINEL1(4),=C'R5 ='
         UNPK  LINEN1(9),SAR05(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'R6 ='
         UNPK  LINEN2(9),SAR06(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'R7 ='
         UNPK  LINEN3(9),SAR07(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         MVC   LINEL4(4),=C'R8 ='
         UNPK  LINEN4(9),SAR08(5)
         TR    LINEN4(8),HEXTBL
         MVI   LINEB4,C' '
         BAL   R14,OUTPUT
         SPACE
         MVC   LINEL1(4),=C'R9 ='
         UNPK  LINEN1(9),SAR09(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'R10='
         UNPK  LINEN2(9),SAR10(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'R11='
         UNPK  LINEN3(9),SAR11(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         MVC   LINEL4(4),=C'R12='
         UNPK  LINEN4(9),SAR12(5)
         TR    LINEN4(8),HEXTBL
         MVI   LINEB4,C' '
         BAL   R14,OUTPUT
         SPACE
         BAL   R14,OUTPUT          JUST A BLANK LINE
         SPACE
         L     R3,SALSA            GET ADDRESS OF NEXT SAVE AREA
         B     LOOP                CONTINUE LOOPING
         SPACE 1
SANA     DS    0H                  SAVE AREA NOT AVAILABLE FROM DUMP
         SPACE 1
         MVC   LINE+L'SAMSG+08+2(L'SANAMSG),SANAMSG
         BAL   R14,OUTPUT
         B     ERROUT
         SPACE 1
ENDLOOP  DS    0H
         B     RETURN0
         SPACE 2
EPMVC    MVC   LINEEP2(0),1(R9)    EXECUTED
         EJECT
STORERR  DS    0H                  ERROR ACCESSING STORAGE
         MVC   LINE(L'ERRMSG),ERRMSG
******** B     ERROUT
         SPACE 1
ERROUT   DS    0H
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
FINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME
*                                  R0 CONTAINS ADDRESS TO SEARCH ON
         ST    R0,FMWHERE          STORE ADDRESS TO BE RESOLVED
         LTR   R0,R0               IF ADDRESS IS ZEROES,
         BZR   R14                 THEN PRINT NOTHING, NOT AN EP
         ST    R14,FMSAVE
         NI    FMWHERE,B'01111111' TURN OFF HIGH-ORDER BIT FOR ADDRESS
FMDOIT   DS    0H
         XR    R0,R0
         ST    R0,ADPLCOM1
         L     R0,FMWHERE
         LR    R1,R4
         L     R15,WHRADDR
         BASSM R14,R15
         CLI   ADPLFMT1,C' '
         BE    FMNF
         MVC   LINEMOD(16),ADPLCOM1
         B     FMRET
FMNF     DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* IF ADDRESS UNKNOWN, MAYBE THE HIGH-ORDER BYTE IS CONFUSING THE      *
* ADDRESS SEARCH ROUTINE.  SO WE SET IT TO ZEROES AND TRY AGAIN.      *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   FMWHERE,X'00'       IF IT'S ALREADY A 24-BIT ADDRESS
         BE    FMFAIL              THEN DON'T TRY AGAIN
         MVI   FMWHERE,X'00'       ELSE CHANGE IT TO A 24-BIT ADDRESS
         B     FMDOIT               TRY AGAIN WITH 0 IN H.O.BYTE
FMFAIL   DS    0H                  ELSE GIVE UP
         MVC   LINEMOD(16),=CL16'(UNKNOWN)       '
         XC    FMWHERE,FMWHERE
FMRET    DS    0H
         L     R14,FMSAVE
         BR    R14
         EJECT
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15             CALL IT
         LTR   R15,R15             IF LINE NOT PRINTED
         BNZ   RETURN0             THEN...
NORETYET DS    0H
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         DELETE EP=XIPSWHR
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
ERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'
NOSAMSG  DC    C'SAVEA AREA POINTER IS ZERO'
IBCMSG   DC    C'*** INVALID BACK CHAIN ***'
SANAMSG  DC    C'STORAGE UNAVAILABLE'
SAMSG    DC    C'SAVE AREA AT '
         SPACE
VALTBL   DC    256YL1(1)
         ORG   VALTBL+X'81'
         DC    6YL1(0)             LOWER CASE ABCDEF
         ORG   VALTBL+C'A'
         DC    6YL1(0)             UPPER CASE ABCDEF
         ORG   VALTBL+C'0'
         DC    10YL1(0)            0123456789
         ORG
         SPACE
FTBL     DC    256YL1(*-FTBL)
         ORG   FTBL+X'81'
         DC    X'FAFBFCFDFEFF'     LOWER CASE ABCDEF
         ORG   FTBL+C'A'
         DC    X'FAFBFCFDFEFF'     UPPER CASE ABCDEF
         ORG
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ...........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
OUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE
FMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE
FMWHERE  DS    A                   ADDRESS PASSED TO FINDMOD SUBROUTINE
WHRADDR  DS    A                   ADDRESS OF XIPSWHR, SEARCH ROUTINE
         DS    XL1                 PADDING FOR CONVERSION
OPWORK   DS    0F,CL9              WORK AREA FOR OPERAND CONVERSION
COPYSA   DS    18F                 WORK AREA FOR SAVE AREA
         ORG   COPYSA
SAWD1    DS    F                   00 = FIRST WORD
SAHSA    DS    F                   04 = HSA
SALSA    DS    F                   08 = LSA
SAR14    DS    F                   0C = REG14
SAR15    DS    F                   10 = REG15
SAR00    DS    F                   14 = REG0
SAR01    DS    F                   18 = REG1
SAR02    DS    F                   1C = REG2
SAR03    DS    F                   20 = REG3
SAR04    DS    F                   24 = REG4
SAR05    DS    F                   28 = REG5
SAR06    DS    F                   2C = REG6
SAR07    DS    F                   30 = REG7
SAR08    DS    F                   34 = REG8
SAR09    DS    F                   38 = REG9
SAR10    DS    F                   3C = REG10
SAR11    DS    F                   40 = REG11
SAR12    DS    F                   44 = REG12
         ORG
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL133               WORD AREA FOR OUTPUT LINES
         ORG   LINE
         DS    CL(L'SAMSG)         "SAVE AREA AT "
LINESAA  DS    CL8                 ADDRESS OF SAVE AREA
         DS    CL2                 "  "
LINEL1   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN1   DS    CL8                 "NNNNNNNN"
LINEB1   DS    CL1                 " "
LINEL2   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN2   DS    CL8                 "NNNNNNNN"
LINEB2   DS    CL1                 " "
LINEL3   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN3   DS    CL8                 "NNNNNNNN"
LINEB3   DS    CL1                 " "
LINEL4   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN4   DS    CL8                 "NNNNNNNN"
LINEB4   DS    CL1                 " "
LINEL5   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN5   DS    CL8                 "NNNNNNNN"
LINEB5   DS    CL1                 " "
         ORG   LINEL2
         DS    CL1
LINEMOD  DS    CL16                "WHERE" DATA
         DS    CL1
LINEEP1  DS    CL6                 "AT EP "
LINEEP2  DS    CL(EPLENGTH)
         SPACE 1
EPLENGTH EQU   78-(LINEEP2-LINE)
         ORG
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 2
         IKJTCB
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ADD NAME=YITWHR
         TITLE 'YITWHR - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'YITWHR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'
         SPACE 1
***********************************************************************
*                                                                     *
* THIS IS AN IPCS TCB EXIT THAT, GIVEN AN ADDRESS (WHICH IS NOT       *
* REALLY A TCB ADDRESS AFTER ALL), REPORTS ON WHAT LOAD MODULE THE    *
* ADDRESS LIVES IN AS WELL AS THE OFFSET.  UNLIKE THE XITWHR EXIT,    *
* HOWEVER, THIS ROUTINE DOES NOT DISPLAY THE INFO, BUT RETURNS THE    *
* VALUES AS CLIST VARIABLES (JEEZ, I HOPE THIS WORKS).                *
*                                                                     *
***********************************************************************
         SPACE 1
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    ADDRESS OF OPERAND
R6       EQU   6    LENGTH OF OPERAND
R7       EQU   7    POINTER TO CDE
R8       EQU   8    USED IN NUCMAP SCANNING
R9       EQU   9    USED IN NUCMAP SCANNING
R10      EQU   10   POINTER TO PARAMETER LIST EXTENSION
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
YITWHR   CSECT
         SAVE  (14,12),,YITWHR_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING YITWHR,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO
         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION
         EJECT
* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.
* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES
* THE CORRECT ASID, ETC.
         SPACE 1
         XR    R0,R0
         ST    R0,ADPLCOM1         Clear communication word
         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE
         LR    R1,R4               GET ADDRESS OF ABDPL
         SPACE 1
         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE
         SPACE 1
         MVI   YITPLACE,C' '
         MVC   YITPLACE+1(L'YITPLACE-1),YITPLACE
         MVI   YITNAME,C' '
         MVC   YITNAME+1(L'YITNAME-1),YITNAME
         MVI   YITLOC,C' '
         MVC   YITLOC+1(L'YITLOC-1),YITLOC
*
* SET YITPLACE = THE AREA WHERE IT WAS FOUND: JPA/PLPA/MLPA/NUC/ERR
*
         MVC   YITPLACE(4),ADPLFMT1
         CLI   YITPLACE,C' '
         BE    YITERROR
         CLI   YITPLACE,C'E'
         BE    YITERRNP
         B     YITOK
YITERROR DS    0H                  ERROR - MODULE NOT FOUND
         MVC   YITPLACE(11),=C'UNAVAILABLE'
YITERRNP DS    0H                  STORAGE ERROR - RETAIN YITPLACE
         MVC   YITNAME(11),=C'UNAVAILABLE'
         MVC   YITLOC(11),=C'UNAVAILABLE'
         B     YITSET
YITOK    DS    0H
*
* SET YITNAME = THE NAME OF THE LOAD MODULE
*
         MVC   YITNAME(8),ADPLCOM1
*
* SET YITLOC = THE OFFSET OF THE ADDRESS WITHIN THE LOAD MODULE
*
         L     R0,ADPLFMT2
         CVD   R0,DOUBLE
         UNPK  YITLOC(10),DOUBLE
         OI    YITLOC+9,X'F0'
         SPACE 1
YITSET   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* OK, NOW INVOKE THE CLIST VARIABLE ACCESS FACILITY TO SET THE        *
* THREE VALUES AS CLIST VARIABLES.                                    *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R14,CENTRY
         LA    R15,CNAMEA
         LA    R0,CNAMEL
         LA    R1,CVALUEA
         LA    R2,CVALUEL
         LA    R3,CTOKEN
         STM   R14,R3,CPARM1
         OI    CPARM6,X'80'
         LA    R0,TSVEUPDT
         ST    R0,CENTRY
         XR    R0,0
         ST    R0,CNAMEA           ADDRESS OF VARIABLE NAME
         ST    R0,CNAMEL           LENGTH OF VARIABLE NAME
         ST    R0,CVALUEA          ADDRESS OF VARIABLE VALUE
         ST    R0,CVALUEL          LENGTH OF VARIABLE VALUE
*
* SET YITPLACE
*
         LA    R14,=C'YITPLACE'
         LA    R15,8
         LA    R0,YITPLACE
         LA    R1,L'YITPLACE
         STM   R14,R1,CNAMEA
         BAL   R2,CALL441
*
* SET YITNAME
*
         LA    R14,=C'YITNAME'
         LA    R15,7
         LA    R0,YITNAME
         LA    R1,L'YITNAME
         STM   R14,R1,CNAMEA
         BAL   R2,CALL441
*
* SET YITLOC
*
         LA    R14,=C'YITLOC'
         LA    R15,6
         LA    R0,YITLOC
         LA    R1,L'YITLOC
         STM   R14,R1,CNAMEA
         BAL   R2,CALL441
*
* RETURN TO CALLER
*
         B     RETURN0
         SPACE 2
CALL441  DS    0H
         LA    R1,CPARM1           POINT TO PARAMETER LIST
         L     R15,X'10'               GET ADDRESS OF CVT
         L     R15,CVTTVT-CVT(,R15)    GET ADDRESS OF TSO VECTOR TABLE
         L     R15,TSVTVACC-TSVT(,R15) GET ADDRESS OF IKJCT441
         BALR  R14,R15             CALL CLIST VARIABLE ACCESS ROUTINE
         LTR   R15,R15             IF RETURN CODE IS ZERO
         BZR   R2                  THEN EVERYTHING IS OK
         MVC   LINE(L'ERR441),ERR441
         CVD   R15,DOUBLE
         UNPK  LINE+L'ERR441(2),DOUBLE
         OI    LINE+L'ERR441+1,X'F0'
         BAL   R14,OUTPUT
         BR    R2
         SPACE 2
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15             CALL IT
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
ERR441   DC    C'YITWHR: CLIST VARIABLE ACCESS FACILITY ERROR '
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ...........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D                   WORK AREA FOR NUMERIC CONVERSION
OUTSAVE  DS    A
         SPACE 1
CPARMS   DS    0A                  PARMS FOR CLIST VARIABLE ACCESS
         SPACE 1
CPARM1   DC    A(CENTRY)           POINTER TO ENTRY CODE
CPARM2   DC    A(CNAMEA)           POINTER TO ADDRESS OF VARIABLE NAME
CPARM3   DC    A(CNAMEL)           POINTER TO LENGTH OF VARIABLE NAME
CPARM4   DC    A(CVALUEA)          POINTER TO ADDRESS OF VARIABLE VALUE
CPARM5   DC    A(CVALUEL)          POINTER TO LENGTH OF VARIABLE VALUE
CPARM6   DC    A(CTOKEN)           POINTER TO TOKEN (NOT USED)
         SPACE 1
CENTRY   DC    A(TSVEUPDT)         ENTRY CODE FOR VARIABLE UPDATE
CNAMEA   DC    A(0)                ADDRESS OF VARIABLE NAME
CNAMEL   DC    A(0)                LENGTH OF VARIABLE NAME
CVALUEA  DC    A(0)                ADDRESS OF VARIABLE NAME
CVALUEL  DC    A(0)                LENGTH OF VARIABLE VALUE
CTOKEN   DC    A(0)                TOKEN (NOT USED)
         SPACE 1
YITPLACE DS    CL11                VALUE OF CLIST VARIABLE
YITNAME  DS    CL11                VALUE OF CLIST VARIABLE
YITLOC   DS    CL11                VALUE OF CLIST VARIABLE
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL133               WORD AREA FOR OUTPUT LINES
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 2
         IHACDE
         EJECT
         IHAXTLST
         EJECT
         IHALPDE
         EJECT
         IKJTCB
         EJECT
         IKJTSVT
         EJECT
         CVT   DSECT=YES
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ENDUP
?!
